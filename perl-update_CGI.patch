diff -up perl-5.10.1/lib/CGI/Apache.pm.cgiup perl-5.10.1/lib/CGI/Apache.pm
--- perl-5.10.1/lib/CGI/Apache.pm.cgiup	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/Apache.pm	2011-01-05 19:13:45.000000000 +0100
@@ -1,6 +1,7 @@
+package CGI::Apache;
 use CGI;
 
-$VERSION = '1.00';
+$VERSION = '1.01';
 
 1;
 __END__
diff -up perl-5.10.1/lib/CGI/Carp.pm.cgiup perl-5.10.1/lib/CGI/Carp.pm
--- perl-5.10.1/lib/CGI/Carp.pm.cgiup	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/Carp.pm	2011-01-05 19:13:45.000000000 +0100
@@ -70,6 +70,8 @@ compiler errors will be caught.  Example
    }
 
 carpout() does not handle file locking on the log for you at this point.
+Also, note that carpout() does not work with in-memory file handles, although
+a patch would be welcome to address that.
 
 The real STDERR is not closed -- it is moved to CGI::Carp::SAVEERR.  Some
 servers, when dealing with CGI scripts, close their connection to the
@@ -77,7 +79,7 @@ browser when the script closes STDOUT an
 prevent this from happening prematurely.
 
 You can pass filehandles to carpout() in a variety of ways.  The "correct"
-way according to Tom Christiansen is to pass a reference to a filehandle 
+way according to Tom Christiansen is to pass a reference to a filehandle
 GLOB:
 
     carpout(\*LOG);
@@ -114,7 +116,7 @@ occur in the early compile phase will be
 Nonfatal errors will still be directed to the log file only (unless redirected
 with carpout).
 
-Note that fatalsToBrowser does B<not> work with mod_perl version 2.0
+Note that fatalsToBrowser may B<not> work well with mod_perl version 2.0
 and higher.
 
 =head2 Changing the default message
@@ -181,6 +183,28 @@ attempting to set SIG{__DIE__} yourself,
 this module's functionality, or this module may interfere with 
 your module's functionality.
 
+=head2 SUPPRESSING PERL ERRORS APPEARING IN THE BROWSER WINDOW
+
+A problem sometimes encountered when using fatalsToBrowser is
+when a C<die()> is done inside an C<eval> body or expression.
+Even though the
+fatalsToBrower support takes precautions to avoid this,
+you still may get the error message printed to STDOUT.
+This may have some undesireable effects when the purpose of doing the
+eval is to determine which of several algorithms is to be used.
+
+By setting C<$CGI::Carp::TO_BROWSER> to 0 you can suppress printing the C<die> messages
+but without all of the complexity of using C<set_die_handler>.
+You can localize this effect to inside C<eval> bodies if this is desireable:
+For example:
+
+ eval {
+   local $CGI::Carp::TO_BROWSER = 0;
+   die "Fatal error messages not sent browser"
+ }
+ # $@ will contain error message
+
+
 =head1 MAKING WARNINGS APPEAR AS HTML COMMENTS
 
 It is now also possible to make non-fatal errors appear as HTML
@@ -243,6 +267,8 @@ non-overridden program name
   
 =head1 CHANGE LOG
 
+3.51 Added $CGI::Carp::TO_BROWSER
+
 1.29 Patch from Peter Whaite to fix the unfixable problem of CGI::Carp
      not behaving correctly in an eval() context.
 
@@ -300,10 +326,6 @@ Address bug reports and comments to: lst
 
 Carp, CGI::Base, CGI::BasePlus, CGI::Request, CGI::MiniSvr, CGI::Form,
 CGI::Response
-    if (defined($CGI::Carp::PROGNAME)) 
-    {
-      $file = $CGI::Carp::PROGNAME;
-    }
 
 =cut
 
@@ -323,9 +345,10 @@ use File::Spec;
 
 $main::SIG{__WARN__}=\&CGI::Carp::warn;
 
-$CGI::Carp::VERSION     = '1.30_01';
+$CGI::Carp::VERSION     = '3.51';
 $CGI::Carp::CUSTOM_MSG  = undef;
 $CGI::Carp::DIE_HANDLER = undef;
+$CGI::Carp::TO_BROWSER  = 1;
 
 
 # fancy import routine detects and handles 'errorWrap' specially.
@@ -423,37 +446,32 @@ sub ineval {
 }
 
 sub die {
-  my ($arg,@rest) = @_;
+    # if no argument is passed, propagate $@ like
+    # the real die
+  my ($arg,@rest) = @_ ? @_ 
+                  : $@ ? "$@\t...propagated" 
+                  :      "Died"
+                  ;
 
-  if ($DIE_HANDLER) {
-      &$DIE_HANDLER($arg,@rest);
-  }
+  &$DIE_HANDLER($arg,@rest) if $DIE_HANDLER;
 
-  if ( ineval() )  {
-    if (!ref($arg)) {
-      $arg = join("",($arg,@rest)) || "Died";
-      my($file,$line,$id) = id(1);
-      $arg .= " at $file line $line.\n" unless $arg=~/\n$/;
-      realdie($arg);
-    }
-    else {
-      realdie($arg,@rest);
-    }
-  }
+  # the "$arg" is done on purpose!
+  # if called as die( $object, 'string' ),
+  # all is stringified, just like with
+  # the real 'die'
+  $arg = join '' => "$arg", @rest if @rest;
+
+  my($file,$line,$id) = id(1);
+
+  $arg .= " at $file line $line.\n" unless ref $arg or $arg=~/\n$/;
+
+  realdie $arg           if ineval();
+  &fatalsToBrowser($arg) if ($WRAP and $CGI::Carp::TO_BROWSER);
+
+  $arg=~s/^/ stamp() /gme if $arg =~ /\n$/ or not exists $ENV{MOD_PERL};
+
+  $arg .= "\n" unless $arg =~ /\n$/;
 
-  if (!ref($arg)) {
-    $arg = join("", ($arg,@rest));
-    my($file,$line,$id) = id(1);
-    $arg .= " at $file line $line." unless $arg=~/\n$/;
-    &fatalsToBrowser($arg) if $WRAP;
-    if (($arg =~ /\n$/) || !exists($ENV{MOD_PERL})) {
-      my $stamp = stamp;
-      $arg=~s/^/$stamp/gm;
-    }
-    if ($arg !~ /\n$/) {
-      $arg .= "\n";
-    }
-  }
   realdie $arg;
 }
 
@@ -505,11 +523,15 @@ sub warningsToBrowser {
 
 # headers
 sub fatalsToBrowser {
-  my($msg) = @_;
+  my $msg = shift;
+
+  $msg = "$msg" if ref $msg;
+
   $msg=~s/&/&amp;/g;
   $msg=~s/>/&gt;/g;
   $msg=~s/</&lt;/g;
-  $msg=~s/\"/&quot;/g;
+  $msg=~s/"/&quot;/g;
+
   my($wm) = $ENV{SERVER_ADMIN} ? 
     qq[the webmaster (<a href="mailto:$ENV{SERVER_ADMIN}">$ENV{SERVER_ADMIN}</a>)] :
       "this site's webmaster";
@@ -524,7 +546,11 @@ END
     if (ref($CUSTOM_MSG) eq 'CODE') {
       print STDOUT "Content-type: text/html\n\n" 
         unless $mod_perl;
-      &$CUSTOM_MSG($msg); # nicer to perl 5.003 users
+        eval { 
+            &$CUSTOM_MSG($msg); # nicer to perl 5.003 users
+        };
+        if ($@) { print STDERR q(error while executing the error handler: $@); }
+
       return;
     } else {
       $outer_message = $CUSTOM_MSG;
diff -up perl-5.10.1/lib/CGI/Cookie.pm.cgiup perl-5.10.1/lib/CGI/Cookie.pm
--- perl-5.10.1/lib/CGI/Cookie.pm.cgiup	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/Cookie.pm	2011-01-05 19:14:15.000000000 +0100
@@ -1,5 +1,8 @@
 package CGI::Cookie;
 
+use strict;
+use warnings;
+
 # See the bottom of this file for the POD documentation.  Search for the
 # string '=head'.
 
@@ -9,21 +12,23 @@ package CGI::Cookie;
 
 # Copyright 1995-1999, Lincoln D. Stein.  All rights reserved.
 # It may be used and modified freely, but I do request that this copyright
-# notice remain attached to the file.  You may modify this module as you 
+# notice remain attached to the file.  You may modify this module as you
 # wish, but if you redistribute a modified version, please attach a note
 # listing the modifications you have made.
 
-$CGI::Cookie::VERSION='1.29';
+our $VERSION='1.30';
 
 use CGI::Util qw(rearrange unescape escape);
-use CGI;
-use overload '""' => \&as_string,
-    'cmp' => \&compare,
-    'fallback'=>1;
+use overload '""' => \&as_string, 'cmp' => \&compare, 'fallback' => 1;
+
+my $PERLEX = 0;
+# Turn on special checking for ActiveState's PerlEx
+$PERLEX++ if defined($ENV{'GATEWAY_INTERFACE'}) && $ENV{'GATEWAY_INTERFACE'} =~ /^CGI-PerlEx/;
 
-# Turn on special checking for Doug MacEachern's modperl
+# Turn on special checking for mod_perl
+# PerlEx::DBI tries to fool DBI by setting MOD_PERL
 my $MOD_PERL = 0;
-if (exists $ENV{MOD_PERL}) {
+if (exists $ENV{MOD_PERL} && ! $PERLEX) {
   if (exists $ENV{MOD_PERL_API_VERSION} && $ENV{MOD_PERL_API_VERSION} == 2) {
       $MOD_PERL = 2;
       require Apache2::RequestUtil;
@@ -52,20 +57,14 @@ sub fetch {
    my($key,$value);
    
    my @pairs = split("[;,] ?",$raw_cookie);
-   foreach (@pairs) {
-     s/\s*(.*?)\s*/$1/;
-     if (/^([^=]+)=(.*)/) {
-       $key = $1;
-       $value = $2;
-     }
-     else {
-       $key = $_;
-       $value = '';
-     }
-     $results{$key} = $value;
-   }
-   return \%results unless wantarray;
-   return %results;
+  for my $pair ( @pairs ) {
+    $pair =~ s/^\s+|\s+$//g;    # trim leading trailing whitespace
+    my ( $key, $value ) = split "=", $pair;
+
+    $value = defined $value ? $value : '';
+    $results{$key} = $value;
+  }
+  return wantarray ? %results : \%results;
 }
 
 sub get_raw_cookie {
@@ -73,24 +72,27 @@ sub get_raw_cookie {
   $r ||= eval { $MOD_PERL == 2                    ? 
                   Apache2::RequestUtil->request() :
                   Apache->request } if $MOD_PERL;
-  if ($r) {
-    $raw_cookie = $r->headers_in->{'Cookie'};
-  } else {
-    if ($MOD_PERL && !exists $ENV{REQUEST_METHOD}) {
-      die "Run $r->subprocess_env; before calling fetch()";
-    }
-    $raw_cookie = $ENV{HTTP_COOKIE} || $ENV{COOKIE};
-  }
+
+  return $r->headers_in->{'Cookie'} if $r;
+
+  die "Run $r->subprocess_env; before calling fetch()" 
+    if $MOD_PERL and !exists $ENV{REQUEST_METHOD};
+    
+  return $ENV{HTTP_COOKIE} || $ENV{COOKIE};
 }
 
 
 sub parse {
   my ($self,$raw_cookie) = @_;
+  return wantarray ? () : {} unless $raw_cookie;
+
   my %results;
 
   my @pairs = split("[;,] ?",$raw_cookie);
-  foreach (@pairs) {
-    s/\s*(.*?)\s*/$1/;
+  for (@pairs) {
+    s/^\s+//;
+    s/\s+$//;
+
     my($key,$value) = split("=",$_,2);
 
     # Some foreign cookies are not in name=value format, so ignore
@@ -106,48 +108,37 @@ sub parse {
     # appear.  The FIRST one in HTTP_COOKIE is the most recent version.
     $results{$key} ||= $self->new(-name=>$key,-value=>\@values);
   }
-  return \%results unless wantarray;
-  return %results;
+  return wantarray ? %results : \%results;
 }
 
 sub new {
-  my $class = shift;
-  $class = ref($class) if ref($class);
-  # Ignore mod_perl request object--compatability with Apache::Cookie.
-  shift if ref $_[0]
-        && eval { $_[0]->isa('Apache::Request::Req') || $_[0]->isa('Apache') };
-  my($name,$value,$path,$domain,$secure,$expires,$httponly) =
-    rearrange([NAME,[VALUE,VALUES],PATH,DOMAIN,SECURE,EXPIRES,HTTPONLY],@_);
-  
-  # Pull out our parameters.
-  my @values;
-  if (ref($value)) {
-    if (ref($value) eq 'ARRAY') {
-      @values = @$value;
-    } elsif (ref($value) eq 'HASH') {
-      @values = %$value;
-    }
-  } else {
-    @values = ($value);
-  }
-  
-  bless my $self = {
-		    'name'=>$name,
-		    'value'=>[@values],
-		   },$class;
-
-  # IE requires the path and domain to be present for some reason.
-  $path   ||= "/";
-  # however, this breaks networks which use host tables without fully qualified
-  # names, so we comment it out.
-  #    $domain = CGI::virtual_host()    unless defined $domain;
-
-  $self->path($path)     if defined $path;
-  $self->domain($domain) if defined $domain;
-  $self->secure($secure) if defined $secure;
-  $self->expires($expires) if defined $expires;
-  $self->httponly($httponly) if defined $httponly;
-#  $self->max_age($expires) if defined $expires;
+  my ( $class, @params ) = @_;
+  $class = ref( $class ) || $class;
+  # Ignore mod_perl request object--compatibility with Apache::Cookie.
+  shift if ref $params[0]
+        && eval { $params[0]->isa('Apache::Request::Req') || $params[0]->isa('Apache') };
+  my ( $name, $value, $path, $domain, $secure, $expires, $max_age, $httponly )
+   = rearrange(
+    [
+      'NAME', [ 'VALUE', 'VALUES' ],
+      'PATH',   'DOMAIN',
+      'SECURE', 'EXPIRES',
+      'MAX-AGE','HTTPONLY'
+    ],
+    @params
+   );
+  return undef unless defined $name and defined $value;
+  my $self = {};
+  bless $self, $class;
+  $self->name( $name );
+  $self->value( $value );
+  $path ||= "/";
+  $self->path( $path )         if defined $path;
+  $self->domain( $domain )     if defined $domain;
+  $self->secure( $secure )     if defined $secure;
+  $self->expires( $expires )   if defined $expires;
+  $self->max_age($expires)     if defined $max_age;
+  $self->httponly( $httponly ) if defined $httponly;
   return $self;
 }
 
@@ -155,23 +146,24 @@ sub as_string {
     my $self = shift;
     return "" unless $self->name;
 
-    my(@constant_values,$domain,$path,$expires,$max_age,$secure,$httponly);
+    no warnings; # some things may be undefined, that's OK.
 
-    push(@constant_values,"domain=$domain")   if $domain = $self->domain;
-    push(@constant_values,"path=$path")       if $path = $self->path;
-    push(@constant_values,"expires=$expires") if $expires = $self->expires;
-    push(@constant_values,"max-age=$max_age") if $max_age = $self->max_age;
-    push(@constant_values,"secure") if $secure = $self->secure;
-    push(@constant_values,"HttpOnly") if $httponly = $self->httponly;
-
-    my($key) = escape($self->name);
-    my($cookie) = join("=",(defined $key ? $key : ''),join("&",map escape(defined $_ ? $_ : ''),$self->value));
-    return join("; ",$cookie,@constant_values);
+    my $name  = escape( $self->name );
+    my $value = join "&", map { escape($_) } $self->value;
+    my @cookie = ( "$name=$value" );
+
+    push @cookie,"domain=".$self->domain   if $self->domain;
+    push @cookie,"path=".$self->path       if $self->path;
+    push @cookie,"expires=".$self->expires if $self->expires;
+    push @cookie,"max-age=".$self->max_age if $self->max_age;
+    push @cookie,"secure"                  if $self->secure;
+    push @cookie,"HttpOnly"                if $self->httponly;
+
+    return join "; ", @cookie;
 }
 
 sub compare {
-    my $self = shift;
-    my $value = shift;
+    my ( $self, $value ) = @_;
     return "$self" cmp $value;
 }
 
@@ -186,6 +178,7 @@ sub bake {
   if ($r) {
       $r->headers_out->add('Set-Cookie' => $self->as_string);
   } else {
+      require CGI;
       print CGI::header(-cookie => $self);
   }
 
@@ -193,70 +186,56 @@ sub bake {
 
 # accessors
 sub name {
-    my $self = shift;
-    my $name = shift;
+    my ( $self, $name ) = @_;
     $self->{'name'} = $name if defined $name;
     return $self->{'name'};
 }
 
 sub value {
-    my $self = shift;
-    my $value = shift;
-      if (defined $value) {
-              my @values;
-        if (ref($value)) {
-            if (ref($value) eq 'ARRAY') {
-                @values = @$value;
-            } elsif (ref($value) eq 'HASH') {
-                @values = %$value;
-            }
-        } else {
-            @values = ($value);
-        }
-      $self->{'value'} = [@values];
-      }
-    return wantarray ? @{$self->{'value'}} : $self->{'value'}->[0]
+  my ( $self, $value ) = @_;
+  if ( defined $value ) {
+    my @values
+     = ref $value eq 'ARRAY' ? @$value
+     : ref $value eq 'HASH'  ? %$value
+     :                         ( $value );
+    $self->{'value'} = [@values];
+  }
+  return wantarray ? @{ $self->{'value'} } : $self->{'value'}->[0];
 }
 
 sub domain {
-    my $self = shift;
-    my $domain = shift;
+    my ( $self, $domain ) = @_;
     $self->{'domain'} = lc $domain if defined $domain;
     return $self->{'domain'};
 }
 
 sub secure {
-    my $self = shift;
-    my $secure = shift;
+    my ( $self, $secure ) = @_;
     $self->{'secure'} = $secure if defined $secure;
     return $self->{'secure'};
 }
 
 sub expires {
-    my $self = shift;
-    my $expires = shift;
+    my ( $self, $expires ) = @_;
     $self->{'expires'} = CGI::Util::expires($expires,'cookie') if defined $expires;
     return $self->{'expires'};
 }
 
 sub max_age {
-  my $self = shift;
-  my $expires = shift;
-  $self->{'max-age'} = CGI::Util::expire_calc($expires)-time() if defined $expires;
-  return $self->{'max-age'};
+    my ( $self, $max_age ) = @_;
+    $self->{'max-age'} = CGI::Util::expire_calc($max_age)-time() if defined $max_age;
+    return $self->{'max-age'};
 }
 
 sub path {
-    my $self = shift;
-    my $path = shift;
+    my ( $self, $path ) = @_;
     $self->{'path'} = $path if defined $path;
     return $self->{'path'};
 }
 
 
 sub httponly { # HttpOnly
-    my $self     = shift;
-    my $httponly = shift;
+    my ( $self, $httponly ) = @_;
     $self->{'httponly'} = $httponly if defined $httponly;
     return $self->{'httponly'};
 }
@@ -265,7 +244,7 @@ sub httponly { # HttpOnly
 
 =head1 NAME
 
-CGI::Cookie - Interface to Netscape Cookies
+CGI::Cookie - Interface to HTTP Cookies
 
 =head1 SYNOPSIS
 
@@ -273,23 +252,23 @@ CGI::Cookie - Interface to Netscape Cook
     use CGI::Cookie;
 
     # Create new cookies and send them
-    $cookie1 = new CGI::Cookie(-name=>'ID',-value=>123456);
-    $cookie2 = new CGI::Cookie(-name=>'preferences',
+    $cookie1 = CGI::Cookie->new(-name=>'ID',-value=>123456);
+    $cookie2 = CGI::Cookie->new(-name=>'preferences',
                                -value=>{ font => Helvetica,
                                          size => 12 } 
                                );
     print header(-cookie=>[$cookie1,$cookie2]);
 
     # fetch existing cookies
-    %cookies = fetch CGI::Cookie;
+    %cookies = CGI::Cookie->fetch;
     $id = $cookies{'ID'}->value;
 
     # create cookies returned from an external source
-    %cookies = parse CGI::Cookie($ENV{COOKIE});
+    %cookies = CGI::Cookie->parse($ENV{COOKIE});
 
 =head1 DESCRIPTION
 
-CGI::Cookie is an interface to Netscape (HTTP/1.1) cookies, an
+CGI::Cookie is an interface to HTTP/1.1 cookies, an
 innovation that allows Web servers to store persistent information on
 the browser's side of the connection.  Although CGI::Cookie is
 intended to be used in conjunction with CGI.pm (and is in fact used by
@@ -297,7 +276,9 @@ it internally), you can use this module 
 
 For full information on cookies see 
 
-	http://www.ics.uci.edu/pub/ietf/http/rfc2109.txt
+	http://tools.ietf.org/html/rfc2109
+	http://tools.ietf.org/html/rfc2965
+	http://tools.ietf.org/html/draft-ietf-httpstate-cookie
 
 =head1 USING CGI::Cookie
 
@@ -324,7 +305,7 @@ the user quits the browser.
 This is a partial or complete domain name for which the cookie is 
 valid.  The browser will return the cookie to any host that matches
 the partial domain name.  For example, if you specify a domain name
-of ".capricorn.com", then Netscape will return the cookie to
+of ".capricorn.com", then the browser will return the cookie to
 Web servers running on any of the machines "www.capricorn.com", 
 "ftp.capricorn.com", "feckless.capricorn.com", etc.  Domain names
 must contain at least two periods to prevent attempts to match
@@ -347,24 +328,25 @@ that all scripts at your site will recei
 If the "secure" attribute is set, the cookie will only be sent to your
 script if the CGI request is occurring on a secure channel, such as SSL.
 
-=item B<4. httponly flag>
+=item B<5. httponly flag>
 
 If the "httponly" attribute is set, the cookie will only be accessible
 through HTTP Requests. This cookie will be inaccessible via JavaScript
 (to prevent XSS attacks).
 
-But, currently this feature only used and recognised by 
-MS Internet Explorer 6 Service Pack 1 and later.
+This feature is only supported by recent browsers like Internet Explorer
+6 Service Pack 1, Firefox 3.0 and Opera 9.5 (and later of course).
 
-See this URL for more information:
+See these URLs for more information:
 
-L<http://msdn.microsoft.com/workshop/author/dhtml/httponly_cookies.asp>
+	http://msdn.microsoft.com/en-us/library/ms533046.aspx
+	http://www.owasp.org/index.php/HTTPOnly#Browsers_Supporting_HTTPOnly
 
 =back
 
 =head2 Creating New Cookies
 
-	my $c = new CGI::Cookie(-name    =>  'foo',
+	my $c = CGI::Cookie->new(-name    =>  'foo',
                              -value   =>  'bar',
                              -expires =>  '+3M',
                              -domain  =>  '.capricorn.com',
@@ -382,6 +364,14 @@ B<-expires> accepts any of the relative 
 recognized by CGI.pm, for example "+3M" for three months in the
 future.  See CGI.pm's documentation for details.
 
+B<-max-age> accepts the same data formats as B<< -expires >>, but sets a
+relative value instead of an absolute like B<< -expires >>. This is intended to be
+more secure since a clock could be changed to fake an absolute time. In
+practice, as of 2011, C<< -max-age >> still does not enjoy the widespread support
+that C<< -expires >> has. You can set both, and browsers that support
+C<< -max-age >> should ignore the C<< Expires >> header. The drawback
+to this approach is the bit of bandwidth for sending an extra header on each cookie.
+
 B<-domain> points to a domain name or to a fully qualified host name.
 If not specified, the cookie will be returned only to the Web server
 that created it.
@@ -401,7 +391,7 @@ For compatibility with Apache::Cookie, y
 a mod_perl request object as the first argument to C<new()>. It will
 simply be ignored:
 
-  my $c = new CGI::Cookie($r,
+  my $c = CGI::Cookie->new($r,
                           -name    =>  'foo',
                           -value   =>  ['bar','baz']);
 
@@ -412,6 +402,10 @@ method:
 
   $c->bake;
 
+This will print the Set-Cookie HTTP header to STDOUT using CGI.pm. CGI.pm
+will be loaded for this purpose if it is not already. Otherwise CGI.pm is not
+required or used by this module.
+
 Under mod_perl, pass in an Apache request object:
 
   $c->bake($r);
@@ -420,7 +414,7 @@ If you want to set the cookie yourself, 
 a cookie to the browser by creating one or more Set-Cookie: fields in the
 HTTP header.  Here is a typical sequence:
 
-  my $c = new CGI::Cookie(-name    =>  'foo',
+  my $c = CGI::Cookie->new(-name    =>  'foo',
                           -value   =>  ['bar','baz'],
                           -expires =>  '+3M');
 
@@ -448,14 +442,14 @@ representation.  You may call as_string(
 
 =head2 Recovering Previous Cookies
 
-	%cookies = fetch CGI::Cookie;
+	%cookies = CGI::Cookie->fetch;
 
 B<fetch> returns an associative array consisting of all cookies
 returned by the browser.  The keys of the array are the cookie names.  You
 can iterate through the cookies this way:
 
-	%cookies = fetch CGI::Cookie;
-	foreach (keys %cookies) {
+	%cookies = CGI::Cookie->fetch;
+	for (keys %cookies) {
 	   do_something($cookies{$_});
         }
 
@@ -471,13 +465,16 @@ You may also retrieve cookies that were 
 form using the parse() class method:
 
        $COOKIES = `cat /usr/tmp/Cookie_stash`;
-       %cookies = parse CGI::Cookie($COOKIES);
+       %cookies = CGI::Cookie->parse($COOKIES);
 
 If you are in a mod_perl environment, you can save some overhead by
 passing the request object to fetch() like this:
 
    CGI::Cookie->fetch($r);
 
+If the value passed to parse() is undefined, an empty array will returned in list
+contact, and an empty hashref will be returned in scalar context.
+
 =head2 Manipulating Cookies
 
 Cookie objects have a series of accessor methods to get and set cookie
@@ -538,4 +535,6 @@ This section intentionally left blank.
 
 L<CGI::Carp>, L<CGI>
 
+L<RFC 2109|http://www.ietf.org/rfc/rfc2109.txt>, L<RFC 2695|http://www.ietf.org/rfc/rfc2965.txt>
+
 =cut
diff -up perl-5.10.1/lib/CGI/Fast.pm.cgiup perl-5.10.1/lib/CGI/Fast.pm
--- perl-5.10.1/lib/CGI/Fast.pm.cgiup	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/Fast.pm	2011-01-05 19:13:45.000000000 +0100
@@ -1,4 +1,10 @@
 package CGI::Fast;
+use strict;
+
+# A way to say "use warnings" that's compatible with even older perls.
+# making it local will not affect the code that loads this module
+# and since we're not in a BLOCK, warnings are enabled until the EOF
+local $^W = 1;
 
 # See the bottom of this file for the POD documentation.  Search for the
 # string '=head'.
@@ -9,21 +15,26 @@ package CGI::Fast;
 
 # Copyright 1995,1996, Lincoln D. Stein.  All rights reserved.
 # It may be used and modified freely, but I do request that this copyright
-# notice remain attached to the file.  You may modify this module as you 
+# notice remain attached to the file.  You may modify this module as you
 # wish, but if you redistribute a modified version, please attach a note
 # listing the modifications you have made.
 
-$CGI::Fast::VERSION='1.07';
+$CGI::Fast::VERSION='1.08';
 
 use CGI;
 use FCGI;
+# use vars works like "our", but is compatible with older Perls.
+use vars qw(
+    @ISA
+    $ignore
+);
 @ISA = ('CGI');
 
 # workaround for known bug in libfcgi
 while (($ignore) = each %ENV) { }
 
 # override the initialization behavior so that
-# state is NOT maintained between invocations 
+# state is NOT maintained between invocations
 sub save_request {
     # no-op
 }
@@ -38,7 +49,7 @@ BEGIN {
 	my $path    = $ENV{FCGI_SOCKET_PATH};
 	my $backlog = $ENV{FCGI_LISTEN_QUEUE} || 100;
 	my $socket  = FCGI::OpenSocket( $path, $backlog );
-	$Ext_Request = FCGI::Request( \*STDIN, \*STDOUT, \*STDERR, 
+	$Ext_Request = FCGI::Request( \*STDIN, \*STDOUT, \*STDERR,
 					\%ENV, $socket, 1 );
    }
 }
@@ -55,7 +66,7 @@ sub new {
      }
      }
      CGI->_reset_globals;
-     $self->_setup_symbols(@SAVED_SYMBOLS) if @CGI::SAVED_SYMBOLS;
+     $self->_setup_symbols(@CGI::SAVED_SYMBOLS) if @CGI::SAVED_SYMBOLS;
      return $CGI::Q = $self->SUPER::new($initializer, @param);
 }
 
@@ -96,10 +107,10 @@ http://www.cpan.org/ for details.
 
 =head1 WRITING FASTCGI PERL SCRIPTS
 
-FastCGI scripts are persistent: one or more copies of the script 
+FastCGI scripts are persistent: one or more copies of the script
 are started up when the server initializes, and stay around until
 the server exits or they die a natural death.  After performing
-whatever one-time initialization it needs, the script enters a 
+whatever one-time initialization it needs, the script enters a
 loop waiting for incoming connections, processing the request, and
 waiting some more.
 
@@ -143,7 +154,7 @@ install, you must add something like the
 
     FastCgiServer /usr/etc/httpd/fcgi-bin/file_upload.fcgi -processes 2
 
-This instructs Apache to launch two copies of file_upload.fcgi at 
+This instructs Apache to launch two copies of file_upload.fcgi at
 startup time.
 
 =head1 USING FASTCGI SCRIPTS AS CGI SCRIPTS
@@ -174,7 +185,7 @@ script to which bind an listen for incom
 
 =item FCGI_LISTEN_QUEUE
 
-Maximum length of the queue of pending connections.  
+Maximum length of the queue of pending connections.
 
 =back
 
@@ -195,7 +206,7 @@ I haven't tested this very much.
 
 =head1 AUTHOR INFORMATION
 
-Copyright 1996-1998, Lincoln D. Stein.  All rights reserved.  
+Copyright 1996-1998, Lincoln D. Stein.  All rights reserved.
 
 This library is free software; you can redistribute it and/or modify
 it under the same terms as Perl itself.
diff -up perl-5.10.1/lib/CGI.pm.cgiup perl-5.10.1/lib/CGI.pm
--- perl-5.10.1/lib/CGI.pm.cgiup	2009-08-22 19:20:26.000000000 +0200
+++ perl-5.10.1/lib/CGI.pm	2011-01-05 19:24:58.000000000 +0100
@@ -1,5 +1,5 @@
 package CGI;
-require 5.004;
+require 5.006;
 use Carp 'croak';
 
 # See the bottom of this file for the POD documentation.  Search for the
@@ -16,10 +16,11 @@ use Carp 'croak';
 # listing the modifications you have made.
 
 # The most recent version and complete docs are available at:
-#   http://stein.cshl.org/WWW/software/CGI/
+#   http://search.cpan.org/dist/CGI.pm
 
-$CGI::revision = '$Id: CGI.pm,v 1.263 2009/02/11 16:56:37 lstein Exp $';
-$CGI::VERSION='3.43';
+# The revision is no longer being updated since moving to git. 
+$CGI::revision = '$Id: CGI.pm,v 1.266 2009/07/30 16:32:34 lstein Exp $';
+$CGI::VERSION='3.51';
 
 # HARD-CODED LOCATION FOR FILE UPLOAD TEMPORARY FILES.
 # UNCOMMENT THIS ONLY IF YOU KNOW WHAT YOU'RE DOING.
@@ -61,8 +62,8 @@ sub initialize_globals {
 
     # Set this to 1 to enable NOSTICKY scripts
     # or: 
-    #    1) use CGI qw(-nosticky)
-    #    2) $CGI::nosticky(1)
+    #    1) use CGI '-nosticky';
+    #    2) $CGI::NOSTICKY = 1;
     $NOSTICKY = 0;
 
     # Set this to 1 to enable NPH scripts
@@ -128,7 +129,9 @@ sub initialize_globals {
 
 # ------------------ START OF THE LIBRARY ------------
 
-*end_form = \&endform;
+#### Method: endform
+# This method is DEPRECATED
+*endform = \&end_form;
 
 # make mod_perlhappy
 initialize_globals();
@@ -156,12 +159,14 @@ if ($OS =~ /^MSWin/i) {
     $OS = 'EPOC';
 } elsif ($OS =~ /^cygwin/i) {
     $OS = 'CYGWIN';
+} elsif ($OS =~ /^NetWare/i) {
+    $OS = 'NETWARE';
 } else {
     $OS = 'UNIX';
 }
 
 # Some OS logic.  Binary mode enabled on DOS, NT and VMS
-$needs_binmode = $OS=~/^(WINDOWS|DOS|OS2|MSWin|CYGWIN)/;
+$needs_binmode = $OS=~/^(WINDOWS|DOS|OS2|MSWin|CYGWIN|NETWARE)/;
 
 # This is the default class for the CGI object to use when all else fails.
 $DefaultClass = 'CGI' unless defined $CGI::DefaultClass;
@@ -172,7 +177,7 @@ $AutoloadClass = $DefaultClass unless de
 # The path separator is a slash, backslash or semicolon, depending
 # on the paltform.
 $SL = {
-     UNIX    => '/',  OS2 => '\\', EPOC      => '/', CYGWIN => '/',
+     UNIX    => '/',  OS2 => '\\', EPOC      => '/', CYGWIN => '/', NETWARE => '/',
      WINDOWS => '\\', DOS => '\\', MACINTOSH => ':', VMS    => '/'
     }->{$OS};
 
@@ -181,8 +186,12 @@ $SL = {
 # $NPH++ if defined($ENV{'SERVER_SOFTWARE'}) && $ENV{'SERVER_SOFTWARE'}=~/IIS/;
 $IIS++ if defined($ENV{'SERVER_SOFTWARE'}) && $ENV{'SERVER_SOFTWARE'}=~/IIS/;
 
+# Turn on special checking for ActiveState's PerlEx
+$PERLEX++ if defined($ENV{'GATEWAY_INTERFACE'}) && $ENV{'GATEWAY_INTERFACE'} =~ /^CGI-PerlEx/;
+
 # Turn on special checking for Doug MacEachern's modperl
-if (exists $ENV{MOD_PERL}) {
+# PerlEx::DBI tries to fool DBI by setting MOD_PERL
+if (exists $ENV{MOD_PERL} && ! $PERLEX) {
   # mod_perl handlers may run system() on scripts using CGI.pm;
   # Make sure so we don't get fooled by inherited $ENV{MOD_PERL}
   if (exists $ENV{MOD_PERL_API_VERSION} && $ENV{MOD_PERL_API_VERSION} == 2) {
@@ -198,9 +207,6 @@ if (exists $ENV{MOD_PERL}) {
   }
 }
 
-# Turn on special checking for ActiveState's PerlEx
-$PERLEX++ if defined($ENV{'GATEWAY_INTERFACE'}) && $ENV{'GATEWAY_INTERFACE'} =~ /^CGI-PerlEx/;
-
 # Define the CRLF sequence.  I can't use a simple "\r\n" because the meaning
 # of "\n" is different on different OS's (sometimes it generates CRLF, sometimes LF
 # and sometimes CR).  The most popular VMS web server
@@ -452,12 +458,23 @@ sub param {
 
     if ($PARAM_UTF8) {
       eval "require Encode; 1;" unless Encode->can('decode'); # bring in these functions
-      @result = map {ref $_ ? $_ : Encode::decode(utf8=>$_) } @result;
+      @result = map {ref $_ ? $_ : $self->_decode_utf8($_) } @result;
     }
 
     return wantarray ?  @result : $result[0];
 }
 
+sub _decode_utf8 {
+    my ($self, $val) = @_;
+
+    if (Encode::is_utf8($val)) {
+        return $val;
+    }
+    else {
+        return Encode::decode(utf8 => $val);
+    }
+}
+
 sub self_or_default {
     return @_ if defined($_[0]) && (!ref($_[0])) &&($_[0] eq 'CGI');
     unless (defined($_[0]) && 
@@ -610,10 +627,10 @@ sub init {
 	  }
 
           if (defined($fh) && ($fh ne '')) {
-              while (<$fh>) {
-                  chomp;
-                  last if /^=/;
-                  push(@lines,$_);
+              while (my $line = <$fh>) {
+                  chomp $line;
+                  last if $line =~ /^=$/;
+                  push(@lines,$line);
               }
               # massage back into standard format
               if ("@lines" =~ /=/) {
@@ -644,8 +661,17 @@ sub init {
       }
 
       if ($meth eq 'POST' || $meth eq 'PUT') {
-	  $self->read_from_client(\$query_string,$content_length,0)
-	      if $content_length > 0;
+	  if ( $content_length > 0 ) {
+	    $self->read_from_client(\$query_string,$content_length,0);
+	  }
+	  elsif (not defined $ENV{CONTENT_LENGTH}) {
+	    $self->read_from_stdin(\$query_string);
+	    # should this be PUTDATA in case of PUT ?
+	    my($param) = $meth . 'DATA' ;
+	    $self->add_parameter($param) ;
+	    push (@{$self->{param}{$param}},$query_string);
+	    undef $query_string ;
+	  }
 	  # Some people want to have their cake and eat it too!
 	  # Uncomment this line to have the contents of the query string
 	  # APPENDED to the POST data.
@@ -653,7 +679,8 @@ sub init {
 	  last METHOD;
       }
 
-      # If $meth is not of GET, POST or HEAD, assume we're being debugged offline.
+      # If $meth is not of GET, POST, PUT or HEAD, assume we're
+      #   being debugged offline.
       # Check the command line and then the standard input for data.
       # We use the shellwords package in order to behave the way that
       # UN*X programmers expect.
@@ -673,10 +700,10 @@ sub init {
         && defined($ENV{'CONTENT_TYPE'})
         && $ENV{'CONTENT_TYPE'} !~ m|^application/x-www-form-urlencoded|
 	&& $ENV{'CONTENT_TYPE'} !~ m|^multipart/form-data| ) {
-        my($param) = $meth . 'DATA' ;
-        $self->add_parameter($param) ;
-      push (@{$self->{param}{$param}},$query_string);
-      undef $query_string ;
+	    my($param) = $meth . 'DATA' ;
+	    $self->add_parameter($param) ;
+	    push (@{$self->{param}{$param}},$query_string);
+	    undef $query_string ;
     }
 # YL: End Change for XML handler 10/19/2001
 
@@ -997,6 +1024,47 @@ sub read_from_client {
 }
 END_OF_FUNC
 
+'read_from_stdin' => <<'END_OF_FUNC',
+# Read data from stdin until all is read
+sub read_from_stdin {
+    my($self, $buff) = @_;
+    local $^W=0;                # prevent a warning
+
+    #
+    # TODO: loop over STDIN until all is read
+    #
+
+    my($eoffound) = 0;
+    my($localbuf) = '';
+    my($tempbuf) = '';
+    my($bufsiz) = 1024;
+    my($res);
+    while ($eoffound == 0) {
+	if ( $MOD_PERL ) {
+	    $res = $self->r->read($tempbuf, $bufsiz, 0)
+	}
+	else {
+	    $res = read(\*STDIN, $tempbuf, $bufsiz);
+	}
+
+	if ( !defined($res) ) {
+	    # TODO: how to do error reporting ?
+	    $eoffound = 1;
+	    last;
+	}
+	if ( $res == 0 ) {
+	    $eoffound = 1;
+	    last;
+	}
+	$localbuf .= $tempbuf;
+    }
+
+    $$buff = $localbuf;
+
+    return $res;
+}
+END_OF_FUNC
+
 'delete' => <<'END_OF_FUNC',
 #### Method: delete
 # Deletes the named parameter entirely.
@@ -1132,6 +1200,12 @@ sub MethPost {
 }
 END_OF_FUNC
 
+'MethPut' => <<'END_OF_FUNC',
+sub MethPut {
+    return request_method() eq 'PUT';
+}
+END_OF_FUNC
+
 'TIEHASH' => <<'END_OF_FUNC',
 sub TIEHASH {
     my $class = shift;
@@ -1277,7 +1351,8 @@ sub url_param {
 		push(@{$self->{'.url_param'}->{$param}},$value);
 	    }
 	} else {
-	    $self->{'.url_param'}->{'keywords'} = [$self->parse_keywordlist($ENV{QUERY_STRING})];
+        my @keywords = $self->parse_keywordlist($ENV{QUERY_STRING});
+	    $self->{'.url_param'}{'keywords'} = \@keywords if @keywords;
 	}
     }
     return keys %{$self->{'.url_param'}} unless defined($name);
@@ -1299,11 +1374,11 @@ sub Dump {
     return '<ul></ul>' unless $self->param;
     push(@result,"<ul>");
     for $param ($self->param) {
-	my($name)=$self->escapeHTML($param);
-	push(@result,"<li><strong>$param</strong></li>");
+	my($name)=$self->_maybe_escapeHTML($param);
+	push(@result,"<li><strong>$name</strong></li>");
 	push(@result,"<ul>");
 	for $value ($self->param($param)) {
-	    $value = $self->escapeHTML($value);
+	    $value = $self->_maybe_escapeHTML($value);
             $value =~ s/\n/<br \/>\n/g;
 	    push(@result,"<li>$value</li>");
 	}
@@ -1339,7 +1414,8 @@ sub save {
 	my($escaped_param) = escape($param);
 	my($value);
 	for $value ($self->param($param)) {
-	    print $filehandle "$escaped_param=",escape("$value"),"\n";
+	    print $filehandle "$escaped_param=",escape("$value"),"\n"
+	        if length($escaped_param) or length($value);
 	}
     }
     for (keys %{$self->{'.fieldnames'}}) {
@@ -1382,7 +1458,14 @@ END_OF_FUNC
 sub multipart_init {
     my($self,@p) = self_or_default(@_);
     my($boundary,@other) = rearrange_header([BOUNDARY],@p);
-    $boundary = $boundary || '------- =_aaaaaaaaaa0';
+    if (!$boundary) {
+        $boundary = '------- =_';
+        my @chrs = ('0'..'9', 'A'..'Z', 'a'..'z');
+        for (1..17) {
+            $boundary .= $chrs[rand(scalar @chrs)];
+        }
+    }
+
     $self->{'separator'} = "$CRLF--$boundary$CRLF";
     $self->{'final_separator'} = "$CRLF--$boundary--$CRLF";
     $type = SERVER_PUSH($boundary);
@@ -1467,22 +1550,35 @@ sub header {
                             'EXPIRES','NPH','CHARSET',
                             'ATTACHMENT','P3P'],@p);
 
+    # CR escaping for values, per RFC 822
+    for my $header ($type,$status,$cookie,$target,$expires,$nph,$charset,$attachment,$p3p,@other) {
+        if (defined $header) {
+            # From RFC 822:
+            # Unfolding  is  accomplished  by regarding   CRLF   immediately
+            # followed  by  a  LWSP-char  as equivalent to the LWSP-char.
+            $header =~ s/$CRLF(\s)/$1/g;
+
+            # All other uses of newlines are invalid input. 
+            if ($header =~ m/$CRLF|\015|\012/) {
+                # shorten very long values in the diagnostic
+                $header = substr($header,0,72).'...' if (length $header > 72);
+                die "Invalid header value contains a newline not followed by whitespace: $header";
+            }
+        } 
+   }
+
     $nph     ||= $NPH;
 
     $type ||= 'text/html' unless defined($type);
 
-    if (defined $charset) {
-      $self->charset($charset);
-    } else {
-      $charset = $self->charset if $type =~ /^text\//;
-    }
-   $charset ||= '';
+    # sets if $charset is given, gets if not
+    $charset = $self->charset( $charset );
 
     # rearrange() was designed for the HTML portion, so we
     # need to fix it up a little.
     for (@other) {
         # Don't use \s because of perl bug 21951
-        next unless my($header,$value) = /([^ \r\n\t=]+)=\"?(.+?)\"?$/;
+        next unless my($header,$value) = /([^ \r\n\t=]+)=\"?(.+?)\"?$/s;
         ($_ = $header) =~ s/^(\w)(.*)/"\u$1\L$2" . ': '.$self->unescapeHTML($value)/e;
     }
 
@@ -1530,7 +1626,6 @@ sub header {
 }
 END_OF_FUNC
 
-
 #### Method: cache
 # Control whether header() will produce the no-cache
 # Pragma directive.
@@ -1632,10 +1727,10 @@ sub start_html {
     # Now that we know whether we're using the HTML 3.2 DTD or not, it's okay to
     # call escapeHTML().  Strangely enough, the title needs to be escaped as
     # HTML while the author needs to be escaped as a URL.
-    $title = $self->escapeHTML($title || 'Untitled Document');
+    $title = $self->_maybe_escapeHTML($title || 'Untitled Document');
     $author = $self->escape($author);
 
-    if ($DTD_PUBLIC_IDENTIFIER =~ /[^X]HTML (2\.0|3\.2)/i) {
+    if ($DTD_PUBLIC_IDENTIFIER =~ /[^X]HTML (2\.0|3\.2|4\.01?)/i) {
 	$lang = "" unless defined $lang;
 	$XHTML = 0;
     }
@@ -1762,20 +1857,20 @@ sub _script {
 
     my (@scripts) = ref($script) eq 'ARRAY' ? @$script : ($script);
     for $script (@scripts) {
-	my($src,$code,$language);
-	if (ref($script)) { # script is a hash
-	    ($src,$code,$type) =
-		rearrange(['SRC','CODE',['LANGUAGE','TYPE']],
-				 '-foo'=>'bar',	# a trick to allow the '-' to be omitted
-				 ref($script) eq 'ARRAY' ? @$script : %$script);
+    my($src,$code,$language,$charset);
+    if (ref($script)) { # script is a hash
+        ($src,$code,$type,$charset) =
+        rearrange(['SRC','CODE',['LANGUAGE','TYPE'],'CHARSET'],
+                 '-foo'=>'bar', # a trick to allow the '-' to be omitted
+                 ref($script) eq 'ARRAY' ? @$script : %$script);
             $type ||= 'text/javascript';
             unless ($type =~ m!\w+/\w+!) {
                 $type =~ s/[\d.]+$//;
                 $type = "text/$type";
             }
-	} else {
-	    ($src,$code,$type) = ('',$script, 'text/javascript');
-	}
+    } else {
+        ($src,$code,$type,$charset) = ('',$script, 'text/javascript', '');
+    }
 
     my $comment = '//';  # javascript by default
     $comment = '#' if $type=~/perl|tcl/i;
@@ -1793,6 +1888,7 @@ sub _script {
      my(@satts);
      push(@satts,'src'=>$src) if $src;
      push(@satts,'type'=>$type);
+     push(@satts,'charset'=>$charset) if ($src && $charset);
      $code = $cdata_start . $code . $cdata_end if defined $code;
      push(@result,$self->script({@satts},$code || ''));
     }
@@ -1833,6 +1929,7 @@ END_OF_FUNC
 
 
 #### Method: startform
+# This method is DEPRECATED
 # Start a form
 # Parameters:
 #   $method -> optional submission method to use (GET or POST)
@@ -1845,13 +1942,13 @@ sub startform {
     my($method,$action,$enctype,@other) = 
 	rearrange([METHOD,ACTION,ENCTYPE],@p);
 
-    $method  = $self->escapeHTML(lc($method || 'post'));
-    $enctype = $self->escapeHTML($enctype || &URL_ENCODED);
+    $method  = $self->_maybe_escapeHTML(lc($method || 'post'));
+    $enctype = $self->_maybe_escapeHTML($enctype || &URL_ENCODED);
     if (defined $action) {
-       $action = $self->escapeHTML($action);
+       $action = $self->_maybe_escapeHTML($action);
     }
     else {
-       $action = $self->escapeHTML($self->request_uri || $self->self_url);
+       $action = $self->_maybe_escapeHTML($self->request_uri || $self->self_url);
     }
     $action = qq(action="$action");
     my($other) = @other ? " @other" : '';
@@ -1860,55 +1957,82 @@ sub startform {
 }
 END_OF_FUNC
 
-
 #### Method: start_form
-# synonym for startform
+# Start a form
+# Parameters:
+#   $method -> optional submission method to use (GET or POST)
+#   $action -> optional URL of script to run
+#   $enctype ->encoding to use (URL_ENCODED or MULTIPART)
 'start_form' => <<'END_OF_FUNC',
 sub start_form {
-    $XHTML ? &start_multipart_form : &startform;
-}
-END_OF_FUNC
+    my($self,@p) = self_or_default(@_);
 
-'end_multipart_form' => <<'END_OF_FUNC',
-sub end_multipart_form {
-    &endform;
+    my($method,$action,$enctype,@other) = 
+	rearrange([METHOD,ACTION,ENCTYPE],@p);
+
+    $method  = $self->_maybe_escapeHTML(lc($method || 'post'));
+
+    if( $XHTML ){
+        $enctype = $self->_maybe_escapeHTML($enctype || &MULTIPART);
+    }else{
+        $enctype = $self->_maybe_escapeHTML($enctype || &URL_ENCODED);
+    }
+
+    if (defined $action) {
+       $action = $self->_maybe_escapeHTML($action);
+    }
+    else {
+       $action = $self->_maybe_escapeHTML($self->request_uri || $self->self_url);
+    }
+    $action = qq(action="$action");
+    my($other) = @other ? " @other" : '';
+    $self->{'.parametersToAdd'}={};
+    return qq/<form method="$method" $action enctype="$enctype"$other>\n/;
 }
 END_OF_FUNC
 
 #### Method: start_multipart_form
-# synonym for startform
 'start_multipart_form' => <<'END_OF_FUNC',
 sub start_multipart_form {
     my($self,@p) = self_or_default(@_);
     if (defined($p[0]) && substr($p[0],0,1) eq '-') {
-      return $self->startform(-enctype=>&MULTIPART,@p);
+      return $self->start_form(-enctype=>&MULTIPART,@p);
     } else {
 	my($method,$action,@other) = 
 	    rearrange([METHOD,ACTION],@p);
-	return $self->startform($method,$action,&MULTIPART,@other);
+	return $self->start_form($method,$action,&MULTIPART,@other);
     }
 }
 END_OF_FUNC
 
 
-#### Method: endform
+
+#### Method: end_form
 # End a form
-'endform' => <<'END_OF_FUNC',
-sub endform {
+'end_form' => <<'END_OF_FUNC',
+sub end_form {
     my($self,@p) = self_or_default(@_);
     if ( $NOSTICKY ) {
-    return wantarray ? ("</form>") : "\n</form>";
+        return wantarray ? ("</form>") : "\n</form>";
     } else {
-      if (my @fields = $self->get_fields) {
-         return wantarray ? ("<div>",@fields,"</div>","</form>")
-                          : "<div>".(join '',@fields)."</div>\n</form>";
-      } else {
-         return "</form>";
-      }
+        if (my @fields = $self->get_fields) {
+            return wantarray ? ("<div>",@fields,"</div>","</form>")
+                             : "<div>".(join '',@fields)."</div>\n</form>";
+        } else {
+            return "</form>";
+        }
     }
 }
 END_OF_FUNC
 
+#### Method: end_multipart_form
+# end a multipart form
+'end_multipart_form' => <<'END_OF_FUNC',
+sub end_multipart_form {
+    &end_form;
+}
+END_OF_FUNC
+
 
 '_textfield' => <<'END_OF_FUNC',
 sub _textfield {
@@ -1919,8 +2043,8 @@ sub _textfield {
     my $current = $override ? $default : 
 	(defined($self->param($name)) ? $self->param($name) : $default);
 
-    $current = defined($current) ? $self->escapeHTML($current,1) : '';
-    $name = defined($name) ? $self->escapeHTML($name) : '';
+    $current = defined($current) ? $self->_maybe_escapeHTML($current,1) : '';
+    $name = defined($name) ? $self->_maybe_escapeHTML($name) : '';
     my($s) = defined($size) ? qq/ size="$size"/ : '';
     my($m) = defined($maxlength) ? qq/ maxlength="$maxlength"/ : '';
     my($other) = @other ? " @other" : '';
@@ -2004,8 +2128,8 @@ sub textarea {
     my($current)= $override ? $default :
 	(defined($self->param($name)) ? $self->param($name) : $default);
 
-    $name = defined($name) ? $self->escapeHTML($name) : '';
-    $current = defined($current) ? $self->escapeHTML($current) : '';
+    $name = defined($name) ? $self->_maybe_escapeHTML($name) : '';
+    $current = defined($current) ? $self->_maybe_escapeHTML($current) : '';
     my($r) = $rows ? qq/ rows="$rows"/ : '';
     my($c) = $cols ? qq/ cols="$cols"/ : '';
     my($other) = @other ? " @other" : '';
@@ -2032,9 +2156,11 @@ sub button {
     my($label,$value,$script,$tabindex,@other) = rearrange([NAME,[VALUE,LABEL],
 						            [ONCLICK,SCRIPT],TABINDEX],@p);
 
-    $label=$self->escapeHTML($label);
-    $value=$self->escapeHTML($value,1);
-    $script=$self->escapeHTML($script);
+    $label=$self->_maybe_escapeHTML($label);
+    $value=$self->_maybe_escapeHTML($value,1);
+    $script=$self->_maybe_escapeHTML($script);
+
+    $script ||= '';
 
     my($name) = '';
     $name = qq/ name="$label"/ if $label;
@@ -2065,8 +2191,8 @@ sub submit {
 
     my($label,$value,$tabindex,@other) = rearrange([NAME,[VALUE,LABEL],TABINDEX],@p);
 
-    $label=$self->escapeHTML($label);
-    $value=$self->escapeHTML($value,1);
+    $label=$self->_maybe_escapeHTML($label);
+    $value=$self->_maybe_escapeHTML($value,1);
 
     my $name = $NOSTICKY ? '' : 'name=".submit" ';
     $name = qq/name="$label" / if defined($label);
@@ -2092,8 +2218,8 @@ END_OF_FUNC
 sub reset {
     my($self,@p) = self_or_default(@_);
     my($label,$value,$tabindex,@other) = rearrange(['NAME',['VALUE','LABEL'],TABINDEX],@p);
-    $label=$self->escapeHTML($label);
-    $value=$self->escapeHTML($value,1);
+    $label=$self->_maybe_escapeHTML($label);
+    $value=$self->_maybe_escapeHTML($value,1);
     my ($name) = ' name=".reset"';
     $name = qq/ name="$label"/ if defined($label);
     $value = defined($value) ? $value : $label;
@@ -2124,7 +2250,7 @@ sub defaults {
 
     my($label,$tabindex,@other) = rearrange([[NAME,VALUE],TABINDEX],@p);
 
-    $label=$self->escapeHTML($label,1);
+    $label=$self->_maybe_escapeHTML($label,1);
     $label = $label || "Defaults";
     my($value) = qq/ value="$label"/;
     my($other) = @other ? " @other" : '';
@@ -2174,9 +2300,9 @@ sub checkbox {
 	$checked = $self->_checked($checked);
     }
     my($the_label) = defined $label ? $label : $name;
-    $name = $self->escapeHTML($name);
-    $value = $self->escapeHTML($value,1);
-    $the_label = $self->escapeHTML($the_label);
+    $name = $self->_maybe_escapeHTML($name);
+    $value = $self->_maybe_escapeHTML($value,1);
+    $the_label = $self->_maybe_escapeHTML($the_label);
     my($other) = @other ? "@other " : '';
     $tabindex = $self->element_tab($tabindex);
     $self->register_parameter($name);
@@ -2188,40 +2314,39 @@ END_OF_FUNC
 
 
 
-# Escape HTML -- used internally
+# Escape HTML
 'escapeHTML' => <<'END_OF_FUNC',
 sub escapeHTML {
-         # hack to work around  earlier hacks
-         push @_,$_[0] if @_==1 && $_[0] eq 'CGI';
-         my ($self,$toencode,$newlinestoo) = CGI::self_or_default(@_);
-         return undef unless defined($toencode);
-         return $toencode if ref($self) && !$self->{'escape'};
-         $toencode =~ s{&}{&amp;}gso;
-         $toencode =~ s{<}{&lt;}gso;
-         $toencode =~ s{>}{&gt;}gso;
-	 if ($DTD_PUBLIC_IDENTIFIER =~ /[^X]HTML 3\.2/i) {
-	     # $quot; was accidentally omitted from the HTML 3.2 DTD -- see
-	     # <http://validator.w3.org/docs/errors.html#bad-entity> /
-	     # <http://lists.w3.org/Archives/Public/www-html/1997Mar/0003.html>.
-	     $toencode =~ s{"}{&#34;}gso;
-         }
-         else {
-	     $toencode =~ s{"}{&quot;}gso;
-         }
-         # Handle bug in some browsers with Latin charsets
-         if ($self->{'.charset'} &&
-             (uc($self->{'.charset'}) eq 'ISO-8859-1' ||
-              uc($self->{'.charset'}) eq 'WINDOWS-1252'))
-         {
+     # hack to work around  earlier hacks
+     push @_,$_[0] if @_==1 && $_[0] eq 'CGI';
+     my ($self,$toencode,$newlinestoo) = CGI::self_or_default(@_);
+     return undef unless defined($toencode);
+     $toencode =~ s{&}{&amp;}gso;
+     $toencode =~ s{<}{&lt;}gso;
+     $toencode =~ s{>}{&gt;}gso;
+     if ($DTD_PUBLIC_IDENTIFIER =~ /[^X]HTML 3\.2/i) {
+     # $quot; was accidentally omitted from the HTML 3.2 DTD -- see
+     # <http://validator.w3.org/docs/errors.html#bad-entity> /
+     # <http://lists.w3.org/Archives/Public/www-html/1997Mar/0003.html>.
+        $toencode =~ s{"}{&#34;}gso;
+     }
+     else {
+        $toencode =~ s{"}{&quot;}gso;
+     }
+
+    # Handle bug in some browsers with Latin charsets
+    if ($self->{'.charset'} 
+            && (uc($self->{'.charset'}) eq 'ISO-8859-1' 
+            || uc($self->{'.charset'}) eq 'WINDOWS-1252')) {
                 $toencode =~ s{'}{&#39;}gso;
                 $toencode =~ s{\x8b}{&#8249;}gso;
                 $toencode =~ s{\x9b}{&#8250;}gso;
-                if (defined $newlinestoo && $newlinestoo) {
-                     $toencode =~ s{\012}{&#10;}gso;
-                     $toencode =~ s{\015}{&#13;}gso;
-                }
-         }
-         return $toencode;
+        if (defined $newlinestoo && $newlinestoo) {
+            $toencode =~ s{\012}{&#10;}gso;
+            $toencode =~ s{\015}{&#13;}gso;
+        }
+    }
+    return $toencode;
 }
 END_OF_FUNC
 
@@ -2235,7 +2360,7 @@ sub unescapeHTML {
     my $latin = defined $self->{'.charset'} ? $self->{'.charset'} =~ /^(ISO-8859-1|WINDOWS-1252)$/i
                                             : 1;
     # thanks to Randal Schwartz for the correct solution to this one
-    $string=~ s[&(.*?);]{
+    $string=~ s[&(\S*?);]{
 	local $_ = $1;
 	/^amp$/i	? "&" :
 	/^quot$/i	? '"' :
@@ -2362,7 +2487,7 @@ sub _box_group {
     # If no check array is specified, check the first by default
     $checked{$values[0]}++ if $box_type eq 'radio' && !%checked;
 
-    $name=$self->escapeHTML($name);
+    $name=$self->_maybe_escapeHTML($name);
 
     my %tabs = ();
     if ($TABINDEX && $tabindex) {
@@ -2403,19 +2528,19 @@ sub _box_group {
 	unless (defined($nolabels) && $nolabels) {
 	    $label = $_;
 	    $label = $labels->{$_} if defined($labels) && defined($labels->{$_});
-	    $label = $self->escapeHTML($label,1);
+	    $label = $self->_maybe_escapeHTML($label,1);
             $label = "<span style=\"color:gray\">$label</span>" if $disabled{$_};
 	}
         my $attribs = $self->_set_attributes($_, $attributes);
         my $tab     = $tabs{$_};
-	$_=$self->escapeHTML($_);
+	$_=$self->_maybe_escapeHTML($_);
 
         if ($XHTML) {
            push @elements,
               CGI::label($labelattributes,
                    qq(<input type="$box_type" name="$name" value="$_" $checkit$other$tab$attribs$disable/>$label)).${break};
         } else {
-            push(@elements,qq/<input type="$box_type" name="$name" value="$_"$checkit$other$tab$attribs$disable>${label}${break}/);
+            push(@elements,qq/<input type="$box_type" name="$name" value="$_" $checkit$other$tab$attribs$disable>${label}${break}/);
         }
     }
     $self->register_parameter($name);
@@ -2456,19 +2581,20 @@ sub popup_menu {
                                 ? @$default 
                                 : $default;
     }
-    $name=$self->escapeHTML($name);
+    $name=$self->_maybe_escapeHTML($name);
     my($other) = @other ? " @other" : '';
 
     my(@values);
     @values = $self->_set_values_and_labels($values,\$labels,$name);
     $tabindex = $self->element_tab($tabindex);
+    $name = q{} if ! defined $name;
     $result = qq/<select name="$name" $tabindex$other>\n/;
     for (@values) {
         if (/<optgroup/) {
             for my $v (split(/\n/)) {
                 my $selectit = $XHTML ? 'selected="selected"' : 'selected';
 		for my $selected (keys %selected) {
-		    $v =~ s/(value="$selected")/$selectit $1/;
+		    $v =~ s/(value="\Q$selected\E")/$selectit $1/;
 		}
                 $result .= "$v\n";
             }
@@ -2478,8 +2604,8 @@ sub popup_menu {
 	  my($selectit) = $self->_selected($selected{$_});
 	  my($label)    = $_;
 	  $label        = $labels->{$_} if defined($labels) && defined($labels->{$_});
-	  my($value)    = $self->escapeHTML($_);
-	  $label        = $self->escapeHTML($label,1);
+	  my($value)    = $self->_maybe_escapeHTML($_);
+	  $label        = $self->_maybe_escapeHTML($label,1);
           $result      .= "<option${attribs} ${selectit}value=\"$value\">$label</option>\n";
         }
     }
@@ -2522,7 +2648,7 @@ sub optgroup {
     @values = $self->_set_values_and_labels($values,\$labels,$name,$labeled,$novals);
     my($other) = @other ? " @other" : '';
 
-    $name=$self->escapeHTML($name);
+    $name = $self->_maybe_escapeHTML($name) || q{};
     $result = qq/<optgroup label="$name"$other>\n/;
     for (@values) {
         if (/<optgroup/) {
@@ -2536,8 +2662,8 @@ sub optgroup {
             my $attribs = $self->_set_attributes($_, $attributes);
             my($label) = $_;
             $label = $labels->{$_} if defined($labels) && defined($labels->{$_});
-            $label=$self->escapeHTML($label);
-            my($value)=$self->escapeHTML($_,1);
+            $label=$self->_maybe_escapeHTML($label);
+            my($value)=$self->_maybe_escapeHTML($_,1);
             $result .= $labeled ? $novals ? "<option$attribs label=\"$value\">$label</option>\n"
                                           : "<option$attribs label=\"$value\" value=\"$value\">$label</option>\n"
                                 : $novals ? "<option$attribs>$label</option>\n"
@@ -2588,18 +2714,30 @@ sub scrolling_list {
     my($has_size) = $size ? qq/ size="$size"/: '';
     my($other) = @other ? " @other" : '';
 
-    $name=$self->escapeHTML($name);
+    $name=$self->_maybe_escapeHTML($name);
     $tabindex = $self->element_tab($tabindex);
     $result = qq/<select name="$name" $tabindex$has_size$is_multiple$other>\n/;
     for (@values) {
-	my($selectit) = $self->_selected($selected{$_});
-	my($label) = $_;
-	$label = $labels->{$_} if defined($labels) && defined($labels->{$_});
-	$label=$self->escapeHTML($label);
-	my($value)=$self->escapeHTML($_,1);
-        my $attribs = $self->_set_attributes($_, $attributes);
-        $result .= "<option ${selectit}${attribs}value=\"$value\">$label</option>\n";
+        if (/<optgroup/) {
+            for my $v (split(/\n/)) {
+                my $selectit = $XHTML ? 'selected="selected"' : 'selected';
+		for my $selected (keys %selected) {
+		    $v =~ s/(value="$selected")/$selectit $1/;
+		}
+                $result .= "$v\n";
+            }
+        }
+        else {
+          my $attribs   = $self->_set_attributes($_, $attributes);
+	  my($selectit) = $self->_selected($selected{$_});
+	  my($label)    = $_;
+	  $label        = $labels->{$_} if defined($labels) && defined($labels->{$_});
+	  my($value)    = $self->_maybe_escapeHTML($_);
+	  $label        = $self->_maybe_escapeHTML($label,1);
+          $result      .= "<option${attribs} ${selectit}value=\"$value\">$label</option>\n";
+        }
     }
+
     $result .= "</select>";
     $self->register_parameter($name);
     return $result;
@@ -2634,15 +2772,16 @@ sub hidden {
 	for ($default,$override,@other) {
 	    push(@value,$_) if defined($_);
 	}
+        undef @other;
     }
 
     # use previous values if override is not set
     my @prev = $self->param($name);
     @value = @prev if !$do_override && @prev;
 
-    $name=$self->escapeHTML($name);
+    $name=$self->_maybe_escapeHTML($name);
     for (@value) {
-	$_ = defined($_) ? $self->escapeHTML($_,1) : '';
+	$_ = defined($_) ? $self->_maybe_escapeHTML($_,1) : '';
 	push @result,$XHTML ? qq(<input type="hidden" name="$name" value="$_" @other />)
                             : qq(<input type="hidden" name="$name" value="$_" @other>);
     }
@@ -2668,7 +2807,7 @@ sub image_button {
 
     my($align) = $alignment ? " align=\L\"$alignment\"" : '';
     my($other) = @other ? " @other" : '';
-    $name=$self->escapeHTML($name);
+    $name=$self->_maybe_escapeHTML($name);
     return $XHTML ? qq(<input type="image" name="$name" src="$src"$align$other />)
                   : qq/<input type="image" name="$name" src="$src"$align$other>/;
 }
@@ -2725,21 +2864,22 @@ sub url {
 #    $uri            =~ s/\Q$path\E$//      if defined $path;      # remove path
 
     if ($full) {
-	my $protocol = $self->protocol();
-	$url = "$protocol://";
-	my $vh = http('x_forwarded_host') || http('host') || '';
-        $vh =~ s/\:\d+$//;  # some clients add the port number (incorrectly). Get rid of it.
-	if ($vh) {
-	    $url .= $vh;
-	} else {
-	    $url .= server_name();
-	}
-        my $port = $self->server_port;
-	$url .= ":" . $port
-	  unless (lc($protocol) eq 'http'  && $port == 80)
-		|| (lc($protocol) eq 'https' && $port == 443);
+        my $protocol = $self->protocol();
+        $url = "$protocol://";
+        my $vh = http('x_forwarded_host') || http('host') || '';
+            $vh =~ s/\:\d+$//;  # some clients add the port number (incorrectly). Get rid of it.
+
+        $url .= $vh || server_name();
+
+        my $port = $self->virtual_port;
+
+        # add the port to the url unless it's the protocol's default port
+        $url .= ':' . $port unless (lc($protocol) eq 'http'  && $port == 80)
+                                or (lc($protocol) eq 'https' && $port == 443);
+
         return $url if $base;
-	$url .= $uri;
+
+        $url .= $uri;
     } elsif ($relative) {
 	($url) = $uri =~ m!([^/]+)$!;
     } elsif ($absolute) {
@@ -2779,9 +2919,8 @@ sub cookie {
     # value of the cookie, if any.  For efficiency, we cache the parsed
     # cookies in our state variables.
     unless ( defined($value) ) {
-	$self->{'.cookies'} = CGI::Cookie->fetch
-	    unless $self->{'.cookies'};
-
+	$self->{'.cookies'} = CGI::Cookie->fetch;
+	
 	# If no name is supplied, then retrieve the names of all our cookies.
 	return () unless $self->{'.cookies'};
 	return keys %{$self->{'.cookies'}} unless $name;
@@ -2801,7 +2940,7 @@ sub cookie {
     push(@param,'-secure'=>$secure) if $secure;
     push(@param,'-httponly'=>$httponly) if $httponly;
 
-    return new CGI::Cookie(@param);
+    return CGI::Cookie->new(@param);
 }
 END_OF_FUNC
 
@@ -2819,6 +2958,8 @@ END_OF_FUNC
 sub param_fetch {
     my($self,@p) = self_or_default(@_);
     my($name) = rearrange([NAME],@p);
+    return [] unless defined $name;
+
     unless (exists($self->{param}{$name})) {
 	$self->add_parameter($name);
 	$self->{param}{$name} = [];
@@ -2911,7 +3052,7 @@ END_OF_FUNC
 ####
 'request_method' => <<'END_OF_FUNC',
 sub request_method {
-    return $ENV{'REQUEST_METHOD'};
+    return (defined $ENV{'REQUEST_METHOD'}) ? $ENV{'REQUEST_METHOD'} : undef;
 }
 END_OF_FUNC
 
@@ -2920,7 +3061,7 @@ END_OF_FUNC
 ####
 'content_type' => <<'END_OF_FUNC',
 sub content_type {
-    return $ENV{'CONTENT_TYPE'};
+    return (defined $ENV{'CONTENT_TYPE'}) ? $ENV{'CONTENT_TYPE'} : undef;
 }
 END_OF_FUNC
 
@@ -2930,7 +3071,7 @@ END_OF_FUNC
 ####
 'path_translated' => <<'END_OF_FUNC',
 sub path_translated {
-    return $ENV{'PATH_TRANSLATED'};
+    return (defined $ENV{'PATH_TRANSLATED'}) ? $ENV{'PATH_TRANSLATED'} : undef;
 }
 END_OF_FUNC
 
@@ -2940,7 +3081,7 @@ END_OF_FUNC
 ####
 'request_uri' => <<'END_OF_FUNC',
 sub request_uri {
-    return $ENV{'REQUEST_URI'};
+    return (defined $ENV{'REQUEST_URI'}) ? $ENV{'REQUEST_URI'} : undef;
 }
 END_OF_FUNC
 
@@ -2954,12 +3095,12 @@ sub query_string {
     my($self) = self_or_default(@_);
     my($param,$value,@pairs);
     for $param ($self->param) {
-	my($eparam) = escape($param);
-	for $value ($self->param($param)) {
-	    $value = escape($value);
+       my($eparam) = escape($param);
+       for $value ($self->param($param)) {
+           $value = escape($value);
             next unless defined $value;
-	    push(@pairs,"$eparam=$value");
-	}
+           push(@pairs,"$eparam=$value");
+       }
     }
     for (keys %{$self->{'.fieldnames'}}) {
       push(@pairs,".cgifields=".escape("$_"));
@@ -3026,8 +3167,9 @@ END_OF_FUNC
 'user_agent' => <<'END_OF_FUNC',
 sub user_agent {
     my($self,$match)=self_or_CGI(@_);
-    return $self->http('user_agent') unless $match;
-    return $self->http('user_agent') =~ /$match/i;
+    my $user_agent = $self->http('user_agent');
+    return $user_agent unless $match && $user_agent;
+    return $user_agent =~ /$match/i;
 }
 END_OF_FUNC
 
@@ -3185,33 +3327,35 @@ END_OF_FUNC
 'http' => <<'END_OF_FUNC',
 sub http {
     my ($self,$parameter) = self_or_CGI(@_);
-    return $ENV{$parameter} if $parameter=~/^HTTP/;
-    $parameter =~ tr/-/_/;
-    return $ENV{"HTTP_\U$parameter\E"} if $parameter;
-    my(@p);
-    for (keys %ENV) {
-	push(@p,$_) if /^HTTP/;
+    if ( defined($parameter) ) {
+        $parameter =~ tr/-a-z/_A-Z/;
+        if ( $parameter =~ /^HTTP(?:_|$)/ ) {
+            return $ENV{$parameter};
+        }
+        return $ENV{"HTTP_$parameter"};
     }
-    return @p;
+    return grep { /^HTTP(?:_|$)/ } keys %ENV;
 }
 END_OF_FUNC
 
 #### Method: https
-# Return the value of HTTPS
+# Return the value of HTTPS, or
+# the value of an HTTPS variable, or
+# the list of variables
 ####
 'https' => <<'END_OF_FUNC',
 sub https {
-    local($^W)=0;
     my ($self,$parameter) = self_or_CGI(@_);
-    return $ENV{HTTPS} unless $parameter;
-    return $ENV{$parameter} if $parameter=~/^HTTPS/;
-    $parameter =~ tr/-/_/;
-    return $ENV{"HTTPS_\U$parameter\E"} if $parameter;
-    my(@p);
-    for (keys %ENV) {
-	push(@p,$_) if /^HTTPS/;
+    if ( defined($parameter) ) {
+        $parameter =~ tr/-a-z/_A-Z/;
+        if ( $parameter =~ /^HTTPS(?:_|$)/ ) {
+            return $ENV{$parameter};
+        }
+        return $ENV{"HTTPS_$parameter"};
     }
-    return @p;
+    return wantarray
+        ? grep { /^HTTPS(?:_|$)/ } keys %ENV
+        : $ENV{'HTTPS'};
 }
 END_OF_FUNC
 
@@ -3236,7 +3380,7 @@ END_OF_FUNC
 ####
 'remote_ident' => <<'END_OF_FUNC',
 sub remote_ident {
-    return $ENV{'REMOTE_IDENT'};
+    return (defined $ENV{'REMOTE_IDENT'}) ? $ENV{'REMOTE_IDENT'} : undef;
 }
 END_OF_FUNC
 
@@ -3246,7 +3390,7 @@ END_OF_FUNC
 ####
 'auth_type' => <<'END_OF_FUNC',
 sub auth_type {
-    return $ENV{'AUTH_TYPE'};
+    return (defined $ENV{'AUTH_TYPE'}) ? $ENV{'AUTH_TYPE'} : undef;
 }
 END_OF_FUNC
 
@@ -3257,7 +3401,7 @@ END_OF_FUNC
 ####
 'remote_user' => <<'END_OF_FUNC',
 sub remote_user {
-    return $ENV{'REMOTE_USER'};
+    return (defined $ENV{'REMOTE_USER'}) ? $ENV{'REMOTE_USER'} : undef;
 }
 END_OF_FUNC
 
@@ -3333,6 +3477,17 @@ sub default_dtd {
 END_OF_FUNC
 
 # -------------- really private subroutines -----------------
+'_maybe_escapeHTML' => <<'END_OF_FUNC',
+sub _maybe_escapeHTML {
+    # hack to work around  earlier hacks
+    push @_,$_[0] if @_==1 && $_[0] eq 'CGI';
+    my ($self,$toencode,$newlinestoo) = CGI::self_or_default(@_);
+    return undef unless defined($toencode);
+    return $toencode if ref($self) && !$self->{'escape'};
+    return $self->escapeHTML($toencode, $newlinestoo);
+}
+END_OF_FUNC
+
 'previous_or_default' => <<'END_OF_FUNC',
 sub previous_or_default {
     my($self,$name,$defaults,$override) = @_;
@@ -3426,7 +3581,7 @@ sub read_multipart {
 
 	$header{'Content-Disposition'} ||= ''; # quench uninit variable warning
 
-	my($param)= $header{'Content-Disposition'}=~/ name="([^"]*)"/;
+	my($param)= $header{'Content-Disposition'}=~/[\s;]name="([^"]*)"/;
         $param .= $TAINTED;
 
         # See RFC 1867, 2183, 2045
@@ -3475,12 +3630,12 @@ sub read_multipart {
 	  # choose a relatively unpredictable tmpfile sequence number
           my $seqno = unpack("%16C*",join('',localtime,grep {defined $_} values %ENV));
           for (my $cnt=10;$cnt>0;$cnt--) {
-	    next unless $tmpfile = new CGITempFile($seqno);
+	    next unless $tmpfile = CGITempFile->new($seqno);
 	    $tmp = $tmpfile->as_string;
 	    last if defined($filehandle = Fh->new($filename,$tmp,$PRIVATE_TEMPFILES));
             $seqno += int rand(100);
           }
-          die "CGI open of tmpfile: $!\n" unless defined $filehandle;
+          die "CGI.pm open of tmpfile $tmp/$filename failed: $!\n" unless defined $filehandle;
 	  $CGI::DefaultClass->binmode($filehandle) if $CGI::needs_binmode 
                      && defined fileno($filehandle);
 
@@ -3587,7 +3742,7 @@ sub read_multipart_related {
 	  # choose a relatively unpredictable tmpfile sequence number
           my $seqno = unpack("%16C*",join('',localtime,grep {defined $_} values %ENV));
           for (my $cnt=10;$cnt>0;$cnt--) {
-	    next unless $tmpfile = new CGITempFile($seqno);
+	    next unless $tmpfile = CGITempFile->new($seqno);
 	    $tmp = $tmpfile->as_string;
 	    last if defined($filehandle = Fh->new($param,$tmp,$PRIVATE_TEMPFILES));
             $seqno += int rand(100);
@@ -3762,7 +3917,9 @@ sub new {
     (my $safename = $name) =~ s/([':%])/ sprintf '%%%02X', ord $1 /eg;
     my $fv = ++$FH . $safename;
     my $ref = \*{"Fh::$fv"};
-    $file =~ m!^([a-zA-Z0-9_\+ \'\":/.\$\\~-]+)$! || return;
+
+    # Note this same regex is also used elsewhere in the same file for CGITempFile::new
+    $file =~ m!^([a-zA-Z0-9_ \'\":/.\$\\\+-]+)$! || return;
     my $safe = $1;
     sysopen($ref,$safe,Fcntl::O_RDWR()|Fcntl::O_CREAT()|Fcntl::O_EXCL(),0600) || return;
     unlink($safe) if $delete;
@@ -4062,10 +4219,11 @@ sub find_tempdir {
 	   "C:${SL}system${SL}temp");
     
     if( $CGI::OS eq 'WINDOWS' ){
-       unshift @TEMP,
-           $ENV{TEMP},
-           $ENV{TMP},
-           $ENV{WINDIR} . $SL . 'TEMP';
+         # PeterH: These evars may not exist if this is invoked within a service and untainting
+         # is in effect - with 'use warnings' the undefined array entries causes Perl to die
+         unshift(@TEMP,$ENV{TEMP}) if defined $ENV{TEMP};
+         unshift(@TEMP,$ENV{TMP}) if defined $ENV{TMP};
+         unshift(@TEMP,$ENV{WINDIR} . $SL . 'TEMP') if defined $ENV{WINDIR};
     }
 
     unshift(@TEMP,$ENV{'TMPDIR'}) if defined $ENV{'TMPDIR'};
@@ -4112,12 +4270,16 @@ $AUTOLOADED_ROUTINES=<<'END_OF_AUTOLOAD'
 sub new {
     my($package,$sequence) = @_;
     my $filename;
-    find_tempdir() unless -w $TMPDIRECTORY;
+    unless (-w $TMPDIRECTORY) {
+        $TMPDIRECTORY = undef;
+        find_tempdir();
+    }
     for (my $i = 0; $i < $MAXTRIES; $i++) {
 	last if ! -f ($filename = sprintf("\%s${SL}CGItemp%d", $TMPDIRECTORY, $sequence++));
     }
     # check that it is a more-or-less valid filename
-    return unless $filename =~ m!^([a-zA-Z0-9_\+ \'\":/.\$\\~-]+)$!;
+    # Note this same regex is also used elsewhere in the same file for Fh::new
+    return unless $filename =~ m!^([a-zA-Z0-9_ \'\":/.\$\\\+-]+)$!;
     # this used to untaint, now it doesn't
     # $filename = $1;
     return bless \$filename;
@@ -4221,7 +4383,7 @@ a simple "Hello World" HTML page:
 
    #!/usr/local/bin/perl -w
    use CGI;                             # load CGI routines
-   $q = new CGI;                        # create new CGI object
+   $q = CGI->new;                        # create new CGI object
    print $q->header,                    # create the HTTP header
          $q->start_html('hello world'), # start the HTML
          $q->h1('hello world'),         # level 1 header
@@ -4360,7 +4522,7 @@ HTML "standards".
 
 =head2 CREATING A NEW QUERY OBJECT (OBJECT-ORIENTED STYLE):
 
-     $query = new CGI;
+     $query = CGI->new;
 
 This will parse the input (from both POST and GET methods) and store
 it into a perl5 object called $query. 
@@ -4370,7 +4532,7 @@ the beginning of the file. 
 
 =head2 CREATING A NEW QUERY OBJECT FROM AN INPUT FILE
 
-     $query = new CGI(INPUTFILE);
+     $query = CGI->new(INPUTFILE);
 
 If you provide a file handle to the new() method, it will read
 parameters from the file (or STDIN, or whatever).  The file can be in
@@ -4383,7 +4545,7 @@ Perl purists will be pleased to know tha
 references to file handles, or even references to filehandle globs,
 which is the "official" way to pass a filehandle:
 
-    $query = new CGI(\*STDIN);
+    $query = CGI->new(\*STDIN);
 
 You can also initialize the CGI object with a FileHandle or IO::File
 object.
@@ -4400,29 +4562,29 @@ default CGI object from the indicated fi
 You can also initialize the query object from a hash
 reference:
 
-    $query = new CGI( {'dinosaur'=>'barney',
+    $query = CGI->new( {'dinosaur'=>'barney',
 		       'song'=>'I love you',
 		       'friends'=>[qw/Jessica George Nancy/]}
 		    );
 
 or from a properly formatted, URL-escaped query string:
 
-    $query = new CGI('dinosaur=barney&color=purple');
+    $query = CGI->new('dinosaur=barney&color=purple');
 
 or from a previously existing CGI object (currently this clones the
 parameter list, but none of the other object-specific fields, such as
 autoescaping):
 
-    $old_query = new CGI;
-    $new_query = new CGI($old_query);
+    $old_query = CGI->new;
+    $new_query = CGI->new($old_query);
 
 To create an empty query, initialize it from an empty string or hash:
 
-   $empty_query = new CGI("");
+   $empty_query = CGI->new("");
 
        -or-
 
-   $empty_query = new CGI({});
+   $empty_query = CGI->new({});
 
 =head2 FETCHING A LIST OF KEYWORDS FROM THE QUERY:
 
@@ -4561,9 +4723,10 @@ specialized tasks.)
    unshift @{$q->param_fetch(-name=>'address')},'George Munster';
 
 If you need access to the parameter list in a way that isn't covered
-by the methods above, you can obtain a direct reference to it by
-calling the B<param_fetch()> method with the name of the .  This
-will return an array reference to the named parameters, which you then
+by the methods given in the previous sections, you can obtain a direct 
+reference to it by
+calling the B<param_fetch()> method with the name of the parameter.  This
+will return an array reference to the named parameter, which you then
 can manipulate in any way you like.
 
 You can also use a named argument style using the B<-name> argument.
@@ -4625,19 +4788,19 @@ a short example of creating multiple ses
 
    use CGI;
 
-   open (OUT,">>test.out") || die;
+   open (OUT,'>>','test.out') || die;
    $records = 5;
    for (0..$records) {
-       my $q = new CGI;
+       my $q = CGI->new;
        $q->param(-name=>'counter',-value=>$_);
        $q->save(\*OUT);
    }
    close OUT;
 
    # reopen for reading
-   open (IN,"test.out") || die;
+   open (IN,'<','test.out') || die;
    while (!eof(IN)) {
-       my $q = new CGI(\*IN);
+       my $q = CGI->new(\*IN);
        print $q->param('counter'),"\n";
    }
 
@@ -4726,12 +4889,11 @@ Import all methods that generate HTML 4 
 
 =item B<:netscape>
 
-Import all methods that generate Netscape-specific HTML extensions.
+Import the <blink>, <fontsize> and <center> tags. 
 
 =item B<:html>
 
-Import all HTML-generating shortcuts (i.e. 'html2' + 'html3' +
-'netscape')...
+Import all HTML-generating shortcuts (i.e. 'html2', 'html3', 'html4' and 'netscape')
 
 =item B<:standard>
 
@@ -4814,11 +4976,11 @@ The current list of pragmas is as follow
 
 When you I<use CGI -any>, then any method that the query object
 doesn't recognize will be interpreted as a new HTML tag.  This allows
-you to support the next I<ad hoc> Netscape or Microsoft HTML
+you to support the next I<ad hoc> HTML
 extension.  This lets you go wild with new and unsupported tags:
 
    use CGI qw(-any);
-   $q=new CGI;
+   $q=CGI->new;
    print $q->gradient({speed=>'fast',start=>'red',end=>'blue'});
 
 Since using <cite>any</cite> causes any mistyped method name
@@ -4881,7 +5043,8 @@ By default, CGI.pm versions 2.69 and hig
 feature.  Thanks to Michalis Kabrianis <kabrianis@hellug.gr> for this
 feature.
 
-If start_html()'s -dtd parameter specifies an HTML 2.0 or 3.2 DTD, 
+If start_html()'s -dtd parameter specifies an HTML 2.0, 
+3.2, 4.0 or 4.01 DTD, 
 XHTML will automatically be disabled without needing to use this 
 pragma.
 
@@ -4909,11 +5072,9 @@ semicolons rather than ampersands.  For 
 
    ?name=fred;age=24;favorite_color=3
 
-Semicolon-delimited query strings are always accepted, but will not be
-emitted by self_url() and query_string() unless the -newstyle_urls
-pragma is specified.
-
-This became the default in version 2.64.
+Semicolon-delimited query strings are always accepted, and will be emitted by
+self_url() and query_string(). newstyle_urls became the default in version
+2.64.
 
 =item -oldstyle_urls
 
@@ -4970,8 +5131,7 @@ file is created with mode 0600 (neither 
 
 The temporary directory is selected using the following algorithm:
 
-    1. if the current user (e.g. "nobody") has a directory named
-    "tmp" in its home directory, use that (Unix systems only).
+    1. if $CGITempFile::TMPDIRECTORY is already set, use that
 
     2. if the environment variable TMPDIR exists, use the location
     indicated.
@@ -5104,7 +5264,7 @@ indicated expiration date.  The followin
 
 The B<-cookie> parameter generates a header that tells the browser to provide
 a "magic cookie" during all subsequent transactions with your script.
-Netscape cookies have a special format that includes interesting attributes
+Some cookies have a special format that includes interesting attributes
 such as expiration time.  Use the cookie() method to create and retrieve
 session cookies.
 
@@ -5133,15 +5293,27 @@ In either case, the outgoing header will
 
   P3P: policyref="/w3c/p3p.xml" cp="CAO DSP LAW CURa"
 
+Note that if a header value contains a carriage return, a leading space will be
+added to each new line that doesn't already have one as specified by RFC2616
+section 4.2.  For example:
+
+    print header( -ingredients => "ham\neggs\nbacon" );
+
+will generate
+
+    Ingredients: ham
+     eggs
+     bacon
+
 =head2 GENERATING A REDIRECTION HEADER
 
-   print redirect('http://somewhere.else/in/movie/land');
+   print $q->redirect('http://somewhere.else/in/movie/land');
 
 Sometimes you don't want to produce a document yourself, but simply
 redirect the browser elsewhere, perhaps choosing a URL based on the
 time of day or the identity of the user.  
 
-The redirect() function redirects the browser to a different URL.  If
+The redirect() method redirects the browser to a different URL.  If
 you use redirection like this, you should B<not> print out a header as
 well.
 
@@ -5150,9 +5322,14 @@ redirection requests.  Relative URLs wil
 
 You can also use named arguments:
 
-    print redirect(-uri=>'http://somewhere.else/in/movie/land',
-			   -nph=>1,
-                           -status=>301);
+    print $q->redirect(
+        -uri=>'http://somewhere.else/in/movie/land',
+	    -nph=>1,
+         -status=>301);
+
+All names arguments recognized by header() are also recognized by
+redirect(). However, most HTTP headers, including those generated by
+-cookie and -target, are ignored by the browser.
 
 The B<-nph> parameter, if set to a true value, will issue the correct
 headers to work with a NPH (no-parse-header) script.  This is important
@@ -5182,8 +5359,7 @@ advised that changing the status to anyt
 			    -style=>{'src'=>'/styles/style1.css'},
 			    -BGCOLOR=>'blue');
 
-After creating the HTTP header, most CGI scripts will start writing
-out an HTML document.  The start_html() routine creates the top of the
+The start_html() routine creates the top of the
 page, along with a lot of optional information that controls the
 page's appearance and behavior.
 
@@ -5191,7 +5367,7 @@ This method returns a canned HTML header
 All parameters are optional.  In the named parameter form, recognized
 parameters are -title, -author, -base, -xbase, -dtd, -lang and -target
 (see below for the explanation).  Any additional parameters you
-provide, such as the Netscape unofficial BGCOLOR attribute, are added
+provide, such as the unofficial BGCOLOR attribute, are added
 to the <body> tag.  Additional parameters must be proceeded by a
 hyphen.
 
@@ -5204,9 +5380,7 @@ All relative links will be interpreted r
 
 The argument B<-target> allows you to provide a default target frame
 for all the links and fill-out forms on the page.  B<This is a
-non-standard HTTP feature which only works with Netscape browsers!>
-See the Netscape documentation on frames for details of how to
-manipulate this.
+non-standard HTTP feature which only works with some browsers!>
 
     -target=>"answer_window"
 
@@ -5239,6 +5413,18 @@ off in other cases by passing an empty s
 The B<-encoding> argument can be used to specify the character set for
 XHTML.  It defaults to iso-8859-1 if not specified.
 
+The B<-dtd> argument can be used to specify a public DTD identifier string. For example:
+
+    -dtd => '-//W3C//DTD HTML 4.01 Transitional//EN')
+
+Alternatively, it can take public and system DTD identifiers as an array:
+
+    dtd => [ '-//W3C//DTD HTML 4.01 Transitional//EN', 'http://www.w3.org/TR/html4/loose.dtd' ]
+
+For the public DTD identifier to be considered, it must be valid. Otherwise it
+will be replaced by the default DTD. If the public DTD contains 'XHTML', CGI.pm
+will emit XML.
+
 The B<-declare_xml> argument, when used in conjunction with XHTML,
 will put a <?xml> declaration at the top of the HTML header. The sole
 purpose of this declaration is to declare the character set
@@ -5247,11 +5433,11 @@ a <meta> tag that specifies the encoding
 most validators.  The default for -declare_xml is false.
 
 You can place other arbitrary HTML elements to the <head> section with the
-B<-head> tag.  For example, to place the rarely-used <link> element in the
+B<-head> tag.  For example, to place a <link> element in the
 head section, use this:
 
-    print start_html(-head=>Link({-rel=>'next',
-		                  -href=>'http://www.capricorn.com/s2.html'}));
+    print start_html(-head=>Link({-rel=>'shortcut icon',
+		                  -href=>'favicon.ico'}));
 
 To incorporate multiple HTML elements into the <head> section, just pass an
 array reference:
@@ -5272,7 +5458,7 @@ And here's how to create an HTTP-EQUIV <
 
 JAVASCRIPTING: The B<-script>, B<-noScript>, B<-onLoad>,
 B<-onMouseOver>, B<-onMouseOut> and B<-onUnload> parameters are used
-to add Netscape JavaScript calls to your pages.  B<-script> should
+to add JavaScript calls to your pages.  B<-script> should
 point to a block of text containing JavaScript function definitions.
 This block will be placed within a <script> block inside the HTML (not
 HTTP) header.  The block is placed in the header in order to give your
@@ -5288,7 +5474,7 @@ code to execute when the page is respect
 browser.  Usually these parameters are calls to functions defined in the
 B<-script> field:
 
-      $query = new CGI;
+      $query = CGI->new;
       print header;
       $JSCRIPT=<<END;
       // Ask a silly question
@@ -5313,12 +5499,10 @@ Use the B<-noScript> parameter to pass s
 browsers that do not have JavaScript (or browsers where JavaScript is turned
 off).
 
-The <script> tag, has several attributes including "type" and src.
-The latter is particularly interesting, as it allows you to keep the
-JavaScript code in a file or CGI script rather than cluttering up each
-page with the source.  To use these attributes pass a HASH reference
-in the B<-script> parameter containing one or more of -type, -src, or
--code:
+The <script> tag, has several attributes including "type", "charset" and "src".
+"src" allows you to keep JavaScript code in an external file. To use these
+attributes pass a HASH reference in the B<-script> parameter containing one or
+more of -type, -src, or -code:
 
     print $q->start_html(-title=>'The Riddle of the Sphinx',
 			 -script=>{-type=>'JAVASCRIPT',
@@ -5354,7 +5538,7 @@ of JavaScript.  Example:
                              );
 
 The option "-language" is a synonym for -type, and is supported for
-backwad compatibility.
+backwards compatibility.
 
 The old-style positional parameters are as follows:
 
@@ -5379,7 +5563,7 @@ but makes the document hierarchy non-por
 =item 4, 5, 6...
 
 Any other parameters you want to include in the <body> tag.  This is a good
-place to put Netscape extensions, such as colors and wallpaper patterns.
+place to put HTML extensions, such as colors and wallpaper patterns.
 
 =back
 
@@ -5499,14 +5683,8 @@ method, the results will not be what you
 
 =head1 CREATING STANDARD HTML ELEMENTS:
 
-CGI.pm defines general HTML shortcut methods for most, if not all of
-the HTML 3 and HTML 4 tags.  HTML shortcuts are named after a single
-HTML element and return a fragment of HTML text that you can then
-print or manipulate as you like.  Each shortcut returns a fragment of
-HTML code that you can append to a string, save to a file, or, most
-commonly, print out so that it displays in the browser window.
-
-This example shows how to use the HTML methods:
+CGI.pm defines general HTML shortcut methods for many HTML tags.  HTML shortcuts are named after a single
+HTML element and return a fragment of HTML text. Example:
 
    print $q->blockquote(
 		     "Many years ago on the island of",
@@ -5606,7 +5784,7 @@ This is extremely useful for creating ta
 
    print table({-border=>undef},
            caption('When Should You Eat Your Vegetables?'),
-           Tr({-align=>CENTER,-valign=>TOP},
+           Tr({-align=>'CENTER',-valign=>'TOP'},
            [
               th(['Vegetable', 'Breakfast','Lunch','Dinner']),
               td(['Tomatoes' , 'no', 'yes', 'yes']),
@@ -5691,6 +5869,13 @@ passing a -charset argument to header(),
 be replaced by their numeric entities, since CGI.pm has no lookup
 table for all the possible encodings.
 
+C<escapeHTML()> expects the supplied string to be a character string. This means you
+should Encode::decode data received from "outside" and Encode::encode your
+strings before sending them back outside. If your source code UTF-8 encoded and
+you want to upgrade string literals in your source to character strings, you
+can use "use utf8". See L<perlunitut>, L<perlunifaq> and L<perlunicode> for more
+information on how Perl handles the difference between bytes and characters.
+
 The automatic escaping does not apply to other shortcuts, such as
 h1().  You should call escapeHTML() yourself on untrusted data in
 order to protect your pages against nasty tricks that people may enter
@@ -5751,8 +5936,12 @@ your ability to incorporate special HTML
 into your fields.  If you wish to turn off automatic escaping, call the
 autoEscape() method with a false value immediately after creating the CGI object:
 
-   $query = new CGI;
-   autoEscape(undef);
+   $query = CGI->new;
+   $query->autoEscape(0);
+
+Note that autoEscape() is exclusively used to effect the behavior of how some
+CGI.pm HTML generation functions handle escaping. Calling escapeHTML()
+explicitly will always escape the HTML.
 
 I<A Lurking Trap!> Some of the form-element generating methods return
 multiple tags.  In a scalar context, the tags will be concatenated
@@ -5787,46 +5976,47 @@ default is to process the query with the
 		    -action=>$action,
 		    -enctype=>$encoding);
       <... various form stuff ...>
-    print endform;
+    print end_form;
 
 	-or-
 
     print start_form($method,$action,$encoding);
       <... various form stuff ...>
-    print endform;
+    print end_form;
 
 start_form() will return a <form> tag with the optional method,
 action and form encoding that you specify.  The defaults are:
 
     method: POST
     action: this script
-    enctype: application/x-www-form-urlencoded
+    enctype: application/x-www-form-urlencoded for non-XHTML
+             multipart/form-data for XHTML, see multipart/form-data below.
 
-endform() returns the closing </form> tag.  
+end_form() returns the closing </form> tag.  
 
 Start_form()'s enctype argument tells the browser how to package the various
 fields of the form before sending the form to the server.  Two
 values are possible:
 
-B<Note:> This method was previously named startform(), and startform()
-is still recognized as an alias.
+B<Note:> These methods were previously named startform() and endform().
+These methods are now DEPRECATED.
+Please use start_form() and end_form() instead.
 
 =over 4
 
 =item B<application/x-www-form-urlencoded>
 
-This is the older type of encoding used by all browsers prior to
-Netscape 2.0.  It is compatible with many CGI scripts and is
+This is the older type of encoding.  It is compatible with many CGI scripts and is
 suitable for short fields containing text data.  For your
 convenience, CGI.pm stores the name of this encoding
 type in B<&CGI::URL_ENCODED>.
 
 =item B<multipart/form-data>
 
-This is the newer type of encoding introduced by Netscape 2.0.
+This is the newer type of encoding.
 It is suitable for forms that contain very large fields or that
 are intended for transferring binary data.  Most importantly,
-it enables the "file upload" feature of Netscape 2.0 forms.  For
+it enables the "file upload" feature.  For
 your convenience, CGI.pm stores the name of this encoding type
 in B<&CGI::MULTIPART>
 
@@ -5839,10 +6029,11 @@ created using this type of encoding.
 
 =back
 
-For compatibility, the start_form() method uses the older form of
-encoding by default.  If you want to use the newer form of encoding
-by default, you can call B<start_multipart_form()> instead of
-B<start_form()>.
+The start_form() method uses the older form of encoding by
+default unless XHTML is requested.  If you want to use the
+newer form of encoding by default, you can call
+B<start_multipart_form()> instead of B<start_form()>.  The
+method B<end_multipart_form()> is an alias to B<end_form()>.
 
 JAVASCRIPTING: The B<-name> and B<-onSubmit> parameters are provided
 for use with JavaScript.  The -name parameter gives the
@@ -5895,7 +6086,7 @@ JavaScript and DHTML.
 
 A boolean, which, if true, forces the element to take on the value
 specified by B<-value>, overriding the sticky behavior described
-earlier for the B<-no_sticky> pragma.
+earlier for the B<-nosticky> pragma.
 
 =item B<-onChange>, B<-onFocus>, B<-onBlur>, B<-onMouseOver>, B<-onMouseOut>, B<-onSelect>
 
@@ -5996,7 +6187,7 @@ will be starred out on the web page.
 
     print filefield('uploaded_file','starting value',50,80);
 
-filefield() will return a file upload field for Netscape 2.0 browsers.
+filefield() will return a file upload field.
 In order to take full advantage of this I<you must use the new 
 multipart encoding scheme> for the form.  You can do this either
 by calling B<start_form()> with an encoding type of B<&CGI::MULTIPART>,
@@ -6034,75 +6225,55 @@ field will accept (-maxlength).
 
 =back
 
-When the form is processed, you can retrieve the entered filename
-by calling param():
+JAVASCRIPTING: The B<-onChange>, B<-onFocus>, B<-onBlur>,
+B<-onMouseOver>, B<-onMouseOut> and B<-onSelect> parameters are
+recognized.  See textfield() for details.
 
-       $filename = param('uploaded_file');
+=head2 PROCESSING A FILE UPLOAD FIELD
 
-Different browsers will return slightly different things for the
-name.  Some browsers return the filename only.  Others return the full
-path to the file, using the path conventions of the user's machine.
-Regardless, the name returned is always the name of the file on the
-I<user's> machine, and is unrelated to the name of the temporary file
-that CGI.pm creates during upload spooling (see below).
+=head3 Basics
 
-The filename returned is also a file handle.  You can read the contents
-of the file using standard Perl file reading calls:
+When the form is processed, you can retrieve an L<IO::Handle> compatible
+handle for a file upload field like this:
 
-	# Read a text file and print it out
-	while (<$filename>) {
-	   print;
-	}
+  $lightweight_fh  = $q->upload('field_name');
 
-	# Copy a binary file to somewhere safe
-	open (OUTFILE,">>/usr/local/web/users/feedback");
-	while ($bytesread=read($filename,$buffer,1024)) {
-	   print OUTFILE $buffer;
-	}
+  # undef may be returned if it's not a valid file handle
+  if (defined $lightweight_fh) {
+    # Upgrade the handle to one compatible with IO::Handle:
+    my $io_handle = $lightweight_fh->handle;
 
-However, there are problems with the dual nature of the upload fields.
-If you C<use strict>, then Perl will complain when you try to use a
-string as a filehandle.  You can get around this by placing the file
-reading code in a block containing the C<no strict> pragma.  More
-seriously, it is possible for the remote user to type garbage into the
-upload field, in which case what you get from param() is not a
-filehandle at all, but a string.
-
-To be safe, use the I<upload()> function (new in version 2.47).  When
-called with the name of an upload field, I<upload()> returns a
-filehandle-like object, or undef if the parameter is not a valid
-filehandle.
-
-     $fh = upload('uploaded_file');
-     while (<$fh>) {
-	   print;
-     }
+    open (OUTFILE,'>>','/usr/local/web/users/feedback');
+    while ($bytesread = $io_handle->read($buffer,1024)) {
+      print OUTFILE $buffer;
+    }
+  }
 
 In a list context, upload() will return an array of filehandles.
-This makes it possible to create forms that use the same name for
+This makes it possible to process forms that use the same name for
 multiple upload fields.
 
-This is the recommended idiom.
+If you want the entered file name for the file, you can just call param():
 
-The lightweight filehandle returned by CGI.pm is not compatible with
-IO::Handle; for example, it does not have read() or getline()
-functions, but instead must be manipulated using read($fh) or
-<$fh>. To get a compatible IO::Handle object, call the handle's
-handle() method:
+  $filename = $q->param('field_name');
 
-  my $real_io_handle = upload('uploaded_file')->handle;
+Different browsers will return slightly different things for the
+name.  Some browsers return the filename only.  Others return the full
+path to the file, using the path conventions of the user's machine.
+Regardless, the name returned is always the name of the file on the
+I<user's> machine, and is unrelated to the name of the temporary file
+that CGI.pm creates during upload spooling (see below).
 
 When a file is uploaded the browser usually sends along some
 information along with it in the format of headers.  The information
-usually includes the MIME content type.  Future browsers may send
-other information as well (such as modification date and size). To
+usually includes the MIME content type. To
 retrieve this information, call uploadInfo().  It returns a reference to
 a hash containing all the document headers.
 
-       $filename = param('uploaded_file');
-       $type = uploadInfo($filename)->{'Content-Type'};
+       $filename = $q->param('uploaded_file');
+       $type = $q->uploadInfo($filename)->{'Content-Type'};
        unless ($type eq 'text/html') {
-	  die "HTML FILES ONLY!";
+        die "HTML FILES ONLY!";
        }
 
 If you are using a machine that recognizes "text" and "binary" data
@@ -6110,6 +6281,24 @@ modes, be sure to understand when and ho
 Otherwise you may find that binary files are corrupted during file
 uploads.
 
+=head3 Accessing the temp files directly
+
+When processing an uploaded file, CGI.pm creates a temporary file on your hard
+disk and passes you a file handle to that file. After you are finished with the
+file handle, CGI.pm unlinks (deletes) the temporary file. If you need to you
+can access the temporary file directly. You can access the temp file for a file
+upload by passing the file name to the tmpFileName() method:
+
+       $filename = $query->param('uploaded_file');
+       $tmpfilename = $query->tmpFileName($filename);
+
+The temporary file will be deleted automatically when your program exits unless
+you manually rename it. On some operating systems (such as Windows NT), you
+will need to close the temporary file's filehandle before your program exits.
+Otherwise the attempt to delete the temporary file will fail.
+
+=head3 Handling interrupted file uploads
+
 There are occasionally problems involving parsing the uploaded file.
 This usually happens when the user presses "Stop" before the upload is
 finished.  In this case, CGI.pm will return undef for the name of the
@@ -6118,35 +6307,39 @@ uploaded file and set I<cgi_error()> to 
 you can incorporate it into a status code to be sent to the browser.
 Example:
 
-   $file = upload('uploaded_file');
-   if (!$file && cgi_error) {
-      print header(-status=>cgi_error);
+   $file = $q->upload('uploaded_file');
+   if (!$file && $q->cgi_error) {
+      print $q->header(-status=>$q->cgi_error);
       exit 0;
    }
 
 You are free to create a custom HTML page to complain about the error,
 if you wish.
 
-You can set up a callback that will be called whenever a file upload
-is being read during the form processing. This is much like the
-UPLOAD_HOOK facility available in Apache::Request, with the exception
-that the first argument to the callback is an Apache::Upload object,
-here it's the remote filename.
+=head3 Progress bars for file uploads and avoiding temp files
+
+CGI.pm gives you low-level access to file upload management through
+a file upload hook. You can use this feature to completely turn off
+the temp file storage of file uploads, or potentially write your own
+file upload progress meter.
+
+This is much like the UPLOAD_HOOK facility available in L<Apache::Request>, with
+the exception that the first argument to the callback is an L<Apache::Upload>
+object, here it's the remote filename.
 
  $q = CGI->new(\&hook [,$data [,$use_tempfile]]);
 
- sub hook
- {
+ sub hook {
         my ($filename, $buffer, $bytes_read, $data) = @_;
-        print  "Read $bytes_read bytes of $filename\n";         
+        print  "Read $bytes_read bytes of $filename\n";
  }
 
-The $data field is optional; it lets you pass configuration
+The C<< $data >> field is optional; it lets you pass configuration
 information (e.g. a database handle) to your hook callback.
 
-The $use_tempfile field is a flag that lets you turn on and off
+The C<< $use_tempfile >> field is a flag that lets you turn on and off
 CGI.pm's use of a temporary disk-based file during file upload. If you
-set this to a FALSE value (default true) then param('uploaded_file')
+set this to a FALSE value (default true) then $q->param('uploaded_file')
 will no longer work, and the only way to get at the uploaded data is
 via the hook you provide.
 
@@ -6158,15 +6351,34 @@ method before calling param() or any oth
 This method is not exported by default.  You will have to import it
 explicitly if you wish to use it without the CGI:: prefix.
 
+=head3 Troubleshooting file uploads on Windows
+
 If you are using CGI.pm on a Windows platform and find that binary
 files get slightly larger when uploaded but that text files remain the
 same, then you have forgotten to activate binary mode on the output
 filehandle.  Be sure to call binmode() on any handle that you create
 to write the uploaded file to disk.
 
-JAVASCRIPTING: The B<-onChange>, B<-onFocus>, B<-onBlur>,
-B<-onMouseOver>, B<-onMouseOut> and B<-onSelect> parameters are
-recognized.  See textfield() for details.
+=head3 Older ways to process file uploads
+
+( This section is here for completeness. if you are building a new application with CGI.pm, you can skip it. )
+
+The original way to process file uploads with CGI.pm was to use param(). The
+value it returns has a dual nature as both a file name and a lightweight
+filehandle. This dual nature is problematic if you following the recommended
+practice of having C<use strict> in your code. Perl will complain when you try
+to use a string as a filehandle.  More seriously, it is possible for the remote
+user to type garbage into the upload field, in which case what you get from
+param() is not a filehandle at all, but a string.
+
+To solve this problem the upload() method was added, which always returns a
+lightweight filehandle. This generally works well, but will have trouble
+interoperating with some other modules because the file handle is not derived
+from L<IO::Handle>. So that brings us to current recommendation given above,
+which is to call the handle() method on the file handle returned by upload().
+That upgrades the handle to an IO::Handle. It's a big win for compatibility for
+a small penalty of loading IO::Handle the first time you call it.
+
 
 =head2 CREATING A POPUP MENU
 
@@ -6798,11 +7010,11 @@ Fetch the value of the button this way:
 
 	-or-
 
-     print button('button_name',"do_something()");
+     print button('button_name',"user visible value","do_something()");
 
-button() produces a button that is compatible with Netscape 2.0's
-JavaScript.  When it's pressed the fragment of JavaScript code
-pointed to by the B<-onClick> parameter will be executed.
+button() produces an C<< <input> >> tag with C<type="button">.  When it's
+pressed the fragment of JavaScript code pointed to by the B<-onClick> parameter
+will be executed.
 
 =head1 HTTP COOKIES
 
@@ -6932,7 +7144,7 @@ without the B<-value> parameter. This ex
 form:
 
 	use CGI;
-	$query = new CGI;
+	$query = CGI->new;
 	$riddle = $query->cookie('riddle_name');
         %answers = $query->cookie('answers');
 
@@ -6974,10 +7186,7 @@ document that defines the frames on the 
 (with appropriate parameters) as the SRC for each of the frames.
 
 There is no specific support for creating <frameset> sections 
-in CGI.pm, but the HTML is very simple to write.  See the frame
-documentation in Netscape's home pages for details 
-
-  http://wp.netscape.com/assist/net_sites/frames.html
+in CGI.pm, but the HTML is very simple to write.  
 
 =item 2. Specify the destination for the document in the HTTP header
 
@@ -6989,8 +7198,7 @@ This will tell the browser to load the o
 frame named "ResultsWindow".  If a frame of that name doesn't already
 exist, the browser will pop up a new window and load your script's
 document into that.  There are a number of magic names that you can
-use for targets.  See the frame documents on Netscape's home pages for
-details.
+use for targets.  See the HTML C<< <frame> >> documentation for details.
 
 =item 3. Specify the destination for the document in the <form> tag
 
@@ -7139,7 +7347,7 @@ start_html() method provides a convenien
 Similarly, you can create a form that checks itself over for
 consistency and alerts the user if some essential value is missing by
 creating it this way: 
-  print startform(-onSubmit=>"validateMe(this)");
+  print start_form(-onSubmit=>"validateMe(this)");
 
 See the javascript.cgi script for a demonstration of how this all
 works.
@@ -7182,7 +7390,7 @@ section of text:
 Note that you must import the ":html3" definitions to have the
 B<span()> method available.  Here's a quick and dirty example of using
 CSS's.  See the CSS specification at
-http://www.w3.org/pub/WWW/TR/Wd-css-1.html for more information.
+http://www.w3.org/Style/CSS/ for more information.
 
     use CGI qw/:standard :html3/;
 
@@ -7328,7 +7536,7 @@ Produces something that looks like:
 As a shortcut, you can interpolate the entire CGI object into a string
 and it will be replaced with the a nice HTML dump shown above:
 
-    $query=new CGI;
+    $query=CGI->new;
     print "<h2>Current Values</h2> $query\n";
 
 =head1 FETCHING ENVIRONMENT VARIABLES
@@ -7399,8 +7607,13 @@ path as well.
 Returns either the remote host name or IP address.
 if the former is unavailable.
 
+=item B<remote_addr()>
+
+Returns the remote host IP address, or 
+127.0.0.1 if the address is unavailable.
+
 =item B<script_name()>
-Return the script name as a partial URL, for self-refering
+Return the script name as a partial URL, for self-referring
 scripts.
 
 =item B<referer()>
@@ -7509,7 +7722,7 @@ note that if you have applied Service Pa
 functionality of NPH scripts, including the ability to redirect while
 setting a cookie, B<do not work at all> on IIS without a special patch
 from Microsoft.  See
-http://support.microsoft.com/support/kb/articles/Q280/3/41.ASP:
+http://web.archive.org/web/20010812012030/http://support.microsoft.com/support/kb/articles/Q280/3/41.ASP
 Non-Parsed Headers Stripped From CGI Applications That Have nph-
 Prefix in Name.
 
@@ -7517,7 +7730,7 @@ Prefix in Name.
 
 =item In the B<use> statement 
 
-Simply add the "-nph" pragmato the list of symbols to be imported into
+Simply add the "-nph" pragma to the list of symbols to be imported into
 your script:
 
       use CGI qw(:standard -nph)
@@ -7703,11 +7916,13 @@ To make it easier to port existing progr
 compatibility routine "ReadParse" is provided.  Porting is simple:
 
 OLD VERSION
+
     require "cgi-lib.pl";
     &ReadParse;
     print "The value of the antique is $in{antique}.\n";
 
 NEW VERSION
+
     use CGI;
     CGI::ReadParse();
     print "The value of the antique is $in{antique}.\n";
@@ -7715,22 +7930,71 @@ NEW VERSION
 CGI.pm's ReadParse() routine creates a tied variable named %in,
 which can be accessed to obtain the query variables.  Like
 ReadParse, you can also provide your own variable.  Infrequently
-used features of ReadParse, such as the creation of @in and $in 
+used features of ReadParse, such as the creation of @in and $in
 variables, are not supported.
 
 Once you use ReadParse, you can retrieve the query object itself
 this way:
 
     $q = $in{CGI};
-    print textfield(-name=>'wow',
-			-value=>'does this really work?');
+    print $q->textfield(-name=>'wow',
+            -value=>'does this really work?');
 
 This allows you to start using the more interesting features
 of CGI.pm without rewriting your old scripts from scratch.
 
+An even simpler way to mix cgi-lib calls with CGI.pm calls is to import both the
+C<:cgi-lib> and C<:standard> method:
+
+ use CGI qw(:cgi-lib :standard);
+ &ReadParse;
+ print "The price of your purchase is $in{price}.\n";
+ print textfield(-name=>'price', -default=>'$1.99');
+
+=head2 Cgi-lib functions that are available in CGI.pm
+
+In compatability mode, the following cgi-lib.pl functions are
+available for your use:
+
+ ReadParse()
+ PrintHeader()
+ HtmlTop()
+ HtmlBot()
+ SplitParam()
+ MethGet()
+ MethPost()
+
+=head2 Cgi-lib functions that are not available in CGI.pm
+
+  * Extended form of ReadParse()
+    The extended form of ReadParse() that provides for file upload
+    spooling, is not available.
+
+  * MyBaseURL()
+    This function is not available.  Use CGI.pm's url() method instead.
+
+  * MyFullURL()
+    This function is not available.  Use CGI.pm's self_url() method
+    instead.
+
+  * CgiError(), CgiDie()
+    These functions are not supported.  Look at CGI::Carp for the way I
+    prefer to handle error messages.
+
+  * PrintVariables()
+    This function is not available.  To achieve the same effect,
+       just print out the CGI object:
+
+       use CGI qw(:standard);
+       $q = CGI->new;
+       print h1("The Variables Are"),$q;
+
+  * PrintEnv()
+    This function is not available. You'll have to roll your own if you really need it.
+
 =head1 AUTHOR INFORMATION
 
-The GD.pm interface is copyright 1995-2007, Lincoln D. Stein.  It is
+The CGI.pm distribution is copyright 1995-2007, Lincoln D. Stein.  It is
 distributed under GPL and the Artistic License 2.0.
 
 Address bug reports and comments to: lstein@cshl.org.  When sending
@@ -7738,7 +8002,7 @@ bug reports, please provide the version 
 Perl, the name and version of your Web server, and the name and
 version of the operating system you are using.  If the problem is even
 remotely browser dependent, please provide information about the
-affected browers as well.
+affected browsers as well.
 
 =head1 CREDITS
 
@@ -7849,18 +8113,17 @@ for suggestions and bug fixes.
 	   print "<p>",reset;
 	   print submit('Action','Shout');
 	   print submit('Action','Scream');
-	   print endform;
+	   print end_form;
 	   print "<hr>\n";
 	}
 
 	sub do_work {
-	   my(@values,$key);
 
 	   print "<h2>Here are the current settings in this form</h2>";
 
-	   for $key (param) {
+	   for my $key (param) {
 	      print "<strong>$key</strong> -> ";
-	      @values = param($key);
+	      my @values = param($key);
 	      print join(", ",@values),"<br>\n";
 	  }
 	}
@@ -7879,7 +8142,11 @@ Please report them.
 
 =head1 SEE ALSO
 
-L<CGI::Carp>, L<CGI::Fast>, L<CGI::Pretty>
+L<CGI::Carp> - provides a L<Carp> implementation tailored to the CGI environment.
+
+L<CGI::Fast> - supports running CGI applications under FastCGI
+
+L<CGI::Pretty> - pretty prints HTML generated by CGI.pm (with a performance penalty)
 
 =cut
 
diff -up perl-5.10.1/lib/CGI/Pretty.pm.cgiup perl-5.10.1/lib/CGI/Pretty.pm
--- perl-5.10.1/lib/CGI/Pretty.pm.cgiup	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/Pretty.pm	2011-01-05 19:13:45.000000000 +0100
@@ -10,7 +10,7 @@ package CGI::Pretty;
 use strict;
 use CGI ();
 
-$CGI::Pretty::VERSION = '1.08';
+$CGI::Pretty::VERSION = '3.46';
 $CGI::DefaultClass = __PACKAGE__;
 $CGI::Pretty::AutoloadClass = 'CGI';
 @CGI::Pretty::ISA = qw( CGI );
@@ -105,7 +105,7 @@ sub _make_tag_func {
                       
   	              \$args[0] .= \$" if \$args[0] !~ /\$CGI::Pretty::LINEBREAK\$/ && 1;
 		  }
-                  chop \$args[0];
+                  chop \$args[0] unless \$" eq "";
 	      }
             }
             else {
@@ -114,9 +114,8 @@ sub _make_tag_func {
 
             my \@result;
             if ( exists \$ASIS{ "\L$tagname\E" } ) {
-		\@result = map { "\$tag\$_\$untag\$CGI::Pretty::LINEBREAK" } 
-		 \@args;
-	    }
+                \@result = map { "\$tag\$_\$untag" } \@args;
+            }
 	    else {
 		\@result = map { 
 		    chomp; 
@@ -127,8 +126,11 @@ sub _make_tag_func {
                     \$untag . \$CGI::Pretty::LINEBREAK
                 } \@args;
 	    }
-	    local \$" = "" if \$CGI::Pretty::LINEBREAK || \$CGI::Pretty::INDENT;
-	    return "\@result";
+            if (\$CGI::Pretty::LINEBREAK || \$CGI::Pretty::INDENT) {
+                return join ("", \@result);
+            } else {
+                return "\@result";
+            }
 	}#;
     }    
 
@@ -170,6 +172,7 @@ sub initialize_globals {
     $CGI::Pretty::LINEBREAK = $/;
 
     # These tags are not prettify'd.
+    # When this list is updated, also update the docs.
     @CGI::Pretty::AS_IS = qw( a pre code script textarea td );
 
     1;
@@ -242,21 +245,29 @@ it.
 now produces the following output:
     <TABLE>
        <TR>
-          <TD>
-             foo
-          </TD>
+          <TD>foo</TD>
        </TR>
     </TABLE>
 
+=head2 Recommendation for when to use CGI::Pretty
+
+CGI::Pretty is far slower than using CGI.pm directly. A benchmark showed that
+it could be about 10 times slower. Adding newlines and spaces may alter the
+rendered appearance of HTML. Also, the extra newlines and spaces also make the
+file size larger, making the files take longer to download.
+
+With all those considerations, it is recommended that CGI::Pretty be used
+primarily for debugging.
 
 =head2 Tags that won't be formatted
 
-The <A> and <PRE> tags are not formatted.  If these tags were formatted, the
+The following tags are not formatted: <a>, <pre>, <code>, <script>, <textarea>, and <td>.
+If these tags were formatted, the
 user would see the extra indentation on the web browser causing the page to
 look different than what would be expected.  If you wish to add more tags to
 the list of tags that are not to be touched, push them onto the C<@AS_IS> array:
 
-    push @CGI::Pretty::AS_IS,qw(CODE XMP);
+    push @CGI::Pretty::AS_IS,qw(XMP);
 
 =head2 Customizing the Indenting
 
@@ -279,10 +290,6 @@ the following:
 
     $CGI::Pretty::INDENT = $CGI::Pretty::LINEBREAK = "";
 
-=head1 BUGS
-
-This section intentionally left blank.
-
 =head1 AUTHOR
 
 Brian Paulsen <Brian@ThePaulsens.com>, with minor modifications by
diff -up perl-5.10.1/lib/CGI/Push.pm.cgiup perl-5.10.1/lib/CGI/Push.pm
--- perl-5.10.1/lib/CGI/Push.pm.cgiup	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/Push.pm	2011-01-05 19:13:45.000000000 +0100
@@ -16,7 +16,7 @@ package CGI::Push;
 # The most recent version and complete docs are available at:
 #   http://stein.cshl.org/WWW/software/CGI/
 
-$CGI::Push::VERSION='1.04';
+$CGI::Push::VERSION='1.05';
 use CGI;
 use CGI::Util 'rearrange';
 @ISA = ('CGI');
@@ -214,7 +214,7 @@ itself should have exactly the same call
 
 This optional parameter indicates the content type of each page.  It
 defaults to "text/html".  Normally the module assumes that each page
-is of a homogenous MIME type.  However if you provide either of the
+is of a homogeneous MIME type.  However if you provide either of the
 magic values "heterogeneous" or "dynamic" (the latter provided for the
 convenience of those who hate long parameter names), you can specify
 the MIME type -- and other header fields -- on a per-page basis.  See 
diff -up perl-5.10.1/lib/CGI/Switch.pm.cgiup perl-5.10.1/lib/CGI/Switch.pm
--- perl-5.10.1/lib/CGI/Switch.pm.cgiup	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/Switch.pm	2011-01-05 19:13:45.000000000 +0100
@@ -1,6 +1,7 @@
+package CGI::Switch;
 use CGI;
 
-$VERSION = '1.00';
+$VERSION = '1.01';
 
 1;
 
diff -up perl-5.10.1/lib/CGI/Util.pm.cgiup perl-5.10.1/lib/CGI/Util.pm
--- perl-5.10.1/lib/CGI/Util.pm.cgiup	2009-04-22 21:35:40.000000000 +0200
+++ perl-5.10.1/lib/CGI/Util.pm	2011-01-05 19:13:45.000000000 +0100
@@ -1,15 +1,16 @@
 package CGI::Util;
 
 use strict;
-use vars qw($VERSION @EXPORT_OK @ISA $EBCDIC @A2E @E2A);
+use vars qw($VERSION @EXPORT_OK @ISA @A2E @E2A);
 require Exporter;
 @ISA = qw(Exporter);
 @EXPORT_OK = qw(rearrange rearrange_header make_attributes unescape escape 
 		expires ebcdic2ascii ascii2ebcdic);
 
-$VERSION = '1.5_01';
+$VERSION = '3.51';
+
+use constant EBCDIC => "\t" ne "\011";
 
-$EBCDIC = "\t" ne "\011";
 # (ord('^') == 95) for codepage 1047 as on os390, vmesa
 @A2E = (
    0,  1,  2,  3, 55, 45, 46, 47, 22,  5, 21, 11, 12, 13, 14, 15,
@@ -48,7 +49,7 @@ $EBCDIC = "\t" ne "\011";
   48, 49, 50, 51, 52, 53, 54, 55, 56, 57,179,219,220,217,218,159
 	 );
 
-if ($EBCDIC && ord('^') == 106) { # as in the BS2000 posix-bc coded character set
+if (EBCDIC && ord('^') == 106) { # as in the BS2000 posix-bc coded character set
      $A2E[91] = 187;   $A2E[92] = 188;  $A2E[94] = 106;  $A2E[96] = 74;
      $A2E[123] = 251;  $A2E[125] = 253; $A2E[126] = 255; $A2E[159] = 95;
      $A2E[162] = 176;  $A2E[166] = 208; $A2E[168] = 121; $A2E[172] = 186;
@@ -61,7 +62,7 @@ if ($EBCDIC && ord('^') == 106) { # as i
      $E2A[221] = 219; $E2A[224] = 217; $E2A[251] = 123; $E2A[253] = 125;
      $E2A[255] = 126;
    }
-elsif ($EBCDIC && ord('^') == 176) { # as in codepage 037 on os400
+elsif (EBCDIC && ord('^') == 176) { # as in codepage 037 on os400
   $A2E[10] = 37;  $A2E[91] = 186;  $A2E[93] = 187; $A2E[94] = 176;
   $A2E[133] = 21; $A2E[168] = 189; $A2E[172] = 95; $A2E[221] = 173;
 
@@ -210,10 +211,10 @@ sub unescape {
   my $todecode = shift;
   return undef unless defined($todecode);
   $todecode =~ tr/+/ /;       # pluses become spaces
-    if ($EBCDIC) {
+    if (EBCDIC) {
       $todecode =~ s/%([0-9a-fA-F]{2})/chr $A2E[hex($1)]/ge;
     } else {
-	# handle surrogate pairs first -- dankogai
+	# handle surrogate pairs first -- dankogai. Ref: http://unicode.org/faq/utf_bom.html#utf16-2
 	$todecode =~ s{
 			%u([Dd][89a-bA-B][0-9a-fA-F]{2}) # hi
 		        %u([Dd][c-fC-F][0-9a-fA-F]{2})   # lo
@@ -244,12 +245,40 @@ sub unescape {
 # was always so and cannot be fixed without breaking the binary data case.
 # -- Stepan Kasal <skasal@redhat.com>
 #
+if ($] == 5.008) {
+   package utf8;
+
+   no warnings 'redefine'; # needed for Perl 5.8.1+
+
+   my $is_utf8_redefinition = <<'EOR';
+      sub is_utf8 {
+         my ($text) = @_;
+
+         my $ctext = pack q{C0a*}, $text;
+
+         return ($text ne $ctext) && ($ctext =~ m/^(
+          [\x09\x0A\x0D\x20-\x7E]
+          | [\xC2-\xDF][\x80-\xBF]
+          | \xE0[\xA0-\xBF][\x80-\xBF]
+          | [\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}
+          | \xED[\x80-\x9F][\x80-\xBF]
+          | \xF0[\x90-\xBF][\x80-\xBF]{2}
+          | [\xF1-\xF3][\x80-\xBF]{3}
+          | \xF4[\x80-\x8F][\x80-\xBF]{2}
+          )*$/xo);
+      }
+EOR
+
+   eval $is_utf8_redefinition;
+}
+
 sub escape {
+  # If we being called in an OO-context, discard the first argument.
   shift() if @_ > 1 and ( ref($_[0]) || (defined $_[1] && $_[0] eq $CGI::DefaultClass));
   my $toencode = shift;
   return undef unless defined($toencode);
-  utf8::encode($toencode) if ($] > 5.007 && utf8::is_utf8($toencode));
-    if ($EBCDIC) {
+  utf8::encode($toencode) if ($] >= 5.008 && utf8::is_utf8($toencode));
+    if (EBCDIC) {
       $toencode=~s/([^a-zA-Z0-9_.~-])/uc sprintf("%%%02x",$E2A[ord($1)])/eg;
     } else {
       $toencode=~s/([^a-zA-Z0-9_.~-])/uc sprintf("%%%02x",ord($1))/eg;
@@ -313,7 +342,8 @@ sub expire_calc {
     } else {
       return $time;
     }
-    return (time+$offset);
+    my $cur_time = time; 
+    return ($cur_time+$offset);
 }
 
 sub ebcdic2ascii {
@@ -346,7 +376,7 @@ no public subroutines
 
 =head1 AUTHOR INFORMATION
 
-Copyright 1995-1998, Lincoln D. Stein.  All rights reserved.  
+Copyright 1995-1998, Lincoln D. Stein.  All rights reserved.
 
 This library is free software; you can redistribute it and/or modify
 it under the same terms as Perl itself.
@@ -356,7 +386,7 @@ bug reports, please provide the version 
 Perl, the name and version of your Web server, and the name and
 version of the operating system you are using.  If the problem is even
 remotely browser dependent, please provide information about the
-affected browers as well.
+affected browsers as well.
 
 =head1 SEE ALSO
 
diff -urN perl-5.10.1/lib/CGI/t.old/apache.t perl-5.10.1/lib/CGI/t/apache.t
--- perl-5.10.1/lib/CGI/t.old/apache.t	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/apache.t	2011-01-05 19:13:45.000000000 +0100
@@ -1,11 +1,5 @@
 #!/usr/local/bin/perl -w
 
-use lib qw(t/lib);
-
-# Due to a bug in older versions of MakeMaker & Test::Harness, we must
-# ensure the blib's are in @INC, else we might use the core CGI.pm
-use lib qw(blib/lib blib/arch);
-
 use strict;
 use Test::More tests => 1;
 
diff -urN perl-5.10.1/lib/CGI/t.old/autoescape.t perl-5.10.1/lib/CGI/t/autoescape.t
--- perl-5.10.1/lib/CGI/t.old/autoescape.t	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/autoescape.t	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,199 @@
+#!perl
+
+use strict;
+use warnings;
+
+use Test::More tests => 18;
+
+use CGI qw/ autoEscape escapeHTML button textfield password_field textarea popup_menu scrolling_list checkbox_group optgroup checkbox radio_group submit image_button button /;
+
+is (button(-name => 'test<'), '<input type="button"  name="test&lt;" value="test&lt;" />', "autoEscape defaults to On");
+
+my $before = escapeHTML("test<");
+autoEscape(undef);
+my $after = escapeHTML("test<");
+
+
+is($before, "test&lt;", "reality check escapeHTML");
+
+is ($before, $after, "passing undef to autoEscape doesn't break escapeHTML"); 
+is (button(-name => 'test<'), '<input type="button"  name="test<" value="test<" />', "turning off autoescape actually works");
+autoEscape(1);
+is (button(-name => 'test<'), '<input type="button"  name="test&lt;" value="test&lt;" />', "autoescape turns back on");
+$before = escapeHTML("test<");
+autoEscape(0);
+$after = escapeHTML("test<");
+
+is ($before, $after, "passing 0 to autoEscape doesn't break escapeHTML"); 
+
+# RT #25485: Needs Tests: autoEscape() bypassed for Javascript handlers, except in button()
+autoEscape(undef);
+ 
+is(textfield(
+{
+default => 'text field',
+onclick => 'alert("===> text field")',
+},
+),
+qq{<input type="text" name="" value="text field" onclick="alert("===> text field")" />},
+'autoescape javascript turns off for textfield'
+);
+
+is(password_field(
+{
+default => 'password field',
+onclick => 'alert("===> password
+field")',
+},
+),
+qq{<input type="password" name="" value="password field" onclick="alert("===> password
+field")" />},
+'autoescape javascript turns off for password field'
+);
+
+is(textarea(
+{
+name => 'foo',
+default => 'text area',
+rows => 10,
+columns => 50,
+onclick => 'alert("===> text area")',
+},
+),
+qq{<textarea name="foo"  rows="10" cols="50" onclick="alert("===> text area")">text area</textarea>},
+'autoescape javascript turns off for textarea'
+);
+
+is(popup_menu(
+{
+name => 'menu_name',
+values => ['eenie','meenie','minie'],
+default => 'meenie',
+onclick => 'alert("===> popup menu")',
+}
+),
+qq{<select name="menu_name"  onclick="alert("===> popup menu")">
+<option value="eenie">eenie</option>
+<option selected="selected" value="meenie">meenie</option>
+<option value="minie">minie</option>
+</select>},
+'autoescape javascript turns off for popup_menu'
+);
+
+is(popup_menu(
+-name=>'menu_name',
+onclick => 'alert("===> menu group")',
+-values=>[
+qw/eenie meenie minie/,
+optgroup(
+-name=>'optgroup_name',
+onclick =>
+'alert("===> menu group option")',
+-values => ['moe','catch'],
+-attributes=>{'catch'=>{'class'=>'red'}}
+)
+],
+-labels=>{
+'eenie'=>'one',
+'meenie'=>'two',
+'minie'=>'three'
+},
+-default=>'meenie'
+),
+qq{<select name="menu_name"  onclick="alert("===> menu group")">
+<option value="eenie">one</option>
+<option selected="selected" value="meenie">two</option>
+<option value="minie">three</option>
+<optgroup label="optgroup_name" onclick="alert("===> menu group option")">
+<option value="moe">moe</option>
+<option class="red" value="catch">catch</option>
+</optgroup>
+</select>},
+'autoescape javascript turns off for popup_menu #2'
+);
+
+is(scrolling_list(
+-name=>'list_name',
+onclick => 'alert("===> scrolling
+list")',
+-values=>['eenie','meenie','minie','moe'],
+-default=>['eenie','moe'],
+-size=>5,
+-multiple=>'true',
+),
+qq{<select name="list_name"  size="5" multiple="multiple" onclick="alert("===> scrolling
+list")">
+<option selected="selected" value="eenie">eenie</option>
+<option value="meenie">meenie</option>
+<option value="minie">minie</option>
+<option selected="selected" value="moe">moe</option>
+</select>},
+'autoescape javascript turns off for scrolling list'
+);
+
+is(checkbox_group(
+-name=>'group_name',
+onclick => 'alert("===> checkbox group")',
+-values=>['eenie','meenie','minie','moe'],
+-default=>['eenie','moe'],
+-linebreak=>'true',
+),
+qq{<label><input type="checkbox" name="group_name" value="eenie" checked="checked" onclick="alert("===> checkbox group")" />eenie</label><br /> <label><input type="checkbox" name="group_name" value="meenie" onclick="alert("===> checkbox group")" />meenie</label><br /> <label><input type="checkbox" name="group_name" value="minie" onclick="alert("===> checkbox group")" />minie</label><br /> <label><input type="checkbox" name="group_name" value="moe" checked="checked" onclick="alert("===> checkbox group")" />moe</label><br />},
+'autoescape javascript turns off for checkbox group'
+);
+
+is(checkbox(
+-name=>'checkbox_name',
+onclick => 'alert("===> single checkbox")',
+onchange => 'alert("===> single checkbox
+changed")',
+-checked=>1,
+-value=>'ON',
+-label=>'CLICK ME'
+),
+qq{<label><input type="checkbox" name="checkbox_name" value="ON" checked="checked" onchange="alert("===> single checkbox
+changed")" onclick="alert("===> single checkbox")" />CLICK ME</label>},
+'autoescape javascript turns off for checkbox'
+);
+
+is(radio_group(
+{
+name=>'group_name',
+onclick => 'alert("===> radio group")',
+values=>['eenie','meenie','minie','moe'],
+rows=>2,
+columns=>2,
+}
+),
+qq{<table><tr><td><label><input type="radio" name="group_name" value="eenie" checked="checked" onclick="alert("===> radio group")" />eenie</label></td><td><label><input type="radio" name="group_name" value="minie" onclick="alert("===> radio group")" />minie</label></td></tr><tr><td><label><input type="radio" name="group_name" value="meenie" onclick="alert("===> radio group")" />meenie</label></td><td><label><input type="radio" name="group_name" value="moe" onclick="alert("===> radio group")" />moe</label></td></tr></table>},
+'autoescape javascript turns off for radio group'
+);
+
+is(submit(
+-name=>'button_name',
+onclick => 'alert("===> submit button")',
+-value=>'value'
+),
+qq{<input type="submit" name="button_name" value="value" onclick="alert("===> submit button")" />},
+'autoescape javascript turns off for submit'
+);
+
+is(image_button(
+-name=>'button_name',
+onclick => 'alert("===> image button")',
+-src=>'/source/URL',
+-align=>'MIDDLE'
+),
+qq{<input type="image" name="button_name" src="/source/URL" align="middle" onclick="alert("===> image button")" />},
+'autoescape javascript turns off for image_button'
+);
+
+is(button(
+{
+onclick => 'alert("===> Button")',
+title => 'Button',
+},
+),
+qq{<input type="button"  onclick="alert("===> Button")" title="Button" />},
+'autoescape javascript turns off for button'
+);
diff -urN perl-5.10.1/lib/CGI/t.old/can.t perl-5.10.1/lib/CGI/t/can.t
--- perl-5.10.1/lib/CGI/t.old/can.t	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/can.t	2011-01-05 19:13:45.000000000 +0100
@@ -1,12 +1,7 @@
 #!/usr/local/bin/perl -w
 
-# Due to a bug in older versions of MakeMaker & Test::Harness, we must
-# ensure the blib's are in @INC, else we might use the core CGI.pm
-
-use lib qw(blib/lib blib/arch);
-
 use Test::More tests => 2;
 
 BEGIN{ use_ok('CGI'); }
 
-can_ok('CGI', qw/cookie param/);
\ No newline at end of file
+can_ok('CGI', qw/cookie param/);
diff -urN perl-5.10.1/lib/CGI/t.old/carp.t perl-5.10.1/lib/CGI/t/carp.t
--- perl-5.10.1/lib/CGI/t.old/carp.t	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/carp.t	2011-01-05 19:13:45.000000000 +0100
@@ -1,17 +1,12 @@
 # -*- Mode: cperl; coding: utf-8; cperl-indent-level: 2 -*-
-#!/usr/local/bin/perl -w
+#!perl -w
 
 use strict;
-use lib qw(t/lib);
 
-# Due to a bug in older versions of MakeMaker & Test::Harness, we must
-# ensure the blib's are in @INC, else we might use the core CGI.pm
-use lib qw(blib/lib blib/arch);
-
-use Test::More tests => 41;
+use Test::More tests => 61;
 use IO::Handle;
 
-BEGIN { use_ok('CGI::Carp') };
+use CGI::Carp;
 
 #-----------------------------------------------------------------------------
 # Test id
@@ -121,12 +116,13 @@
 # Test that realwarn is called
 {
   local $^W = 0;
-  eval 'sub CGI::Carp::realdie {my $mess = shift; return $mess};';
-}
+  local *CGI::Carp::realdie = sub { my $mess = shift; return $mess };
 
-like(CGI::Carp::die('There is a problem'),
-     $stamp,
-     'CGI::Carp::die calls CORE::die, but adds stamp');
+    like(CGI::Carp::die('There is a problem'),
+        $stamp,
+        'CGI::Carp::die calls CORE::die, but adds stamp');
+
+}
 
 #-----------------------------------------------------------------------------
 # Test set_message
@@ -278,3 +274,125 @@
 ok( defined buffer('::STDOUT'),    'STDIN returns proper filehandle');
 ok( defined buffer(*main::STDOUT), 'STDIN returns proper filehandle');
 ok(!defined buffer("WIBBLE"),      '"WIBBLE" doesn\'t returns proper filehandle');
+
+# Calling die with code refs with no WRAP
+{
+    local $CGI::Carp::WRAP = 0;
+
+    eval { CGI::Carp::die( 'regular string' ) };
+    like $@ => qr/regular string/, 'die with string';
+
+    eval { CGI::Carp::die( [ 1..10 ] ) };
+    like $@ => qr/ARRAY\(0x[\da-f]+\)/, 'die with array ref';
+
+    eval { CGI::Carp::die( { a => 1 } ) };
+    like $@ => qr/HASH\(0x[\da-f]+\)/, 'die with hash ref';
+
+    eval { CGI::Carp::die( sub { 'Farewell' } ) };
+    like $@ => qr/CODE\(0x[\da-f]+\)/, 'die with code ref';
+
+    eval { CGI::Carp::die( My::Plain::Object->new ) };
+    isa_ok $@, 'My::Plain::Object';
+
+    eval { CGI::Carp::die( My::Plain::Object->new, ' and another argument' ) };
+    like $@ => qr/My::Plain::Object/,     'object is stringified';
+    like $@ => qr/and another argument/, 'second argument is present';
+
+    eval { CGI::Carp::die( My::Stringified::Object->new ) };
+    isa_ok $@, 'My::Stringified::Object';
+
+    eval { CGI::Carp::die( My::Stringified::Object->new, ' and another argument' ) };
+    like $@ => qr/stringified/,          'object is stringified';
+    like $@ => qr/and another argument/, 'second argument is present';
+
+    eval { CGI::Carp::die() };
+    like $@ => qr/Died at/, 'die with no argument';
+}
+
+# Calling die with code refs when WRAPped
+{
+    local $CGI::Carp::WRAP = 1;
+    local *CGI::Carp::realdie = sub { return @_ };
+    local *STDOUT;
+
+    tie *STDOUT, 'StoreStuff';
+
+    my %result;   # store results because stdout is kidnapped
+
+    CGI::Carp::die( 'regular string' );
+    $result{string} .= $_ while <STDOUT>;
+
+    CGI::Carp::die( [ 1..10 ] );
+    $result{array_ref} .= $_ while <STDOUT>;
+
+    CGI::Carp::die( { a => 1 } );
+    $result{hash_ref} .= $_ while <STDOUT>;
+
+    CGI::Carp::die( sub { 'Farewell' } );
+    $result{code_ref} .= $_ while <STDOUT>;
+
+    CGI::Carp::die( My::Plain::Object->new );
+    $result{plain_object} .= $_ while <STDOUT>;
+
+    CGI::Carp::die( My::Stringified::Object->new );
+    $result{string_object} .= $_ while <STDOUT>;
+
+    undef $@;
+    CGI::Carp::die();
+    $result{no_args} .= $_ while <STDOUT>;
+
+    $@ = "I think I caught a virus";
+    CGI::Carp::die();
+    $result{propagated} .= $_ while <STDOUT>;
+
+    untie *STDOUT;
+
+    like $result{string}    => qr/regular string/, 'regular string, wrapped';
+    like $result{array_ref} => qr/ARRAY\(\w+?\)/,  'array ref, wrapped';
+    like $result{hash_ref}  => qr/HASH\(\w+?\)/,   'hash ref, wrapped';
+    like $result{code_ref}  => qr/CODE\(\w+?\)/,   'code ref, wrapped';
+    like $result{plain_object} => qr/My::Plain::Object/,
+      'plain object, wrapped';
+    like $result{string_object} => qr/stringified/,
+      'stringified object, wrapped';
+    like $result{no_args} => qr/Died at/, 'no args, wrapped';
+
+    like $result{propagated} => qr/I think I caught a virus\t\.{3}propagated/, 
+        'propagating $@ if no argument';
+
+}
+
+{
+    package My::Plain::Object;
+
+    sub new {
+        return bless {}, shift;
+    }
+}
+
+{
+    package My::Stringified::Object;
+
+    use overload '""' => sub { 'stringified' };
+
+    sub new {
+        return bless {}, shift;
+    }
+}
+
+
+@result = ();
+tie *STDOUT, 'StoreStuff' or die "Can't tie STDOUT";
+ {
+ 	eval {
+ 		$CGI::Carp::TO_BROWSER = 0;
+ 		die 'Message ToBrowser = 0';
+	};
+ 	$result[0] = $@;
+ 	$result[1] .= $_ while (<STDOUT>);
+ }
+untie *STDOUT;
+
+ like $result[0] => qr/Message ToBrowser/, 'die message for ToBrowser = 0 is OK';
+ ok !$result[1], 'No output for ToBrowser = 0';
+
diff -urN perl-5.10.1/lib/CGI/t.old/charset.t perl-5.10.1/lib/CGI/t/charset.t
--- perl-5.10.1/lib/CGI/t.old/charset.t	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/charset.t	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,27 @@
+#!perl
+
+use strict;
+use warnings;
+
+use Test::More 'no_plan';
+
+use CGI;
+
+my $q = CGI->new;
+
+like( $q->header
+    , qr/charset=ISO-8859-1/, "charset ISO-8859-1 is set by default for default content-type");
+like( $q->header('application/json')
+    , qr/charset=ISO-8859-1/, "charset ISO-8859-1 is set by default for application/json content-type");
+
+{
+    $q->charset('UTF-8');
+    my $out = $q->header('text/plain');
+    like($out, qr{Content-Type: text/plain; charset=UTF-8}, "setting charset alters header of text/plain");
+}
+{
+    $q->charset('UTF-8');
+    my $out = $q->header('application/json');
+    like($out, qr{Content-Type: application/json; charset=UTF-8}, "setting charset alters header of application/json");
+}
+
diff -urN perl-5.10.1/lib/CGI/t.old/checkbox_group.t perl-5.10.1/lib/CGI/t/checkbox_group.t
--- perl-5.10.1/lib/CGI/t.old/checkbox_group.t	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/checkbox_group.t	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,21 @@
+#!/usr/local/bin/perl -w
+
+use Test::More tests => 3;
+
+BEGIN { use_ok('CGI'); };
+use CGI (':standard','-no_debug','-no_xhtml');
+
+# no_xhtml test on checkbox_group()
+is(checkbox_group(-name       => 'game',
+		  '-values'   => [qw/checkers chess cribbage/],
+                  '-defaults' => ['cribbage']),
+   qq(<input type="checkbox" name="game" value="checkers" >checkers <input type="checkbox" name="game" value="chess" >chess <input type="checkbox" name="game" value="cribbage" checked >cribbage),
+   'checkbox_group()');
+
+#  xhtml test on checkbox_group()
+$CGI::XHTML = 1;
+is(checkbox_group(-name       => 'game',
+		  '-values'   => [qw/checkers chess cribbage/],
+                  '-defaults' => ['cribbage']),
+   qq(<label><input type="checkbox" name="game" value="checkers" />checkers</label> <label><input type="checkbox" name="game" value="chess" />chess</label> <label><input type="checkbox" name="game" value="cribbage" checked="checked" />cribbage</label>),
+   'checkbox_group()');
diff -urN perl-5.10.1/lib/CGI/t.old/cookie.t perl-5.10.1/lib/CGI/t/cookie.t
--- perl-5.10.1/lib/CGI/t.old/cookie.t	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/cookie.t	2011-01-05 19:14:15.000000000 +0100
@@ -1,28 +1,29 @@
-#!/usr/local/bin/perl -w
+#!perl -w
 
-use lib qw(t/lib);
 use strict;
 
-# Due to a bug in older versions of MakeMaker & Test::Harness, we must
-# ensure the blib's are in @INC, else we might use the core CGI.pm
-use lib qw(blib/lib blib/arch);
+# to have a consistent baseline, we nail the current time
+# to 100 seconds after the epoch
+BEGIN {
+    *CORE::GLOBAL::time = sub { 100 };
+}
 
-use Test::More tests => 96;
+use Test::More 'no_plan';
 use CGI::Util qw(escape unescape);
 use POSIX qw(strftime);
+use CGI::Cookie;
 
 #-----------------------------------------------------------------------------
 # make sure module loaded
 #-----------------------------------------------------------------------------
 
-BEGIN {use_ok('CGI::Cookie');}
-
 my @test_cookie = (
-		   'foo=123; bar=qwerty; baz=wibble; qux=a1',
-		   'foo=123; bar=qwerty; baz=wibble;',
-		   'foo=vixen; bar=cow; baz=bitch; qux=politician',
-		   'foo=a%20phrase; bar=yes%2C%20a%20phrase; baz=%5Ewibble; qux=%27',
-		   );
+           # including leading and trailing whitespace in first cookie
+           ' foo=123 ; bar=qwerty; baz=wibble; qux=a1',
+           'foo=123; bar=qwerty; baz=wibble;',
+           'foo=vixen; bar=cow; baz=bitch; qux=politician',
+           'foo=a%20phrase; bar=yes%2C%20a%20phrase; baz=%5Ewibble; qux=%27',
+           );
 
 #-----------------------------------------------------------------------------
 # Test parse
@@ -30,23 +31,29 @@
 
 {
   my $result = CGI::Cookie->parse($test_cookie[0]);
-
   is(ref($result), 'HASH', "Hash ref returned in scalar context");
 
   my @result = CGI::Cookie->parse($test_cookie[0]);
-
   is(@result, 8, "returns correct number of fields");
 
   @result = CGI::Cookie->parse($test_cookie[1]);
-
   is(@result, 6, "returns correct number of fields");
 
   my %result = CGI::Cookie->parse($test_cookie[0]);
-
   is($result{foo}->value, '123', "cookie foo is correct");
   is($result{bar}->value, 'qwerty', "cookie bar is correct");
   is($result{baz}->value, 'wibble', "cookie baz is correct");
   is($result{qux}->value, 'a1', "cookie qux is correct");
+
+  my @array   = CGI::Cookie->parse('');
+  my $scalar  = CGI::Cookie->parse('');
+  is_deeply(\@array, [], " parse('') returns an empty array   in list context   (undocumented)");
+  is_deeply($scalar, {}, " parse('') returns an empty hashref in scalar context (undocumented)");
+
+  my @array   = CGI::Cookie->parse(undef);
+  my $scalar  = CGI::Cookie->parse(undef);
+  is_deeply(\@array, [], " parse(undef) returns an empty array   in list context   (undocumented)");
+  is_deeply($scalar, {}, " parse(undef) returns an empty hashref in scalar context (undocumented)");
 }
 
 #-----------------------------------------------------------------------------
@@ -131,6 +138,10 @@
   is($result{bar}, 'yes%2C%20a%20phrase', "cookie bar is correct");
   is($result{baz}, '%5Ewibble', "cookie baz is correct");
   is($result{qux}, '%27', "cookie qux is correct");
+
+  $ENV{COOKIE} = '$Version=1; foo; $Path="/test"';
+  %result = CGI::Cookie->raw_fetch();
+  is($result{foo}, '', 'no value translates to empty string');
 }
 
 #-----------------------------------------------------------------------------
@@ -140,12 +151,13 @@
 {
   # Try new with full information provided
   my $c = CGI::Cookie->new(-name    => 'foo',
-			   -value   => 'bar',
-			   -expires => '+3M',
-			   -domain  => '.capricorn.com',
-			   -path    => '/cgi-bin/database',
-			   -secure  => 1
-			  );
+               -value   => 'bar',
+               -expires => '+3M',
+               -domain  => '.capricorn.com',
+               -path    => '/cgi-bin/database',
+               -secure  => 1,
+               -httponly=> 1
+              );
   is(ref($c), 'CGI::Cookie', 'new returns objects of correct type');
   is($c->name   , 'foo',               'name is correct');
   is($c->value  , 'bar',               'value is correct');
@@ -153,11 +165,12 @@
   is($c->domain , '.capricorn.com',    'domain is correct');
   is($c->path   , '/cgi-bin/database', 'path is correct');
   ok($c->secure , 'secure attribute is set');
+  ok( $c->httponly, 'httponly attribute is set' );
 
   # now try it with the only two manditory values (should also set the default path)
   $c = CGI::Cookie->new(-name    =>  'baz',
-			-value   =>  'qux',
-		       );
+            -value   =>  'qux',
+               );
   is(ref($c), 'CGI::Cookie', 'new returns objects of correct type');
   is($c->name   , 'baz', 'name is correct');
   is($c->value  , 'qux', 'value is correct');
@@ -165,6 +178,7 @@
   ok(!defined $c->domain ,       'domain attributeis not set');
   is($c->path, '/',      'path atribute is set to default');
   ok(!defined $c->secure ,       'secure attribute is set');
+  ok( !defined $c->httponly, 'httponly attribute is not set' );
 
 # I'm really not happy about the restults of this section.  You pass
 # the new method invalid arguments and it just merilly creates a
@@ -191,12 +205,13 @@
 
 {
   my $c = CGI::Cookie->new(-name    => 'Jam',
-			   -value   => 'Hamster',
-			   -expires => '+3M',
-			   -domain  => '.pie-shop.com',
-			   -path    => '/',
-			   -secure  => 1
-			  );
+               -value   => 'Hamster',
+               -expires => '+3M',
+               -domain  => '.pie-shop.com',
+               -path    => '/',
+               -secure  => 1,
+               -httponly=> 1
+              );
 
   my $name = $c->name;
   like($c->as_string, "/$name/", "Stringified cookie contains name");
@@ -215,9 +230,12 @@
 
   like($c->as_string, '/secure/', "Stringified cookie contains secure");
 
+  like( $c->as_string, '/HttpOnly/',
+    "Stringified cookie contains HttpOnly" );
+
   $c = CGI::Cookie->new(-name    =>  'Hamster-Jam',
-			-value   =>  'Tulip',
-		       );
+            -value   =>  'Tulip',
+               );
 
   $name = $c->name;
   like($c->as_string, "/$name/", "Stringified cookie contains name");
@@ -233,6 +251,9 @@
   like($c->as_string, "/$path/", "Stringified cookie contains path");
 
   ok($c->as_string !~ /secure/, "Stringified cookie does not contain secure");
+
+  ok( $c->as_string !~ /HttpOnly/,
+    "Stringified cookie does not contain HttpOnly" );
 }
 
 #-----------------------------------------------------------------------------
@@ -241,38 +262,38 @@
 
 {
   my $c1 = CGI::Cookie->new(-name    => 'Jam',
-			    -value   => 'Hamster',
-			    -expires => '+3M',
-			    -domain  => '.pie-shop.com',
-			    -path    => '/',
-			    -secure  => 1
-			   );
+                -value   => 'Hamster',
+                -expires => '+3M',
+                -domain  => '.pie-shop.com',
+                -path    => '/',
+                -secure  => 1
+               );
 
   # have to use $c1->expires because the time will occasionally be
   # different between the two creates causing spurious failures.
   my $c2 = CGI::Cookie->new(-name    => 'Jam',
-			    -value   => 'Hamster',
-			    -expires => $c1->expires,
-			    -domain  => '.pie-shop.com',
-			    -path    => '/',
-			    -secure  => 1
-			   );
+                -value   => 'Hamster',
+                -expires => $c1->expires,
+                -domain  => '.pie-shop.com',
+                -path    => '/',
+                -secure  => 1
+               );
 
   # This looks titally whacked, but it does the -1, 0, 1 comparison
   # thing so 0 means they match
   is($c1->compare("$c1"), 0, "Cookies are identical");
-  is($c1->compare("$c2"), 0, "Cookies are identical");
+  is( "$c1", "$c2", "Cookies are identical");
 
   $c1 = CGI::Cookie->new(-name   => 'Jam',
-			 -value  => 'Hamster',
-			 -domain => '.foo.bar.com'
-			);
+             -value  => 'Hamster',
+             -domain => '.foo.bar.com'
+            );
 
   # have to use $c1->expires because the time will occasionally be
   # different between the two creates causing spurious failures.
   $c2 = CGI::Cookie->new(-name    =>  'Jam',
-			 -value   =>  'Hamster',
-			);
+             -value   =>  'Hamster',
+            );
 
   # This looks titally whacked, but it does the -1, 0, 1 comparison
   # thing so 0 (i.e. false) means they match
@@ -289,12 +310,12 @@
 
 {
   my $c = CGI::Cookie->new(-name    => 'Jam',
-			   -value   => 'Hamster',
-			   -expires => '+3M',
-			   -domain  => '.pie-shop.com',
-			   -path    => '/',
-			   -secure  => 1
-			   );
+               -value   => 'Hamster',
+               -expires => '+3M',
+               -domain  => '.pie-shop.com',
+               -path    => '/',
+               -secure  => 1
+               );
 
   is($c->name,          'Jam',   'name is correct');
   is($c->name('Clash'), 'Clash', 'name is set correctly');
@@ -326,6 +347,36 @@
   ok(!$c->secure,    'secure attribute is cleared');
 }
 
+#----------------------------------------------------------------------------
+# Max-age
+#----------------------------------------------------------------------------
+
+MAX_AGE: {
+    my $cookie = CGI::Cookie->new( -name=>'a', value=>'b', '-expires' => 'now',);
+    is $cookie->expires, 'Thu, 01-Jan-1970 00:01:40 GMT';
+    is $cookie->max_age => undef, 'max-age is undefined when setting expires';
+
+    my $cookie = CGI::Cookie->new( -name=>'a', 'value'=>'b' );
+    $cookie->max_age( '+4d' );
+
+    is $cookie->expires, undef, 'expires is undef when setting max_age';
+    is $cookie->max_age => 4*24*60*60, 'setting via max-age';
+
+    $cookie->max_age( '113' );
+    is $cookie->max_age => 13, 'max_age(num) as delta';
+}
+
+
+#----------------------------------------------------------------------------
+# bake
+#----------------------------------------------------------------------------
+
+BAKE: {
+    my $cookie = CGI::Cookie->new( -name=>'a', value=>'b', '-expires' => 'now',);
+    eval { $cookie->bake };
+    is($@,'', "calling bake() without mod_perl should survive"); 
+}
+
 #-----------------------------------------------------------------------------
 # Apache2?::Cookie compatibility.
 #-----------------------------------------------------------------------------
diff -urN perl-5.10.1/lib/CGI/t.old/Dump.t perl-5.10.1/lib/CGI/t/Dump.t
--- perl-5.10.1/lib/CGI/t.old/Dump.t	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/Dump.t	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,5 @@
+use Test::More 'no_plan';
+use CGI;
+my $cgi = CGI->new('<a>=<b>');
+like($cgi->Dump, qr/\Q&lt;a&gt;/, 'param names are HTML escaped by Dump()');
+like($cgi->Dump, qr/\Q&lt;b&gt;/, 'param values are HTML escaped by Dump()');
diff -urN perl-5.10.1/lib/CGI/t.old/end_form.t perl-5.10.1/lib/CGI/t/end_form.t
--- perl-5.10.1/lib/CGI/t.old/end_form.t	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/end_form.t	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,13 @@
+
+use strict;
+use warnings;
+
+use Test::More tests => 3;
+
+BEGIN { use_ok 'CGI', qw/ -compile :form / };
+
+is end_form() => '</form>', 'end_form()';
+is endform() => '</form>', 'endform()';
+
+
+
diff -urN perl-5.10.1/lib/CGI/t.old/fast.t perl-5.10.1/lib/CGI/t/fast.t
--- perl-5.10.1/lib/CGI/t.old/fast.t	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/fast.t	2011-01-05 19:13:45.000000000 +0100
@@ -1,10 +1,4 @@
-#!./perl -w
-
-use lib qw(t/lib);
-
-# Due to a bug in older versions of MakeMaker & Test::Harness, we must
-# ensure the blib's are in @INC, else we might use the core CGI.pm
-use lib qw(blib/lib blib/arch);
+#!perl -w
 
 my $fcgi;
 BEGIN {
@@ -13,25 +7,33 @@
 	$fcgi = $@ ? 0 : 1;
 }
 
-use Test::More tests => 7;
+use Test::More tests => 10;
 
 # Shut up "used only once" warnings.
 () = $CGI::Q;
 () = $CGI::Fast::Ext_Request;
 
 SKIP: {
-	skip( 'FCGI not installed, cannot continue', 7 ) unless $fcgi;
+	skip( 'FCGI not installed, cannot continue', 10 ) unless $fcgi;
 
-	use_ok( CGI::Fast );
+	require CGI::Fast;
 	ok( my $q = CGI::Fast->new(), 'created new CGI::Fast object' );
 	is( $q, $CGI::Q, 'checking to see if the object was stored properly' );
 	is( $q->param(), (), 'no params' );
 
-	ok( $q = CGI::Fast->new({ foo => 'bar' }), 'creating obect with params' );
+	ok( $q = CGI::Fast->new({ foo => 'bar' }), 'creating object with params' );
 	is( $q->param('foo'), 'bar', 'checking passed param' );
 
 	# if this is false, the package var will be empty
 	$ENV{FCGI_SOCKET_PATH} = 0;
-	is( $CGI::Fast::Ext_Request, '', 'checking no active request' );
+	is( $CGI::Fast::Ext_Request, undef, 'checking no active request' );
 
-}
+    is($CGI::PRIVATE_TEMPFILES,0, "reality check default value for CGI::PRIVATE_TEMPFILES");
+	import CGI::Fast '-private_tempfiles';
+    CGI::Fast->new;
+    is($CGI::PRIVATE_TEMPFILES,1, "pragma in subclass set package variable in parent class. ");
+    $q = CGI::Fast->new({ a => 1 });
+    ok($q, "reality check: something was returned from CGI::Fast->new besides undef");
+    is($CGI::PRIVATE_TEMPFILES,1, "package variable in parent class persists through multiple calls to CGI::Fast->new ");
+
+};
diff -urN perl-5.10.1/lib/CGI/t.old/form.t perl-5.10.1/lib/CGI/t/form.t
--- perl-5.10.1/lib/CGI/t.old/form.t	2009-06-10 18:53:46.000000000 +0200
+++ perl-5.10.1/lib/CGI/t/form.t	2011-01-05 19:13:45.000000000 +0100
@@ -1,12 +1,10 @@
-#!/usr/local/bin/perl -w
+#!perl -w
 
-# Due to a bug in older versions of MakeMaker & Test::Harness, we must
-# ensure the blib's are in @INC, else we might use the core CGI.pm
-use lib qw(. ./blib/lib ./blib/arch);
+# Form-related tests for CGI.pm
+# If you are adding or updated tests, please put tests for each methods in
+# their own file, rather than growing this file any larger. 
 
-use Test::More tests => 19;
-
-BEGIN { use_ok('CGI'); };
+use Test::More 'no_plan';
 use CGI (':standard','-no_debug','-tabindex');
 
 my $CRLF = "\015\012";
@@ -134,3 +132,114 @@
    qq(<label><input type="checkbox" name="game" value="checkers" checked="checked" tabindex="23" disabled='1'/><span style="color:gray">checkers</span></label> <label><input type="checkbox" name="game" value="chess" checked="checked" tabindex="24" />chess</label> <label><input type="checkbox" name="game" value="cribbage" tabindex="25" />cribbage</label>),
    'checkbox_group()');
 
+my $optgroup = optgroup(-name=>'optgroup_name',
+                        -Values => ['moe','catch'],
+                        -attributes=>{'catch'=>{'class'=>'red'}});
+
+is($optgroup, 
+    qq(<optgroup label="optgroup_name">
+<option value="moe">moe</option>
+<option class="red" value="catch">catch</option>
+</optgroup>),
+    'optgroup()');
+
+is(popup_menu(-name=>'menu_name',
+              -Values=>[qw/eenie meenie minie/, $optgroup],
+              -labels=>{'eenie'=>'one',
+                        'meenie'=>'two',
+                        'minie'=>'three'},
+              -default=>'meenie'),
+    qq(<select name="menu_name" tabindex="26" >
+<option value="eenie">one</option>
+<option selected="selected" value="meenie">two</option>
+<option value="minie">three</option>
+<optgroup label="optgroup_name">
+<option value="moe">moe</option>
+<option class="red" value="catch">catch</option>
+</optgroup>
+</select>),
+    'popup_menu() + optgroup()');
+
+is(scrolling_list(-name=>'menu_name',
+              -Values=>[qw/eenie meenie minie/, $optgroup],
+              -labels=>{'eenie'=>'one',
+                        'meenie'=>'two',
+                        'minie'=>'three'},
+              -default=>'meenie'),
+    qq(<select name="menu_name" tabindex="27"  size="4">
+<option value="eenie">one</option>
+<option selected="selected" value="meenie">two</option>
+<option value="minie">three</option>
+<optgroup label="optgroup_name">
+<option value="moe">moe</option>
+<option class="red" value="catch">catch</option>
+</optgroup>
+</select>),
+    'scrolling_list() + optgroup()');
+
+# ---------- START 22046 ----------
+# The following tests were added for
+# https://rt.cpan.org/Public/Bug/Display.html?id=22046
+#     SHCOREY at cpan.org
+# Saved whether working with XHTML because need to test both
+# with it and without.
+my $saved_XHTML = $CGI::XHTML;
+
+# set XHTML
+$CGI::XHTML = 1;
+
+is(start_form("GET","/foobar"),
+    qq{<form method="get" action="/foobar" enctype="multipart/form-data">
+},
+    'start_form() + XHTML');
+
+is(start_form("GET", "/foobar",&CGI::URL_ENCODED),
+    qq{<form method="get" action="/foobar" enctype="application/x-www-form-urlencoded">
+},
+    'start_form() + XHTML + URL_ENCODED');
+
+is(start_form("GET", "/foobar",&CGI::MULTIPART),
+    qq{<form method="get" action="/foobar" enctype="multipart/form-data">
+},
+    'start_form() + XHTML + MULTIPART');
+
+is(start_multipart_form("GET", "/foobar"),
+    qq{<form method="get" action="/foobar" enctype="multipart/form-data">
+},
+    'start_multipart_form() + XHTML');
+
+is(start_multipart_form("GET", "/foobar","name=\"foobar\""),
+    qq{<form method="get" action="/foobar" enctype="multipart/form-data" name="foobar">
+},
+    'start_multipart_form() + XHTML + additional args');
+
+# set no XHTML
+$CGI::XHTML = 0;
+
+is(start_form("GET","/foobar"),
+    qq{<form method="get" action="/foobar" enctype="application/x-www-form-urlencoded">
+},
+    'start_form() + NO_XHTML');
+
+is(start_form("GET", "/foobar",&CGI::URL_ENCODED),
+    qq{<form method="get" action="/foobar" enctype="application/x-www-form-urlencoded">
+},
+    'start_form() + NO_XHTML + URL_ENCODED');
+
+is(start_form("GET", "/foobar",&CGI::MULTIPART),
+    qq{<form method="get" action="/foobar" enctype="multipart/form-data">
+},
+    'start_form() + NO_XHTML + MULTIPART');
+
+is(start_multipart_form("GET", "/foobar"),
+    qq{<form method="get" action="/foobar" enctype="multipart/form-data">
+},
+    'start_multipart_form() + NO_XHTML');
+
+is(start_multipart_form("GET", "/foobar","name=\"foobar\""),
+    qq{<form method="get" action="/foobar" enctype="multipart/form-data" name="foobar">
+},
+    'start_multipart_form() + NO_XHTML + additional args');
+
+# restoring value
+$CGI::XHTML = $saved_XHTML;
diff -urN perl-5.10.1/lib/CGI/t.old/function.t perl-5.10.1/lib/CGI/t/function.t
--- perl-5.10.1/lib/CGI/t.old/function.t	2009-06-10 18:53:46.000000000 +0200
+++ perl-5.10.1/lib/CGI/t/function.t	2011-01-05 19:13:45.000000000 +0100
@@ -1,11 +1,5 @@
 #!/usr/local/bin/perl -w
 
-use lib qw(t/lib);
-
-# Test ability to retrieve HTTP request info
-######################### We start with some black magic to print on failure.
-use lib '.','..','../blib/lib','../blib/arch';
-
 BEGIN {$| = 1; print "1..32\n"; }
 END {print "not ok 1\n" unless $loaded;}
 use Config;
@@ -38,11 +32,6 @@
 
 if (ord("\t") != 9) { $CRLF = "\r\n"; }
 
-# Web servers on EBCDIC hosts are typically set up to do an EBCDIC -> ASCII
-# translation hence CRLF is used as \r\n within CGI.pm on such machines.
-
-if (ord("\t") != 9) { $CRLF = "\r\n"; }
- 
 # Set up a CGI environment
 $ENV{REQUEST_METHOD}='GET';
 $ENV{QUERY_STRING}  ='game=chess&game=checkers&weather=dull';
diff -urN perl-5.10.1/lib/CGI/t.old/gen-tests/gen-start-end-tags.pl perl-5.10.1/lib/CGI/t/gen-tests/gen-start-end-tags.pl
--- perl-5.10.1/lib/CGI/t.old/gen-tests/gen-start-end-tags.pl	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/gen-tests/gen-start-end-tags.pl	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,75 @@
+#!/usr/bin/perl -w
+
+use strict;
+
+my @tags = 
+    (
+        "h1","h2","h3","h4","h5","h6",
+        "table","ul","li","ol","td",
+        "b","i","u","div",
+    );
+
+my $the_tag;
+my $tests_body = "";
+my $num_tests = 0;
+foreach $the_tag (@tags)
+{
+    my $start_or_end;
+    foreach $start_or_end (qw(start end))
+    {
+        my $slash = ($start_or_end eq "start") ? "" : "/";
+        $tests_body .= "is(${start_or_end}_${the_tag}(), \"<${slash}${the_tag}>\", \"${start_or_end}_${the_tag}\"); # TEST\n";
+        $num_tests++;
+        if ($start_or_end eq "start")
+        {
+            $tests_body .= "is(${start_or_end}_${the_tag}({class => 'hello'}), \"<${slash}${the_tag} class=\\\"hello\\\">\", \"${start_or_end}_${the_tag} with param\"); # TEST\n";
+            $num_tests++;
+        }
+    }
+    $tests_body .= "\n";
+}
+
+my $header1 = <<"EOF";
+#!/usr/local/bin/perl -w
+
+use lib qw(t/lib);
+use strict;
+
+# Due to a bug in older versions of MakeMaker & Test::Harness, we must
+# ensure the blib's are in \@INC, else we might use the core CGI.pm
+use lib qw(blib/lib blib/arch);
+EOF
+;
+
+my $header2 = "use Test::More tests => $num_tests;\n\n";
+
+my $header3;
+
+sub write_file
+{
+    my %args = (@_);
+    local(*O);
+    open O, ">t/start_end_" . $args{'filename'} . ".t\n";
+    my $content = $header1 . $header2 .
+        "use CGI qw(:standard " .
+            join(" ", @{$args{'use_params'}}) . ");\n\n" .
+        $tests_body;
+    print O $content;
+    close(O);
+}
+
+write_file(
+    "filename" => "asterisk",
+    "use_params" => [ map {"\*$_" } @tags ],
+);
+
+write_file(
+    "filename" => "start",
+    "use_params" => [ map {"start_$_"} @tags],
+);
+
+write_file(
+    "filename" => "end",
+    "use_params" => [ map {"end_$_"} @tags],
+);
+
diff -urN perl-5.10.1/lib/CGI/t.old/headers.t perl-5.10.1/lib/CGI/t/headers.t
--- perl-5.10.1/lib/CGI/t.old/headers.t	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/headers.t	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,47 @@
+
+# Test that header generation is spec compliant.
+# References:
+#   http://www.w3.org/Protocols/rfc2616/rfc2616.html
+#   http://www.w3.org/Protocols/rfc822/3_Lexical.html
+
+use strict;
+use warnings;
+
+use Test::More 'no_plan';
+
+use CGI;
+
+my $cgi = CGI->new;
+
+like $cgi->header( -type => "text/html" ),
+    qr#Type: text/html#, 'known header, basic case: type => "text/html"';
+
+eval { $cgi->header( -type => "text/html".$CGI::CRLF."evil: stuff" ) };
+like($@,qr/contains a newline/,'invalid header blows up');
+
+like $cgi->header( -type => "text/html".$CGI::CRLF." evil: stuff " ),
+    qr#Content-Type: text/html evil: stuff#, 'known header, with leading and trailing whitespace on the continuation line';
+
+eval { $cgi->header( -foobar => "text/html".$CGI::CRLF."evil: stuff" ) };
+like($@,qr/contains a newline/,'unknown header with CRLF embedded blows up');
+
+eval { $cgi->header( -foobar => $CGI::CRLF."Content-type: evil/header" ) };
+like($@,qr/contains a newline/, 'unknown header with leading newlines blows up');
+
+eval { $cgi->redirect( -type => "text/html".$CGI::CRLF."evil: stuff" ) };
+like($@,qr/contains a newline/,'redirect with known header with CRLF embedded blows up');
+
+eval { $cgi->redirect( -foobar => "text/html".$CGI::CRLF."evil: stuff" ) };
+like($@,qr/contains a newline/,'redirect with unknown header with CRLF embedded blows up');
+
+eval { $cgi->redirect( $CGI::CRLF.$CGI::CRLF."Content-Type: text/html") };
+like($@,qr/contains a newline/,'redirect with leading newlines blows up');
+
+{
+    my $cgi = CGI->new('t=bogus%0A%0A<html>');
+    my $out;
+    eval { $out = $cgi->redirect( $cgi->param('t') ) };
+    like($@,qr/contains a newline/, "redirect does not allow double-newline injection");
+}
+
+
diff -urN perl-5.10.1/lib/CGI/t.old/hidden.t perl-5.10.1/lib/CGI/t/hidden.t
--- perl-5.10.1/lib/CGI/t.old/hidden.t	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/hidden.t	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,38 @@
+#!perl -w
+
+use Test::More 'no_plan';
+use CGI;
+
+my $q = CGI->new;
+
+is( $q->hidden( 'hidden_name', 'foo' ),
+    qq(<input type="hidden" name="hidden_name" value="foo"  />),
+    'hidden() with single default value, positional');
+
+is( $q->hidden( -name => 'hidden_name', -default =>'foo' ),
+    qq(<input type="hidden" name="hidden_name" value="foo"  />),
+    'hidden() with single default value, named');
+
+is( $q->hidden( 'hidden_name', qw(foo bar baz fie) ),
+    qq(<input type="hidden" name="hidden_name" value="foo"  /><input type="hidden" name="hidden_name" value="bar"  /><input type="hidden" name="hidden_name" value="baz"  /><input type="hidden" name="hidden_name" value="fie"  />),
+    'hidden() with default array, positional');
+
+is( $q->hidden( -name=>'hidden_name',
+            -Values =>[qw/foo bar baz fie/],
+            -Title => "hidden_field"),
+     qq(<input type="hidden" name="hidden_name" value="foo" title="hidden_field" /><input type="hidden" name="hidden_name" value="bar" title="hidden_field" /><input type="hidden" name="hidden_name" value="baz" title="hidden_field" /><input type="hidden" name="hidden_name" value="fie" title="hidden_field" />),
+    'hidden() default array, named as "Values"');
+
+is( $q->hidden( -name=>'hidden_name',
+            -default =>[qw/foo bar baz fie/],
+            -Title => "hidden_field"),
+     qq(<input type="hidden" name="hidden_name" value="foo" title="hidden_field" /><input type="hidden" name="hidden_name" value="bar" title="hidden_field" /><input type="hidden" name="hidden_name" value="baz" title="hidden_field" /><input type="hidden" name="hidden_name" value="fie" title="hidden_field" />),
+    'hidden() default array, named as "default"');
+
+is( $q->hidden( -name=>'hidden_name',
+            '-value' =>[qw/foo bar baz fie/],
+            -Title => "hidden_field"),
+     qq(<input type="hidden" name="hidden_name" value="foo" title="hidden_field" /><input type="hidden" name="hidden_name" value="bar" title="hidden_field" /><input type="hidden" name="hidden_name" value="baz" title="hidden_field" /><input type="hidden" name="hidden_name" value="fie" title="hidden_field" />),
+    'hidden() default array, named as "value"');
+
+
diff -urN perl-5.10.1/lib/CGI/t.old/html.t perl-5.10.1/lib/CGI/t/html.t
--- perl-5.10.1/lib/CGI/t.old/html.t	2009-06-10 18:53:46.000000000 +0200
+++ perl-5.10.1/lib/CGI/t/html.t	2011-01-05 19:13:45.000000000 +0100
@@ -1,59 +1,82 @@
 #!/usr/local/bin/perl -w
 
-# Test ability to retrieve HTTP request info
-######################### We start with some black magic to print on failure.
-use lib '../blib/lib','../blib/arch';
+use Test::More tests => 33;
 
-END {print "not ok 1\n" unless $loaded;}
-use CGI (':standard','-no_debug','*h3','start_table');
+END { ok $loaded; }
+use CGI ( ':standard', '-no_debug', '*h3', 'start_table' );
 $loaded = 1;
-print "ok 1\n";
+ok 1;
 
 BEGIN {
-   $| = 1; print "1..28\n";
-  if( $] > 5.006 ) {
-    # no utf8
-    require utf8; # we contain Latin-1
-    utf8->unimport;
-  }
+    $| = 1;
+    if ( $] > 5.006 ) {
+
+        # no utf8
+        require utf8;    # we contain Latin-1
+        utf8->unimport;
+    }
 }
 
 ######################### End of black magic.
 
 my $CRLF = "\015\012";
-if ($^O eq 'VMS') { 
-  $CRLF = "\n";  # via web server carriage is inserted automatically
+if ( $^O eq 'VMS' ) {
+    $CRLF = "\n";        # via web server carriage is inserted automatically
 }
-if (ord("\t") != 9) { # EBCDIC?
-  $CRLF = "\r\n";
+if ( ord("\t") != 9 ) {    # EBCDIC?
+    $CRLF = "\r\n";
 }
 
-
 # util
 sub test {
-    local($^W) = 0;
-    my($num, $true,$msg) = @_;
-    print($true ? "ok $num\n" : "not ok $num $msg\n");
+    local ($^W) = 0;
+    my ( undef, $true, $msg ) = @_;
+    ok $true => $msg;
 }
 
 # all the automatic tags
-test(2,h1() eq '<h1 />',"single tag");
-test(3,h1('fred') eq '<h1>fred</h1>',"open/close tag");
-test(4,h1('fred','agnes','maura') eq '<h1>fred agnes maura</h1>',"open/close tag multiple");
-test(5,h1({-align=>'CENTER'},'fred') eq '<h1 align="CENTER">fred</h1>',"open/close tag with attribute");
-test(6,h1({-align=>undef},'fred') eq '<h1 align>fred</h1>',"open/close tag with orphan attribute");
-test(7,h1({-align=>'CENTER'},['fred','agnes']) eq 
-     '<h1 align="CENTER">fred</h1> <h1 align="CENTER">agnes</h1>',
-     "distributive tag with attribute");
+is h1(), '<h1 />', "single tag";
+
+is h1('fred'), '<h1>fred</h1>', "open/close tag";
+
+is h1( 'fred', 'agnes', 'maura' ), '<h1>fred agnes maura</h1>',
+  "open/close tag multiple";
+
+is h1( { -align => 'CENTER' }, 'fred' ), '<h1 align="CENTER">fred</h1>',
+  "open/close tag with attribute";
+
+is h1( { -align => undef }, 'fred' ), '<h1 align>fred</h1>',
+  "open/close tag with orphan attribute";
+
+is h1( { -align => 'CENTER' }, [ 'fred', 'agnes' ] ),
+  '<h1 align="CENTER">fred</h1> <h1 align="CENTER">agnes</h1>',
+  "distributive tag with attribute";
+
 {
-    local($") = '-'; 
-    test(8,h1('fred','agnes','maura') eq '<h1>fred-agnes-maura</h1>',"open/close tag \$\" interpolation");
+    local $" = '-';
+
+    is h1( 'fred', 'agnes', 'maura' ), '<h1>fred-agnes-maura</h1>',
+      "open/close tag \$\" interpolation";
+
 }
-test(9,header() eq "Content-Type: text/html; charset=ISO-8859-1${CRLF}${CRLF}","header()");
-test(10,header(-type=>'image/gif') eq "Content-Type: image/gif${CRLF}${CRLF}","header()");
-test(11,header(-type=>'image/gif',-status=>'500 Sucks') eq "Status: 500 Sucks${CRLF}Content-Type: image/gif${CRLF}${CRLF}","header()");
-test(12,header(-nph=>1) =~ m!HTTP/1.0 200 OK${CRLF}Server: cmdline${CRLF}Date:.+${CRLF}Content-Type: text/html; charset=ISO-8859-1${CRLF}${CRLF}!,"header()");
-test(13,start_html() eq <<END,"start_html()");
+
+is header(), "Content-Type: text/html; charset=ISO-8859-1${CRLF}${CRLF}",
+  "header()";
+
+is header( -type => 'image/gif', -charset => '' ), "Content-Type: image/gif${CRLF}${CRLF}",
+  "header()";
+
+is header( -type => 'image/gif', -status => '500 Sucks' ),
+  "Status: 500 Sucks${CRLF}Content-Type: image/gif${CRLF}${CRLF}", "header()";
+ 
+# return to normal 
+charset( 'ISO-8859-1' );
+
+like header( -nph => 1 ),
+  qr!HTTP/1.0 200 OK${CRLF}Server: cmdline${CRLF}Date:.+${CRLF}Content-Type: text/html; charset=ISO-8859-1${CRLF}${CRLF}!,
+  "header()";
+
+is start_html(), <<END, "start_html()";
 <!DOCTYPE html
 	PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 	 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
@@ -64,50 +87,92 @@
 </head>
 <body>
 END
-    ;
-test(14,start_html(-Title=>'The world of foo') eq <<END,"start_html()");
+
+is start_html(
+    -Title  => 'The world of foo' ,
+    -Script => [ {-src=> 'foo.js', -charset=>'utf-8'} ],
+    ), <<END, "start_html()";
 <!DOCTYPE html
 	PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 	 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
 <head>
 <title>The world of foo</title>
+<script src="foo.js" charset="utf-8" type="text/javascript"></script>
 <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
 </head>
 <body>
 END
-    ;
-# Note that this test will turn off XHTML until we make a new CGI object.
-test(15,start_html(-dtd=>"-//IETF//DTD HTML 3.2//FR",-lang=>'fr') eq <<END,"start_html()");
+
+for my $v (qw/ 2.0 3.2 4.0 4.01 /) {
+    local $CGI::XHTML = 1;
+    is
+      start_html( -dtd => "-//IETF//DTD HTML $v//FR", -lang => 'fr' ),
+      <<"END", 'start_html()';
 <!DOCTYPE html
-	PUBLIC "-//IETF//DTD HTML 3.2//FR">
+	PUBLIC "-//IETF//DTD HTML $v//FR">
 <html lang="fr"><head><title>Untitled Document</title>
 </head>
 <body>
 END
-    ;
-test(16,($cookie=cookie(-name=>'fred',-value=>['chocolate','chip'],-path=>'/')) eq 'fred=chocolate&chip; path=/',"cookie()");
-my $h = header(-Cookie=>$cookie);
-test(17,$h =~ m!^Set-Cookie: fred=chocolate&chip\; path=/${CRLF}Date:.*${CRLF}Content-Type: text/html; charset=ISO-8859-1${CRLF}${CRLF}!s, 
-  "header(-cookie)");
-test(18,start_h3 eq '<h3>');
-test(19,end_h3 eq '</h3>');
-test(20,start_table({-border=>undef}) eq '<table border>');
-test(21,h1(escapeHTML("this is <not> \x8bright\x9b")) eq '<h1>this is &lt;not&gt; &#8249;right&#8250;</h1>');
-charset('utf-8');
-if (ord("\t") == 9) {
-test(22,h1(escapeHTML("this is <not> \x8bright\x9b")) eq '<h1>this is &lt;not&gt; right</h1>');
-}
-else {
-test(22,h1(escapeHTML("this is <not> \x8bright\x9b")) eq '<h1>this is &lt;not&gt; right</h1>');
 }
-test(23,i(p('hello there')) eq '<i><p>hello there</p></i>');
-my $q = new CGI;
-test(24,$q->h1('hi') eq '<h1>hi</h1>');
+
+is
+  start_html( -dtd => "-//IETF//DTD HTML 9.99//FR", -lang => 'fr' ),
+  <<"END", 'start_html()';
+<!DOCTYPE html
+	PUBLIC "-//IETF//DTD HTML 9.99//FR">
+<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
+<head>
+<title>Untitled Document</title>
+<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
+</head>
+<body>
+END
+
+my $cookie =
+  cookie( -name => 'fred', -value => [ 'chocolate', 'chip' ], -path => '/' );
+
+is $cookie, 'fred=chocolate&chip; path=/', "cookie()";
+
+my $h = header( -Cookie => $cookie );
+
+like $h,
+  qr!^Set-Cookie: fred=chocolate&chip\; path=/${CRLF}Date:.*${CRLF}Content-Type: text/html; charset=ISO-8859-1${CRLF}${CRLF}!s,
+  "header(-cookie)";
+
+is start_h3, '<h3>';
+
+is end_h3, '</h3>';
+
+is start_table( { -border => undef } ), '<table border>';
+is h1( escapeHTML("this is <not> \x8bright\x9b") ),
+  '<h1>this is &lt;not&gt; &#8249;right&#8250;</h1>';
+
+charset('utf-8');
+
+is h1( escapeHTML("this is <not> \x8bright\x9b") ),
+  ord("\t") == 9
+  ? '<h1>this is &lt;not&gt; right</h1>'
+  : '<h1>this is &lt;not&gt; right</h1>';
+
+is i( p('hello there') ), '<i><p>hello there</p></i>';
+
+my $q = CGI->new;
+is $q->h1('hi'), '<h1>hi</h1>';
 
 $q->autoEscape(1);
-test(25,$q->p({title=>"hello world&egrave;"},'hello &aacute;') eq '<p title="hello world&amp;egrave;">hello &aacute;</p>');
+
+is $q->p( { title => "hello world&egrave;" }, 'hello &aacute;' ),
+  '<p title="hello world&amp;egrave;">hello &aacute;</p>';
+
 $q->autoEscape(0);
-test(26,$q->p({title=>"hello world&egrave;"},'hello &aacute;') eq '<p title="hello world&egrave;">hello &aacute;</p>');
-test(27,p({title=>"hello world&egrave;"},'hello &aacute;') eq '<p title="hello world&amp;egrave;">hello &aacute;</p>');
-test(28,header(-type=>'image/gif',-charset=>'UTF-8') eq "Content-Type: image/gif; charset=UTF-8${CRLF}${CRLF}","header()");
+
+is $q->p( { title => "hello world&egrave;" }, 'hello &aacute;' ),
+  '<p title="hello world&egrave;">hello &aacute;</p>';
+
+is p( { title => "hello world&egrave;" }, 'hello &aacute;' ),
+  '<p title="hello world&amp;egrave;">hello &aacute;</p>';
+
+is header( -type => 'image/gif', -charset => 'UTF-8' ),
+  "Content-Type: image/gif; charset=UTF-8${CRLF}${CRLF}", "header()";
diff -urN perl-5.10.1/lib/CGI/t.old/http.t perl-5.10.1/lib/CGI/t/http.t
--- perl-5.10.1/lib/CGI/t.old/http.t	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/http.t	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,44 @@
+#!./perl -w
+
+# Fixes RT 12909
+
+use lib qw(t/lib);
+
+use Test::More tests => 7;
+use CGI;
+
+my $cgi = CGI->new();
+
+{
+    # http() without arguments should not cause warnings
+    local $SIG{__WARN__} = sub { die @_ };
+    ok eval { $cgi->http(); 1 },  "http() without arguments doesn't warn";
+    ok eval { $cgi->https(); 1 }, "https() without arguments doesn't warn";
+}
+
+{
+    # Capitalization and the use of hyphens versus underscores are not significant.
+    local $ENV{'HTTP_HOST'}   = 'foo';
+    is $cgi->http('Host'),      'foo', 'http("Host") returns $ENV{HTTP_HOST}';
+    is $cgi->http('http-host'), 'foo', 'http("http-host") returns $ENV{HTTP_HOST}';
+}
+
+{
+    # Called with no arguments returns the list of HTTP environment variables
+    local $ENV{'HTTPS_FOO'} = 'bar';
+    my @http = $cgi->http();
+    is scalar( grep /^HTTPS/, @http), 0, "http() doesn't return HTTPS variables";
+}
+
+{
+    # https()
+    # The same as http(), but operates on the HTTPS environment variables present when the SSL protocol is in
+    # effect.  Can be used to determine whether SSL is turned on.
+    my @expect = grep /^HTTPS/, keys %ENV;
+    push @expect, 'HTTPS'         if not exists $ENV{HTTPS};
+    push @expect, 'HTTPS_KEYSIZE' if not exists $ENV{HTTPS_KEYSIZE};
+    local $ENV{'HTTPS'} = 'ON';
+    local $ENV{'HTTPS_KEYSIZE'} = 512;
+    is $cgi->https(), 'ON', 'scalar context to check SSL is on';
+    ok eq_set( [$cgi->https()], \@expect), 'list context returns https keys';
+}
diff -urN perl-5.10.1/lib/CGI/t.old/init.t perl-5.10.1/lib/CGI/t/init.t
--- perl-5.10.1/lib/CGI/t.old/init.t	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/init.t	2011-01-21 10:12:44.000000000 +0100
@@ -0,0 +1,13 @@
+#!/usr/bin/perl -w
+
+use strict;
+use Test::More tests => 1;
+
+use CGI;
+
+
+$_ = "abcdefghijklmnopq";
+my $IN;
+open ($IN, "t/init_test.txt");
+my $q = CGI->new($IN);
+is($_, 'abcdefghijklmnopq', 'make sure not to clobber $_ on init');
diff -urN perl-5.10.1/lib/CGI/t.old/init_test.txt perl-5.10.1/lib/CGI/t/init_test.txt
--- perl-5.10.1/lib/CGI/t.old/init_test.txt	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/init_test.txt	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,3 @@
+A=B
+D=F
+G=H
diff -urN perl-5.10.1/lib/CGI/t.old/no_tabindex.t perl-5.10.1/lib/CGI/t/no_tabindex.t
--- perl-5.10.1/lib/CGI/t.old/no_tabindex.t	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/no_tabindex.t	2011-01-05 19:13:45.000000000 +0100
@@ -1,9 +1,5 @@
 #!/usr/local/bin/perl -w
 
-# Due to a bug in older versions of MakeMaker & Test::Harness, we must
-# ensure the blib's are in @INC, else we might use the core CGI.pm
-use lib qw(. ./blib/lib ./blib/arch);
-
 use Test::More tests => 18;
 
 BEGIN { use_ok('CGI'); };
diff -urN perl-5.10.1/lib/CGI/t.old/param_fetch.t perl-5.10.1/lib/CGI/t/param_fetch.t
--- perl-5.10.1/lib/CGI/t.old/param_fetch.t	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/param_fetch.t	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,26 @@
+#!perl
+
+# Tests for the param_fetch() method.
+
+use Test::More 'no_plan';
+use CGI;
+
+{
+    my $q = CGI->new('b=baz;a=foo;a=bar');
+
+    is $q->param_fetch('a')->[0] => 'foo', 'first "a" is "foo"';
+    is $q->param_fetch( -name => 'a' )->[0] => 'foo',
+      'first "a" is "foo", with -name';
+    is $q->param_fetch('a')->[1] => 'bar', 'second "a" is "bar"';
+    is_deeply $q->param_fetch('a') => [qw/ foo bar /], 'a is array ref';
+    is_deeply $q->param_fetch( -name => 'a' ) => [qw/ foo bar /],
+      'a is array ref, w/ name';
+
+    is $q->param_fetch('b')->[0] => 'baz', '"b" is "baz"';
+    is_deeply $q->param_fetch('b') => [qw/ baz /], 'b is array ref too';
+
+    is_deeply $q->param_fetch, [], "param_fetch without parameters";
+
+    is_deeply $q->param_fetch( 'a', 'b' ), [qw/ foo bar /],
+      "param_fetch only take first argument";
+}
diff -urN perl-5.10.1/lib/CGI/t.old/popup_menu.t perl-5.10.1/lib/CGI/t/popup_menu.t
--- perl-5.10.1/lib/CGI/t.old/popup_menu.t	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/popup_menu.t	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,22 @@
+#!perl
+# Tests for popup_menu();
+use Test::More 'no_plan';
+use CGI;
+
+my $q  = CGI->new;
+
+is ( $q->popup_menu(-name=>"foo", - values=>[0,1], -default=>0),
+'<select name="foo" >
+<option selected="selected" value="0">0</option>
+<option value="1">1</option>
+</select>'
+, 'popup_menu(): basic test, including 0 as a default value');
+
+is(
+    CGI::popup_menu(-values=>[CGI::optgroup(-values=>["b+"])],-default=>"b+"),
+    '<select name="" >
+<optgroup label="">
+<option selected="selected" value="b+">b+</option>
+</optgroup>
+</select>'
+    , "<optgroup> selections work when the default values contain regex characters (RT#49606)"); 
diff -urN perl-5.10.1/lib/CGI/t.old/pretty.t perl-5.10.1/lib/CGI/t/pretty.t
--- perl-5.10.1/lib/CGI/t.old/pretty.t	2009-06-10 18:53:46.000000000 +0200
+++ perl-5.10.1/lib/CGI/t/pretty.t	2011-01-05 19:13:45.000000000 +0100
@@ -1,13 +1,8 @@
 #!/bin/perl -w
 
 use strict;
-use lib '.', 't/lib','../blib/lib','./blib/lib';
-use Test::More tests => 18;
-
-BEGIN { use_ok('CGI::Pretty') };
-
-# This is silly use_ok should take arguments
-use CGI::Pretty (':all');
+use Test::More tests => 17;
+use CGI::Pretty ':all';
 
 is(h1(), '<h1 />
 ',"single tag");
@@ -26,8 +21,7 @@
 
 is(p('hi',pre('there'),'frog'), <<HTML, "<pre> tags");
 <p>
-	hi <pre>there</pre>
-	frog
+	hi <pre>there</pre> frog
 </p>
 HTML
 
@@ -54,8 +48,7 @@
 
 is(p('hi',a({-href=>'frog'},'there'),'frog'), <<HTML,   "as-is");
 <p>
-	hi <a href="frog">there</a>
-	frog
+	hi <a href="frog">there</a> frog
 </p>
 HTML
 
@@ -100,9 +93,7 @@
 	<tr>
 		<td><table>
 			<tr>
-				<td>hi</td>
-				<td>there</td>
-				<td>frog</td>
+				<td>hi</td><td>there</td><td>frog</td>
 			</tr>
 		</table></td>
 	</tr>
diff -urN perl-5.10.1/lib/CGI/t.old/push.t perl-5.10.1/lib/CGI/t/push.t
--- perl-5.10.1/lib/CGI/t.old/push.t	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/push.t	2011-01-05 19:13:45.000000000 +0100
@@ -1,11 +1,5 @@
 #!./perl -wT
 
-use lib qw(t/lib);
-
-# Due to a bug in older versions of MakeMaker & Test::Harness, we must
-# ensure the blib's are in @INC, else we might use the core CGI.pm
-use lib qw(blib/lib blib/arch);
-
 use Test::More tests => 12; 
 
 use_ok( 'CGI::Push' );
diff -urN perl-5.10.1/lib/CGI/t.old/query_string.t perl-5.10.1/lib/CGI/t/query_string.t
--- perl-5.10.1/lib/CGI/t.old/query_string.t	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/query_string.t	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,15 @@
+#!perl
+
+# Tests for the query_string() method.
+
+use Test::More 'no_plan';
+use CGI;
+
+{
+    my $q1 = CGI->new('b=2;a=1;a=1');
+    my $q2 = CGI->new('b=2&a=1&a=1');
+
+    is($q1->query_string
+        ,$q2->query_string
+        , "query string format is returned with the same delimiter regardless of input.");
+}
diff -urN perl-5.10.1/lib/CGI/t.old/request.t perl-5.10.1/lib/CGI/t/request.t
--- perl-5.10.1/lib/CGI/t.old/request.t	2009-06-10 18:53:46.000000000 +0200
+++ perl-5.10.1/lib/CGI/t/request.t	2011-01-05 19:13:45.000000000 +0100
@@ -1,24 +1,18 @@
-#!/usr/local/bin/perl -w
+#!/usr/local/bin/perl
 
-# Test ability to retrieve HTTP request info
-######################### We start with some black magic to print on failure.
-use lib '.','../blib/lib','../blib/arch';
+use strict;
+use warnings;
+
+use Test::More tests => 41;
 
-BEGIN {$| = 1; print "1..34\n"; }
-END {print "not ok 1\n" unless $loaded;}
 use CGI ();
 use Config;
-$loaded = 1;
-print "ok 1\n";
 
-######################### End of black magic.
+my $loaded = 1;
 
-# util
-sub test {
-    local($^W) = 0;
-    my($num, $true,$msg) = @_;
-    print($true ? "ok $num\n" : "not ok $num $msg\n");
-}
+$| = 1;
+
+######################### End of black magic.
 
 # Set up a CGI environment
 $ENV{REQUEST_METHOD}  = 'GET';
@@ -32,68 +26,90 @@
 $ENV{REQUEST_URI}     = "$ENV{SCRIPT_NAME}$ENV{PATH_INFO}?$ENV{QUERY_STRING}";
 $ENV{HTTP_LOVE}       = 'true';
 
-$q = new CGI;
-test(2,$q,"CGI::new()");
-test(3,$q->request_method eq 'GET',"CGI::request_method()");
-test(4,$q->query_string eq 'game=chess;game=checkers;weather=dull',"CGI::query_string()");
-test(5,$q->param() == 2,"CGI::param()");
-test(6,join(' ',sort $q->param()) eq 'game weather',"CGI::param()");
-test(7,$q->param('game') eq 'chess',"CGI::param()");
-test(8,$q->param('weather') eq 'dull',"CGI::param()");
-test(9,join(' ',$q->param('game')) eq 'chess checkers',"CGI::param()");
-test(10,$q->param(-name=>'foo',-value=>'bar'),'CGI::param() put');
-test(11,$q->param(-name=>'foo') eq 'bar','CGI::param() get');
-test(12,$q->query_string eq 'game=chess;game=checkers;weather=dull;foo=bar',"CGI::query_string() redux");
-test(13,$q->http('love') eq 'true',"CGI::http()");
-test(14,$q->script_name eq '/cgi-bin/foo.cgi',"CGI::script_name()");
-test(15,$q->url eq 'http://the.good.ship.lollypop.com:8080/cgi-bin/foo.cgi',"CGI::url()");
-test(16,$q->self_url eq 
+my $q = new CGI;
+ok $q,"CGI::new()";
+is $q->request_method => 'GET',"CGI::request_method()";
+is $q->query_string => 'game=chess;game=checkers;weather=dull',"CGI::query_string()";
+is $q->param(), 2,"CGI::param()";
+is join(' ',sort $q->param()), 'game weather',"CGI::param()";
+is $q->param('game'), 'chess',"CGI::param()";
+is $q->param('weather'), 'dull',"CGI::param()";
+is join(' ',$q->param('game')), 'chess checkers',"CGI::param()";
+ok $q->param(-name=>'foo',-value=>'bar'),'CGI::param() put';
+is $q->param(-name=>'foo'), 'bar','CGI::param() get';
+is $q->query_string, 'game=chess;game=checkers;weather=dull;foo=bar',"CGI::query_string() redux";
+is $q->http('love'), 'true',"CGI::http()";
+is $q->script_name, '/cgi-bin/foo.cgi',"CGI::script_name()";
+is $q->url, 'http://the.good.ship.lollypop.com:8080/cgi-bin/foo.cgi',"CGI::url()";
+is $q->self_url,
      'http://the.good.ship.lollypop.com:8080/cgi-bin/foo.cgi/somewhere/else?game=chess;game=checkers;weather=dull;foo=bar',
-     "CGI::url()");
-test(17,$q->url(-absolute=>1) eq '/cgi-bin/foo.cgi','CGI::url(-absolute=>1)');
-test(18,$q->url(-relative=>1) eq 'foo.cgi','CGI::url(-relative=>1)');
-test(19,$q->url(-relative=>1,-path=>1) eq 'foo.cgi/somewhere/else','CGI::url(-relative=>1,-path=>1)');
-test(20,$q->url(-relative=>1,-path=>1,-query=>1) eq 
+     "CGI::url()";
+is $q->url(-absolute=>1), '/cgi-bin/foo.cgi','CGI::url(-absolute=>1)';
+is $q->url(-relative=>1), 'foo.cgi','CGI::url(-relative=>1)';
+is $q->url(-relative=>1,-path=>1), 'foo.cgi/somewhere/else','CGI::url(-relative=>1,-path=>1)';
+is $q->url(-relative=>1,-path=>1,-query=>1), 
      'foo.cgi/somewhere/else?game=chess;game=checkers;weather=dull;foo=bar',
-     'CGI::url(-relative=>1,-path=>1,-query=>1)');
+     'CGI::url(-relative=>1,-path=>1,-query=>1)';
 $q->delete('foo');
-test(21,!$q->param('foo'),'CGI::delete()');
+ok !$q->param('foo'),'CGI::delete()';
 
 $q->_reset_globals;
 $ENV{QUERY_STRING}='mary+had+a+little+lamb';
-test(22,$q=new CGI,"CGI::new() redux");
-test(23,join(' ',$q->keywords) eq 'mary had a little lamb','CGI::keywords');
-test(24,join(' ',$q->param('keywords')) eq 'mary had a little lamb','CGI::keywords');
-test(25,$q=new CGI('foo=bar&foo=baz'),"CGI::new() redux");
-test(26,$q->param('foo') eq 'bar','CGI::param() redux');
-test(27,$q=new CGI({'foo'=>'bar','bar'=>'froz'}),"CGI::new() redux 2");
-test(28,$q->param('bar') eq 'froz',"CGI::param() redux 2");
+ok $q=new CGI,"CGI::new() redux";
+is join(' ',$q->keywords), 'mary had a little lamb','CGI::keywords';
+is join(' ',$q->param('keywords')), 'mary had a little lamb','CGI::keywords';
+ok $q=new CGI('foo=bar&foo=baz'),"CGI::new() redux";
+is $q->param('foo'), 'bar','CGI::param() redux';
+ok $q=new CGI({'foo'=>'bar','bar'=>'froz'}),"CGI::new() redux 2";
+is $q->param('bar'), 'froz',"CGI::param() redux 2";
 
 # test tied interface
 my $p = $q->Vars;
-test(29,$p->{bar} eq 'froz',"tied interface fetch");
+is $p->{bar}, 'froz',"tied interface fetch";
 $p->{bar} = join("\0",qw(foo bar baz));
-test(30,join(' ',$q->param('bar')) eq 'foo bar baz','tied interface store');
-test(31,exists $p->{bar});
+is join(' ',$q->param('bar')), 'foo bar baz','tied interface store';
+ok exists $p->{bar};
 
 # test posting
 $q->_reset_globals;
-if ($Config{d_fork}) {
-  $test_string = 'game=soccer&game=baseball&weather=nice';
-  $ENV{REQUEST_METHOD}='POST';
-  $ENV{CONTENT_LENGTH}=length($test_string);
-  $ENV{QUERY_STRING}='big_balls=basketball&small_balls=golf';
-  if (open(CHILD,"|-")) {  # cparent
-    print CHILD $test_string;
-    close CHILD;
-    exit 0;
-  }
-  # at this point, we're in a new (child) process
-  test(32,$q=new CGI,"CGI::new() from POST");
-  test(33,$q->param('weather') eq 'nice',"CGI::param() from POST");
-  test(34,$q->url_param('big_balls') eq 'basketball',"CGI::url_param()");
-} else {
-  print "ok 32 # Skip\n";
-  print "ok 33 # Skip\n";
-  print "ok 34 # Skip\n";
+{
+  my $test_string = 'game=soccer&game=baseball&weather=nice';
+  local $ENV{REQUEST_METHOD}='POST';
+  local $ENV{CONTENT_LENGTH}=length($test_string);
+  local $ENV{QUERY_STRING}='big_balls=basketball&small_balls=golf';
+
+  local *STDIN;
+  open STDIN, '<', \$test_string;
+
+  ok $q=new CGI,"CGI::new() from POST";
+  is $q->param('weather'), 'nice',"CGI::param() from POST";
+  is $q->url_param('big_balls'), 'basketball',"CGI::url_param()";
+}
+
+# test url_param 
+{
+    local $ENV{QUERY_STRING} = 'game=chess&game=checkers&weather=dull';
+
+    CGI::_reset_globals;
+    my $q = CGI->new;
+    # params present, param and url_param should return true
+    ok $q->param,     'param() is true if parameters';
+    ok $q->url_param, 'url_param() is true if parameters';
+
+    $ENV{QUERY_STRING} = '';
+
+    CGI::_reset_globals;
+    $q = CGI->new;
+    ok !$q->param,     'param() is false if no parameters';
+    ok !$q->url_param, 'url_param() is false if no parameters';
+
+    $ENV{QUERY_STRING} = 'tiger dragon';
+    CGI::_reset_globals;
+    $q = CGI->new;
+
+    is_deeply [$q->$_] => [ 'keywords' ], "$_ with QS='$ENV{QUERY_STRING}'" 
+        for qw/ param url_param /;
+
+    is_deeply [ sort $q->$_( 'keywords' ) ], [ qw/ dragon tiger / ],
+        "$_ keywords" for qw/ param url_param /;
 }
diff -urN perl-5.10.1/lib/CGI/t.old/save_read_roundtrip.t perl-5.10.1/lib/CGI/t/save_read_roundtrip.t
--- perl-5.10.1/lib/CGI/t.old/save_read_roundtrip.t	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/save_read_roundtrip.t	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,24 @@
+
+use strict;
+use warnings;
+
+# Reference: RT#13158: Needs test: empty name/value, when saved, prevents proper restore from filehandle.
+#                      https://rt.cpan.org/Ticket/Display.html?id=13158
+
+use Test::More tests => 3;
+
+use IO::File;
+use CGI;
+
+my $cgi = CGI->new('a=1;=;b=2;=3');
+ok eq_set (['a', '', 'b'], [$cgi->param]);
+
+# not File::Temp, since that wasn't in core at 5.6.0
+my $tmp = IO::File->new_tmpfile;
+$cgi->save($tmp);
+$tmp->seek(0,0);
+
+$cgi = CGI->new($tmp);
+ok eq_set (['a', '', 'b'], [$cgi->param]);
+is $cgi->param(''), 3; # '=' is lost, '=3' is retained
+
diff -urN perl-5.10.1/lib/CGI/t.old/switch.t perl-5.10.1/lib/CGI/t/switch.t
--- perl-5.10.1/lib/CGI/t.old/switch.t	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/switch.t	2011-01-05 19:13:45.000000000 +0100
@@ -1,11 +1,5 @@
 #!/usr/local/bin/perl -w
 
-use lib qw(t/lib);
-
-# Due to a bug in older versions of MakeMaker & Test::Harness, we must
-# ensure the blib's are in @INC, else we might use the core CGI.pm
-use lib qw(blib/lib blib/arch);
-
 use strict;
 use Test::More tests => 1;
 
diff -urN perl-5.10.1/lib/CGI/t.old/unescapeHTML.t perl-5.10.1/lib/CGI/t/unescapeHTML.t
--- perl-5.10.1/lib/CGI/t.old/unescapeHTML.t	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/unescapeHTML.t	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,8 @@
+use Test::More tests => 4;
+use CGI 'unescapeHTML';
+
+is( unescapeHTML( '&amp;'), '&', 'unescapeHTML: &');
+is( unescapeHTML( '&quot;'), '"', 'unescapeHTML: "');
+is( unescapeHTML( '&#60;'), '<', 'unescapeHTML: < (using a numbered sequence)'); 
+is( unescapeHTML( 'Bob & Tom went to the store; Where did you go?'), 
+    'Bob & Tom went to the store; Where did you go?', 'unescapeHTML: a case where &...; should not be escaped.');
diff -urN perl-5.10.1/lib/CGI/t.old/uploadInfo.t perl-5.10.1/lib/CGI/t/uploadInfo.t
--- perl-5.10.1/lib/CGI/t.old/uploadInfo.t	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/uploadInfo.t	2011-01-05 19:13:45.000000000 +0100
@@ -5,22 +5,7 @@
 #  Shamelessly stolen from Data::FormValidator and CGI::Upload  #
 #################################################################
 
-# Due to a bug in older versions of MakeMaker & Test::Harness, we must
-# ensure the blib's are in @INC, else we might use the core CGI.pm
-
-my $test_file;
-if($ENV{PERL_CORE}) {
-   chdir 't';
-   @INC = '../lib';
-   use File::Spec ();
-   $test_file = File::Spec->catfile(qw(.. lib CGI t), "upload_post_text.txt");
-} else {
-   use lib qw(. ./blib/lib ./blib/arch);
-   $test_file = "t/upload_post_text.txt";
-}
-
 use strict;
-
 use Test::More 'no_plan';
 
 use CGI;
@@ -78,7 +63,7 @@
 
 {
     local *STDIN;
-    open STDIN, "< $test_file"
+    open STDIN, '<t/upload_post_text.txt'
         or die 'missing test file t/upload_post_text.txt';
     binmode STDIN;
     $q = CGI->new;
Binary files perl-5.10.1/lib/CGI/t.old/upload_post_text.txt and perl-5.10.1/lib/CGI/t/upload_post_text.txt differ
diff -urN perl-5.10.1/lib/CGI/t.old/upload_post_text.txt.packed perl-5.10.1/lib/CGI/t/upload_post_text.txt.packed
--- perl-5.10.1/lib/CGI/t.old/upload_post_text.txt.packed	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/upload_post_text.txt.packed	1970-01-01 01:00:00.000000000 +0100
@@ -1,89 +0,0 @@
-#########################################################################
-This is a binary file that was packed with the 'uupacktool.pl' which
-is included in the Perl distribution.
-
-To unpack this file use the following command:
-
-     uupacktool.pl -u lib/CGI/t/upload_post_text.txt.packed lib/CGI/t/upload_post_text.txt
-
-To recreate it use the following command:
-
-     uupacktool.pl -p lib/CGI/t/upload_post_text.txt lib/CGI/t/upload_post_text.txt.packed
-
-Created at Thu Apr  3 17:55:51 2008
-#########################################################################
-__UU__
-M+2UX67I:60T*0V]N=&5N="U$:7-P;W-I=&EO;CH@9F]R;2UD871A.R!N86UE
-M/2)H96QL;U]W;W)L9"([(&9I;&5N86UE/2)G;V]D8GEE7W=O<FQD+G1X="(-
-M"D-O;G1E;G0M3&5N9W1H.B`Q,PT*0V]N=&5N="U4>7!E.B!T97AT+W!L86EN
-M#0H-"D=O;V1B>64@5V]R;&0A"@T*+2UX67I:60T*0V]N=&5N="U$:7-P;W-I
-M=&EO;CH@9F]R;2UD871A.R!N86UE/2)H96QL;U]W;W)L9"([(&9I;&5N86UE
-M/2)H96QL;U]W;W)L9"YT>'0B#0I#;VYT96YT+4QE;F=T:#H@,3,-"D-O;G1E
-M;G0M5'EP93H@=&5X="]P;&%I;@T*#0I(96QL;R!7;W)L9"$*#0HM+7A9>EI9
-M#0I#;VYT96YT+41I<W!O<VET:6]N.B!F;W)M+61A=&$[(&YA;64](F1O97-?
-M;F]T7V5X:7-T7V=I9B([(&9I;&5N86UE/2)D;V5S7VYO=%]E>&ES="YG:68B
-M#0I#;VYT96YT+51Y<&4Z(&%P<&QI8V%T:6]N+V]C=&5T+7-T<F5A;0T*#0H-
-M"BTM>%EZ6ED-"D-O;G1E;G0M1&ES<&]S:71I;VXZ(&9O<FTM9&%T83L@;F%M
-M93TB,3`P.S$P,%]G:68B.R!F:6QE;F%M93TB,3`P.S$P,"YG:68B#0I#;VYT
-M96YT+4QE;F=T:#H@.#DV#0I#;VYT96YT+51Y<&4Z(&EM86=E+V=I9@T*#0I'
-M248X.6%D`&0`Q```@("`O[^_0$!`[^_O,#`PW]_?S\_/<'!P4%!0GY^?("`@
-MCX^/8&!@KZ^O$!`0````____````````````````````````````````````
-M````````````````````````(?D$```````L`````&0`9```!?_@(XYD:9YH
-MJJYLJT)P+,]T;=]XKN^UR/_`H%#H&QJ/R%\QR6PRE\ZHE`>=6J^R*G8KU7*_
-M22]X3'R0ST<Q>GU3L]]9,WQN<]/9]CLZKR?S^V!_@%R"@UB%AE:(B5URC'B.
-MCWN1DGZ4E8&7F(2:FX>=GHJ@1@4%-`$\`P9PBS4",0``-*\[!@>LHSP&#Z@0
-ML0:K,;TP`<$TJC$#`:8W`<-AN3L)#[*^"@<$U1".`@<(M#,!M`,*`-DU`P0'
-M#`1-K32.`+?B,8X."<HU]!`&"@W(QX!-<Q=M1SQ9^[;%,,!``8(!I\`U0'`-
-M'0$&"PKJ>#?C((2$CAY"(/",&*T"#"#_#-!$;Q?!)@3:^4((SE&"F+<BQL!&
-M(($-`=T<0(06:@S'HDHT(DVC=.F0HTYS0(W:IBG5I%=%99TR=6L<.`)ZQ4*W
-M(,B`LD^M1@D+8ZQ.(`F#M"I`0``!9MNP,:"8$P*VBC#8SJQ!P$%.`SAC-(B)
-M($;AOD!:`4C98-B#`BLQRRE0M@`WL=ID)+P+@8%/"`)\+F`6-[):E0@<,#`F
-MI_9.`@@^MPTMK";0U#`07QO:&JL09[YJPK#]L=W*&(+=A@.GP%0I&`DP(ZA6
-MG,KK`N6`+Q^O4&6YW-!!US!P#WNVZC`6FPO&_K3<URJ7B2;&'T8^`T,!",-U
-MZQE30`!##8B@_0S`I.55%%T]N`U^$G9$887U7(CAA!LB$>&#'WH5XE8C0N=4
-MB?TAA2)J,22P``((!`!C@@`(@(`Q`^QU@'T-",!`@EQIV`8L`N18)`)H-7!+
-M`N`@24XU!A39XR>'P"++6-(M((`"R@UF#5!"UA%F#U8.YM:+RH`CE%_5+`#9
-M%2MZA&4U"<18UTX,-.!`->`UH"655VB#W*##N,B9,"X>H$T!`"P`9".,*+!`
-M`_!9PLA9`.!EU)@@<BJBIR2"FM6*49%ZHJA7F;J4JBJB2A6K1<$:BJR>T+J)
-MK9C@6HFNDO#ZB*^,`)N(L(80.XBQ@"#;A[)ZN.#LL]!&*ZT((0``.PT*+2UX
-M67I:60T*0V]N=&5N="U$:7-P;W-I=&EO;CH@9F]R;2UD871A.R!N86UE/2(S
-M,#!X,S`P7V=I9B([(&9I;&5N86UE/2(S,#!X,S`P+F=I9B(-"D-O;G1E;G0M
-M3&5N9W1H.B`Q-C4V#0I#;VYT96YT+51Y<&4Z(&EM86=E+V=I9@T*#0I'248X
-M.6$L`2P!Q```0$!`O[^_@("`[^_OS\_/,#`P<'!PGY^?4%!0("`@W]_?CX^/
-MKZ^O8&!@$!`0````____````````````````````````````````````````
-M````````````````````(?D$```````L`````"P!+`$`!?_@(XYD:9YHJJYL
-MZ[YP+,]T;=_X`^U\[__`H'!(+!J/R*1RR6PZG]"G*$JM6J_8K';+-4Z[X+!X
-M3"Z/O^:T>LUN@]'NN'Q.G\/K^+Q^'[WS_X"!@'Z"A8:':82(BXR-5(J.D9*3
-M09"4EYB,EIF<G7R;GJ&B;J"CIJ=BI:BKK%:JK;"Q2J^RM;9`M+>ZMKF[OJV]
-MO\*FP</&G<7'RI3)R\Z-S<_2AM'3UG_5U]IXV=O><=W?XFKAX^9G.N?J@>7K
-M[ECM[_)]Z?/VI/7W^HGY^_ZI_?X)W!)OH$$>!0\:3*A0(,.&_AY"U"=QHKV*
-M%N5AS.AN(T=U'C^:"RE2',F2WD[_HM2F<J6UEBZEP8SI;"9-939O&LNI4QC/
-MGKY^`M4E="BO@$8A%DT::RE38$B?+HPJU2'5JA&O8J6H=>O%KEXU@@W;<2Q9
-MD&;/CDRKUB3;MBG?PF4I=^[+NG9EXLU;<R]?G'[_[@PLV"?APD$/(R:J>/%1
-MQV@AGW,JF5KCRE`QN]7\C3)G;)<_$PLM6I3GTGE.HZZC>K4=TJXSM8Z-CW9?
-MV\MFXR8'>W<DW;[+``^.CKAAX[^&(^^B?#G!WLX+-8\.#SKU0=:O?\JN7<_T
-M[O3`P_HNW@GY\DS.HY_%?3VX]N[;J(_O!3Y]WO=-V\\O?#__XO]Q,E^`/PQ(
-M8`\&'KA#_X)Z**#`#P$<,0`!)3$X!P`\""#`#Q@:08`!%?HW"@$/1`B!A@10
-MR(.).P2@X@\3\C!```\*$0"+8LUSP`,;GIB``07T"$$]`!B`0(<^!-#A``D(
-M$"00`Q1@0`,%?'51AB`JB1`/#APP(Q!:0D!``@S$"&.*.UHY3ST:0A#FD#P0
-MT$`""`P`(9(,(/`CE`4TL("(HU@H!YL;OEE/G1`4@&.+'2K0``0#(*4EB6K*
-M4T"5)Q:*9#T'7`KBG3P`6<`!00!0I`-VYJ@@,X"N6IVKDP@:H*S_T<J?K?GA
-M>I^N]/$:GZ]A`+!H%D(BP<"+:ZTC[!M++!N9.LX.8&H"I"Z(P/^GTIJ*9*>C
-M`F'``TB*^J*I!3"PPP$.%(#L9M":&("Y!VQ:(P0&;"C`D@GLD,"\"/+`P*,*
-MY.MF`1-6"X&SD[6*2;0(%&#JECPL&V8`#FB[[H(9)J!MJ`X@8.X.""?;[@X"
-M@,C`ICTT0&J\.P2\`P&I^L#IHVZV3&H`1`[;F<*7.!M`D`Y#_'*3&O/0P+68
-M_N``ME)>RX.4#=`,`0((\,ON.3#SH`"%+.)X``'O(M`#V$(H@*.+22([8\SC
-M`%O'`D#K3)/;=9C--E!TEY>W>'N#UW=W?VL7^'6#4U?X&$AN=;@8<C.U>+`\
-M'+``U0%0'?.]"+PXP-$&&'QR`W=S-1#_FP!L7CH""^S``(@L[X`ZDST24/K)
-MH_.,"J&9YK[#`@`4C;'N`F@,@.VG/,XLR?8FOWN=;Z)*;X\+?#K5Z!DJWR8$
-M!R#P<[@-,.!`CP$SP'OM`PEYHYL1GG_N`@JDWJ+D]6HMP`*AWV/\'@DLP,"^
-M%MVOQP`+$(#5%.*_X!30-P?<30)QLT#;-)`V#XQ-!%TSP=54$#47+$T&1;/!
-MSW20,Q_43`@Q,\+*E%`R)X1,"AVSPL6T$#$O+$P,!3/#O]20+S?,2P[MLL.Y
-M]!`N/VQ+$-4RQ+,4D2Q'#$L2O;)$Q1$/5E)X(A2;T$2L5+$J5Y1*%I^R1<=)
-M<8I+Z&)2Q&@4]3(.Q8QX^R(8DX#&GK11)V^\21SGIL8U'F&.,<&C2_2X$CZB
-MQ(\ALN,B`"D20G[$D!Q!9$84V;\Z"I((C)Q())7BR$<*89(-P20!*VE)7'"R
-MDS+[)"@1(LI1#JF4H]3D050Y/5."QI6OA.4>6$D^67H'E:"DI55L>4M>I@:7
-MG=3E/X29%5]R`YB6).8^E"DZ8]*!F?9#YB.A62EGOL>:K\'FH*0I2&JNB9MV
-M]*:JM"D?<*Y1G.]`9UG(61MVLD&=ZX#GL]R)'WK6TYYFD&?"\,D/?N;3G&#4
-MI\C\"2""`L2@!44H<W+`T(8Z]*$0C:A$)TK1$H0``#L-"BTM>%EZ6EDM+0T*
-!"@``
diff -urN perl-5.10.1/lib/CGI/t.old/upload.t perl-5.10.1/lib/CGI/t/upload.t
--- perl-5.10.1/lib/CGI/t.old/upload.t	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/upload.t	2011-01-05 19:13:45.000000000 +0100
@@ -5,20 +5,6 @@
 #  Shamelessly stolen from Data::FormValidator and CGI::Upload  #
 #################################################################
 
-# Due to a bug in older versions of MakeMaker & Test::Harness, we must
-# ensure the blib's are in @INC, else we might use the core CGI.pm
-
-my $test_file;
-if($ENV{PERL_CORE}) {
-   chdir 't';
-   @INC = '../lib';
-   use File::Spec ();
-   $test_file = File::Spec->catfile(qw(.. lib CGI t), "upload_post_text.txt");
-} else {
-   use lib qw(. ./blib/lib ./blib/arch);
-   $test_file = "t/upload_post_text.txt";
-}
-
 use strict;
 
 use Test::More 'no_plan';
@@ -77,7 +63,7 @@
 
 {
     local *STDIN;
-    open STDIN, "< $test_file"
+    open STDIN, '<t/upload_post_text.txt'
         or die 'missing test file t/upload_post_text.txt';
     binmode STDIN;
     $q = CGI->new;
diff -urN perl-5.10.1/lib/CGI/t.old/url.t perl-5.10.1/lib/CGI/t/url.t
--- perl-5.10.1/lib/CGI/t.old/url.t	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/url.t	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,23 @@
+use strict;
+use warnings;
+
+use Test::More tests => 4;    # last test to print
+
+use CGI qw/ :all /;
+
+$ENV{HTTP_X_FORWARDED_HOST} = 'proxy:8484';
+$ENV{SERVER_PROTOCOL}       = 'HTTP/1.0';
+$ENV{SERVER_PORT}           = 8080;
+$ENV{SERVER_NAME}           = 'the.good.ship.lollypop.com';
+
+is virtual_port() => 8484, 'virtual_port()';
+is server_port()  => 8080, 'server_port()';
+
+is url() => 'http://proxy:8484', 'url()';
+
+# let's see if we do the defaults right
+
+$ENV{HTTP_X_FORWARDED_HOST} = 'proxy:80';
+
+is url() => 'http://proxy', 'url() with default port';
+
diff -urN perl-5.10.1/lib/CGI/t.old/user_agent.t perl-5.10.1/lib/CGI/t/user_agent.t
--- perl-5.10.1/lib/CGI/t.old/user_agent.t	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/user_agent.t	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,14 @@
+# Test the user_agent method. 
+use Test::More 'no_plan';
+use CGI;
+
+my $q = CGI->new; 
+
+is($q->user_agent, undef, 'user_agent: undef test'); 
+
+$ENV{HTTP_USER_AGENT} = 'mark';
+is($q->user_agent, 'mark', 'user_agent: basic test'); 
+ok($q->user_agent('ma.*'), 'user_agent: positive regex test'); 
+ok(!$q->user_agent('BOOM.*'), 'user_agent: negative regex test'); 
+
+
diff -urN perl-5.10.1/lib/CGI/t.old/utf8.t perl-5.10.1/lib/CGI/t/utf8.t
--- perl-5.10.1/lib/CGI/t.old/utf8.t	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/utf8.t	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,34 @@
+#!perl -T
+
+use strict;
+use warnings;
+
+use utf8;
+
+use Test::More tests => 7;
+use Encode;
+
+use_ok( 'CGI' );
+
+ok( my $q = CGI->new, 'create a new CGI object' );
+
+{
+    no warnings qw/ once /;
+    $CGI::PARAM_UTF8 = 1;
+}
+
+my $data = '';
+ok Encode::is_utf8($data), "created UTF-8 encoded data string";
+
+# now set the param.
+$q->param(data => $data);
+
+# if param() runs the data  through Encode::decode(), this will fail.
+is $q->param('data'), $data;
+
+# make sure setting bytes decodes properly
+my $bytes = Encode::encode(utf8 => $data);
+ok !Encode::is_utf8($bytes), "converted UTF-8 to bytes";
+$q->param(data => $bytes);
+is $q->param('data'), $data;
+ok Encode::is_utf8($q->param('data')), 'param() decoded UTF-8';
diff -urN perl-5.10.1/lib/CGI/t.old/util-58.t perl-5.10.1/lib/CGI/t/util-58.t
--- perl-5.10.1/lib/CGI/t.old/util-58.t	2009-04-22 21:35:40.000000000 +0200
+++ perl-5.10.1/lib/CGI/t/util-58.t	2011-01-05 19:13:45.000000000 +0100
@@ -10,7 +10,7 @@
 # 2) is a valid utf-8 sequence, but not an UTF-8-flagged string
 #    This happens often: people write utf-8 strings to source, but forget
 #    to tell perl about it by "use utf8;"--this is obviously wrong, but we
-#    have to handle it gracefully, for compatibility with GCI.pm under
+#    have to handle it gracefully, for compatibility with CGI.pm under
 #    perl-5.8.x
 #
 $uri = "pe\x{c5}\x{99}\x{c3}\x{ad}\x{c4}\x{8d}ko.ogg";
diff -urN perl-5.10.1/lib/CGI/t.old/util.t perl-5.10.1/lib/CGI/t/util.t
--- perl-5.10.1/lib/CGI/t.old/util.t	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/t/util.t	2011-01-05 19:13:45.000000000 +0100
@@ -2,24 +2,12 @@
 
 # Test ability to escape() and unescape() punctuation characters
 # except for qw(- . _).
-######################### We start with some black magic to print on failure.
-use lib '../blib/lib','../blib/arch';
 
-BEGIN {$| = 1; print "1..57\n"; }
-END {print "not ok 1\n" unless $loaded;}
+$| = 1;
+
+use Test::More tests => 57;
 use Config;
-use CGI::Util qw(escape unescape);
-$loaded = 1;
-print "ok 1\n";
-
-######################### End of black magic.
-
-# util
-sub test {
-    local($^W) = 0;
-    my($num, $true,$msg) = @_;
-    print($true ? "ok $num\n" : "not ok $num $msg\n");
-}
+use_ok ( 'CGI::Util', qw(escape unescape) );
 
 # ASCII order, ASCII codepoints, ASCII repertoire
 
@@ -42,10 +30,10 @@
     $i++;
     my $escape = "AbC\%$punct{$_}dEF";
     my $cgi_escape = escape("AbC$_" . "dEF");
-    test($i, $escape eq $cgi_escape , "# $escape ne $cgi_escape");
+    is($escape, $cgi_escape , "# $escape ne $cgi_escape");
     $i++;
     my $unescape = "AbC$_" . "dEF";
     my $cgi_unescape = unescape("AbC\%$punct{$_}dEF");
-    test($i, $unescape eq $cgi_unescape , "# $unescape ne $cgi_unescape");
+    is($unescape, $cgi_unescape , "# $unescape ne $cgi_unescape");
 }
 
diff -urN perl-5.10.1/lib/CGI/eg/caution.xbm perl-5.10.1/lib/CGI/eg.oldeg/caution.xbm
--- perl-5.10.1/lib/CGI/eg/caution.xbm	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/eg.oldeg/caution.xbm	1970-01-01 01:00:00.000000000 +0100
@@ -1,12 +0,0 @@
-#define caution_width 32
-#define caution_height 32
-static char caution_bits[] = {
- 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x00,0x00,0x00,0x10,0x01,
- 0x00,0x00,0x08,0x07,0x00,0x00,0x08,0x0e,0x00,0x00,0x04,0x0e,0x00,0x00,0x04,
- 0x1c,0x00,0x00,0x02,0x1c,0x00,0x00,0xe2,0x38,0x00,0x00,0xf1,0x39,0x00,0x00,
- 0xf1,0x71,0x00,0x80,0xf0,0x71,0x00,0x80,0xf0,0xe1,0x00,0x40,0xf0,0xe1,0x00,
- 0x40,0xf0,0xc1,0x01,0x20,0xf0,0xc1,0x01,0x20,0xf0,0x81,0x03,0x10,0xe0,0x80,
- 0x03,0x10,0xe0,0x00,0x07,0x08,0xe0,0x00,0x07,0x08,0xe0,0x00,0x0e,0x04,0x00,
- 0x00,0x0e,0x04,0xe0,0x00,0x1c,0x02,0xf0,0x01,0x1c,0x02,0xf0,0x01,0x38,0x01,
- 0xe0,0x00,0x38,0x01,0x00,0x00,0x70,0x01,0x00,0x00,0x70,0xff,0xff,0xff,0x7f,
- 0xf8,0xff,0xff,0x3f,0x00,0x00,0x00,0x00};
diff -urN perl-5.10.1/lib/CGI/eg/clickable_image.cgi perl-5.10.1/lib/CGI/eg.oldeg/clickable_image.cgi
--- perl-5.10.1/lib/CGI/eg/clickable_image.cgi	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/eg.oldeg/clickable_image.cgi	1970-01-01 01:00:00.000000000 +0100
@@ -1,26 +0,0 @@
-#!/usr/local/bin/perl
-
-use CGI;
-$query = new CGI;
-print $query->header;
-print $query->start_html("A Clickable Image");
-print <<END;
-<H1>A Clickable Image</H1>
-</A>
-END
-print "Sorry, this isn't very exciting!\n";
-
-print $query->startform;
-print $query->image_button('picture',"./wilogo.gif");
-print "Give me a: ",$query->popup_menu('letter',['A','B','C','D','E','W']),"\n"; # 
-print "<P>Magnification: ",$query->radio_group('magnification',['1X','2X','4X','20X']),"\n";
-print "<HR>\n";
-
-if ($query->param) {
-    print "<P>Magnification, <EM>",$query->param('magnification'),"</EM>\n";
-    print "<P>Selected Letter, <EM>",$query->param('letter'),"</EM>\n";
-    ($x,$y) = ($query->param('picture.x'),$query->param('picture.y'));
-    print "<P>Selected Position <EM>($x,$y)</EM>\n";
-}
-
-print $query->end_html;
diff -urN perl-5.10.1/lib/CGI/eg/cookie.cgi perl-5.10.1/lib/CGI/eg.oldeg/cookie.cgi
--- perl-5.10.1/lib/CGI/eg/cookie.cgi	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/eg.oldeg/cookie.cgi	1970-01-01 01:00:00.000000000 +0100
@@ -1,88 +0,0 @@
-#!/usr/local/bin/perl
-
-use CGI qw(:standard);
-
-@ANIMALS=sort qw/lion tiger bear pig porcupine ferret zebra gnu ostrich
-    emu moa goat weasel yak chicken sheep hyena dodo lounge-lizard
-    squirrel rat mouse hedgehog racoon baboon kangaroo hippopotamus
-    giraffe/;
-
-# Recover the previous animals from the magic cookie.
-# The cookie has been formatted as an associative array
-# mapping animal name to the number of animals.
-%zoo = cookie('animals');
-
-# Recover the new animal(s) from the parameter 'new_animal'
-@new = param('new_animals');
-
-# If the action is 'add', then add new animals to the zoo.  Otherwise
-# delete them.
-foreach (@new) {
-    if (param('action') eq 'Add') {
-	$zoo{$_}++;
-    } elsif (param('action') eq 'Delete') {
-	$zoo{$_}-- if $zoo{$_};
-	delete $zoo{$_} unless $zoo{$_};
-    }
-}
-
-# Add new animals to old, and put them in a cookie
-$the_cookie = cookie(-name=>'animals',
-		     -value=>\%zoo,
-		     -expires=>'+1h');
-
-# Print the header, incorporating the cookie and the expiration date...
-print header(-cookie=>$the_cookie);
-
-# Now we're ready to create our HTML page.
-print start_html('Animal crackers');
-
-print <<EOF;
-<h1>Animal Crackers</h1>
-Choose the animals you want to add to the zoo, and click "add".
-Come back to this page any time within the next hour and the list of 
-animals in the zoo will be resurrected.  You can even quit Netscape
-completely!
-<p>
-Try adding the same animal several times to the list.  Does this
-remind you vaguely of a shopping cart?
-<p>
-<em>This script only works with Netscape browsers</em>
-<p>
-<center>
-<table border>
-<tr><th>Add/Delete<th>Current Contents
-EOF
-    ;
-
-print "<tr><td>",start_form;
-print scrolling_list(-name=>'new_animals',
-		     -values=>[@ANIMALS],
-		     -multiple=>1,
-		     -override=>1,
-		     -size=>10),"<br>";
-print submit(-name=>'action',-value=>'Delete'),
-    submit(-name=>'action',-value=>'Add');
-print end_form;
-
-print "<td>";
-if (%zoo) {			# make a table
-    print "<ul>\n";
-    foreach (sort keys %zoo) {
-	print "<li>$zoo{$_} $_\n";
-    }
-    print "</ul>\n";
-} else {
-    print "<strong>The zoo is empty.</strong>\n";
-}
-print "</table></center>";
-
-print <<EOF;
-<hr>
-<ADDRESS>Lincoln D. Stein</ADDRESS><BR>
-<A HREF="./">More Examples</A>
-EOF
-    ;
-print end_html;
-
-
diff -urN perl-5.10.1/lib/CGI/eg/crash.cgi perl-5.10.1/lib/CGI/eg.oldeg/crash.cgi
--- perl-5.10.1/lib/CGI/eg/crash.cgi	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/eg.oldeg/crash.cgi	1970-01-01 01:00:00.000000000 +0100
@@ -1,6 +0,0 @@
-#!/usr/local/bin/perl
-
-use CGI::Carp qw(fatalsToBrowser);
-
-# This line invokes a fatal error message at compile time.
-foo bar baz;
diff -urN perl-5.10.1/lib/CGI/eg/customize.cgi perl-5.10.1/lib/CGI/eg.oldeg/customize.cgi
--- perl-5.10.1/lib/CGI/eg/customize.cgi	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/eg.oldeg/customize.cgi	1970-01-01 01:00:00.000000000 +0100
@@ -1,92 +0,0 @@
-#!/usr/local/bin/perl
-
-use CGI qw(:standard :html3);
-
-# Some constants to use in our form.
-@colors=qw/aqua black blue fuschia gray green lime maroon navy olive
-    purple red silver teal white yellow/;
-@sizes=("<default>",1..7);
-
-# recover the "preferences" cookie.
-%preferences = cookie('preferences');
-
-# If the user wants to change the background color or her
-# name, they will appear among our CGI parameters.
-foreach ('text','background','name','size') {
-    $preferences{$_} = param($_) || $preferences{$_};
-}
-
-# Set some defaults
-$preferences{'background'} = $preferences{'background'} || 'silver';
-$preferences{'text'} = $preferences{'text'} || 'black';
-
-# Refresh the cookie so that it doesn't expire.  This also
-# makes any changes the user made permanent.
-$the_cookie = cookie(-name=>'preferences',
-			 -value=>\%preferences,
-			 -expires=>'+30d');
-print header(-cookie=>$the_cookie);
-
-# Adjust the title to incorporate the user's name, if provided.
-$title = $preferences{'name'} ? 
-    "Welcome back, $preferences{name}!" : "Customizable Page";
-
-# Create the HTML page.  We use several of Netscape's
-# extended tags to control the background color and the
-# font size.  It's safe to use Netscape features here because
-# cookies don't work anywhere else anyway.
-print start_html(-title=>$title,
-		 -bgcolor=>$preferences{'background'},
-		 -text=>$preferences{'text'}
-		 );
-
-print basefont({SIZE=>$preferences{size}}) if $preferences{'size'} > 0;
-
-print h1($title),<<END;
-You can change the appearance of this page by submitting
-the fill-out form below.  If you return to this page any time
-within 30 days, your preferences will be restored.
-END
-    ;
-
-# Create the form
-print hr(),
-    start_form,
-    
-    "Your first name: ",
-    textfield(-name=>'name',
-	      -default=>$preferences{'name'},
-	      -size=>30),br,
-    
-    table(
-	  TR(
-	     td("Preferred"),
-	     td("Page color:"),
-	     td(popup_menu(-name=>'background',
-			   -values=>\@colors,
-			   -default=>$preferences{'background'})
-		),
-	     ),
-	  TR(
-	     td(''),
-	     td("Text color:"),
-	     td(popup_menu(-name=>'text',
-			   -values=>\@colors,
-			   -default=>$preferences{'text'})
-		)
-	     ),
-	  TR(
-	     td(''),
-	     td("Font size:"),
-	     td(popup_menu(-name=>'size',
-			   -values=>\@sizes,
-			   -default=>$preferences{'size'})
-		)
-	     )
-	  ),
-
-    submit(-label=>'Set preferences'),
-    hr;
-	   
-print a({HREF=>"/"},'Go to the home page');
-print end_html;
diff -urN perl-5.10.1/lib/CGI/eg/diff_upload.cgi perl-5.10.1/lib/CGI/eg.oldeg/diff_upload.cgi
--- perl-5.10.1/lib/CGI/eg/diff_upload.cgi	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/eg.oldeg/diff_upload.cgi	1970-01-01 01:00:00.000000000 +0100
@@ -1,68 +0,0 @@
-#!/usr/local/bin/perl
-
-$DIFF = "/usr/bin/diff";
-$PERL = "/usr/bin/perl";
-
-use CGI qw(:standard);
-use CGI::Carp;
-
-print header;
-print start_html("File Diff Example");
-print "<strong>Version </strong>$CGI::VERSION<p>";
-
-print <<EOF;
-<H1>File Diff Example</H1>
-Enter two files.  When you press "submit" their diff will be
-produced.
-EOF
-    ;
-
-# Start a multipart form.
-print start_multipart_form;
-print "File #1:",filefield(-name=>'file1',-size=>45),"<BR>\n";
-print "File #2:",filefield(-name=>'file2',-size=>45),"<BR>\n";
-print "Diff type: ",radio_group(-name=>'type',
-					-value=>['context','normal']),"<br>\n";
-print reset,submit(-name=>'submit',-value=>'Do Diff');
-print endform;
-
-# Process the form if there is a file name entered
-$file1 = param('file1');
-$file2 = param('file2');
-
-$|=1;				# for buffering
-if ($file1 && $file2) {
-    $realfile1 = tmpFileName($file1);
-    $realfile2 = tmpFileName($file2);
-    print "<HR>\n";
-    print "<H2>$file1 vs $file2</H2>\n";
-
-    print "<PRE>\n";
-    $options = "-c" if param('type') eq 'context';
-    system "$DIFF $options $realfile1 $realfile2 | $PERL -pe 's/>/&gt;/g; s/</&lt;/g;'";
-    close $file1;
-    close $file2;
-    print "</PRE>\n";
-}
-
-print <<EOF;
-<HR>
-<A HREF="../cgi_docs.html">CGI documentation</A>
-<HR>
-<ADDRESS>
-<A HREF="/~lstein">Lincoln D. Stein</A>
-</ADDRESS><BR>
-Last modified 17 July 1996
-EOF
-    ;
-print end_html;
-
-sub sanitize {
-    my $name = shift;
-    my($safe) = $name=~/([a-zA-Z0-9._~#,]+)/;
-    unless ($safe) {
-	print "<strong>$name is not a valid Unix filename -- sorry</strong>";
-	exit 0;
-    }
-    return $safe;
-}
diff -urN perl-5.10.1/lib/CGI/eg/dna_small_gif.uu perl-5.10.1/lib/CGI/eg.oldeg/dna_small_gif.uu
--- perl-5.10.1/lib/CGI/eg/dna_small_gif.uu	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/eg.oldeg/dna_small_gif.uu	1970-01-01 01:00:00.000000000 +0100
@@ -1,63 +0,0 @@
-begin 444 dna_small.gif
-M1TE&.#=A)0`J`.<``+9%&Y<R0M<F'ID\,!<07%<G1:P<0Q`A2Q`P;"L9/L$:
-M,"480N5"&RL7:4LD0T,G144[7BHL2B4?3\0I+"</)BQ.9KD0/S878\96$Z\@
-M(:\1*RL:3L0W&QL?2#4?9>@_&A$_5<I"&C`A3*,3-A`//9X<)\@Q(L`@.#\E
-M7K,R*R\T6)H++1L72T8=4207:T`G=JX..MD^&!$_;^)2$#T=7S`79AL7.A$3
-M1-=%#^,Q&QT_:C8=1!L86]\R#4M":4H76R,515HZ4"477G@T,J\;(X(@/$\7
-M."4A2N9;$"DZ6RL34-8I$34A73P86I84/\87%1`0/V,B2"0<0N!(%QPH91<6
-M2=!5$3(=73(E23`/,!L4.=$Z'-MH%>`Y#3$=2"=#59M((H88,GP\/]X^&+$R
-M$"(79"DF33(93"$86=%;&"T4/=Y"&\\A$Q4Z4!`62*T4-Q4B9+X1*BH96SP?
-M1<0D/3(F<-TM$!`=5:H.(!<64C$W?#8J3*`S(S<@3=8V%K$](QT.6Q`43AL4
-M1:$D,;<0,\X9&,8])\@=$A(U244S5U,D6Q<V;]\I&&<K/8!*.R044>=/#YH>
-M08$I1B,09S$35R(:4C0?<19$7<D^#Q`>5!()-;4702M`=;56)A`25,0K%"X<
-M83`N>K`H'HDS*1`40,M&%!<@7M,_$A<N2L)%%18E4^<M$A@=5=0Q$Q`E311*
-M2L8E&2D<7Q\A7P\80B48,%E/8[1-'J4/-"H<3"PA1$,T?Q<15R44,R,A4AL/
-M,^M4%2,07!L+,[\[&!P4520I:C(9.=54$[,2/M-)&RP?7M=(%1$J8<-,%2H@
-M4B,=51436^]2"!X<1A<44RD</>E+#%0>0S0/:4PJ9I,F-6DG420Y<"@09R,0
-M-V$R/R4M<:\H0!(H410Z:AT27&4Q9"L@;=1%(MA-$M5+#RL4+M8Z&AT<7[<:
-M(-QA&2,36R$++B(84!0:5ALO:K$A.]X?&!$84V@;/SX<6Q`;2$(B2QD21W4J
-M1=TW&@```````````````"P`````)0`J```(_@!]:(N'18\W%15T$1N'C)V?
-M0_HH,<$G9YBX!C6<3;+T@AZ-)K@\O*"!KP^$>"KVA`L3*8P3)^5ZA)@B:AH+
-M9];F7.$Q+!`!0=*<E3'5K(:EHS2N%"AP*Y(\&##H6(!A:!XU99B*H?%4IDF?
-M!8'<"-F%9I*TH8A83:*TXYD!J83D$0ICI-NE(:O8I6&FJ$64$M5$M%!3PU,F
-M2UJD"9I41E824WT2G?BV-!$(!`=,+<IF!P>.%",&P7J"9XB82L5,48F5K,:"
-M'94FU='6;!*R3T->E"%&95DR"`/6P,I0PDF)0SG8($$RJN0R`FI(H7$A2]VD
-M*^^L_6(T3U*V%XH"_AB:HDS8H$AO5@R:P,8.I%^.:*AC(>Z!'":6RC`1L@W-
-M%1Q/,%(.'5+1`<D^74R@P2#?T*'/$"%@\(L5Y?RAB!SO3#*,-6CL44\4]C1#
-MR0Q3C&&"!AH08@(#:Y2C@`&1---,.#)\T84=R##`0",H++8#)34,@X80R:"`
-M0A<]?'#.!";`TDH.8QBB0354A!,*)WI0\<D\YJRQ3PE[V",(.D#48$T9GO22
-MA0.BC,)'*]3TP,`^\_#QA0P@>`/"*]=<HX\3"C!BAQV%5",$+Z0,0X,UL3SB
-M#B[NN$'/,A&,$L,Y[-BASR(@<**("E^,0(<&;[QA0@^,3%",#2S8H,01_LX0
-M`(0:W%`@13#TN+'#&LK@0$T0VER##50*Q/%-%%&H$`0#K7"`!B^X/`),()F0
-M0PNT[K#BRBS1-!("`^=,$8`D="B`QRW?1**+-I?(X$@(L(R2AQ8+Y,*#-*YX
-MH(00'1Q!CSI,U'!%)^_%4(X&FUB@01$.@*!#$I?4D48I&1BA!2*HD%))(.+T
-MYTEOT3B#PB/U4(,$%QD0(<\QX^CRBC=)@%`!&+:<<TH&M*C1"RJX'-'.'`YX
-M<H0@<)#"0CX+I%`*-%:4L@XFS`#[11M?U-))"&RP84LWZL!A1A^YH.*)!)3<
-MHXX6L]P3"!I`H/!`*>90`PD.F'3SR@-AG)`&_A=3'"**#[J(P<<I@YCA2@32
-M!,*+Q9H`(XT2'O2RS"CGS.U9!K>0^C0&S/#1""(ZI)'&*6,,$842N%Q!@3NK
-M"R'%%4KP0D(Q?"`S!3)<I#!!".68$T(IMHP#>BVE(/$+)#-80<PTLBRP^@$>
-M<+,`-[QH$LP+0_P!1C>=S("!,N>8XP<8H6131!B;3`#&#)"DTH(L5#P0S#W+
-MQ)*`$K1HHD4^;E!2QP%:B``&4H$,/Y2C$Y*(1%0(00A)@```77B"*$0@#3>P
-MP&PU4`,^H!","P!!$')0P^H6((I5L"$'.;``';[Q!@-\PP"<B$<]EG"(#*C"
-M%-(@0":\L0U?D&`#_L50@33.(`4M4``=&4@'+-9!!P9JP`#9T$4H=*$+!#1B
-M'3A(`SYH`81'B.,(XJ@"":0(CDRPH@/<"$88V+"%$N#A&)MPX0N2H`L]C&,<
-MEW"$%6:0BCV@XPIH>$0?)M$`<92!%OG8Q3#@(`U2C*)%9-!`&`K`!!EP0@80
-M2,0M;I$.:"C#"D.@P#UJ``]GT"*,K%B&*0+!@TFH8VV*0$(:_/`)?7@#'.'0
-M@R[H8``\:&`,=NC"*"B@!2TTHP5]N((TEH&`<)B"!PU`0RQ(P8MNS``9K6@%
-M'W31AG%$(BZ2&((PA-&#'I"A&`F8!DD\\`H6-,.,X'B'%,+R#FX4`PS&_L!$
-M.4R0#7W<0@%O2,07$($#9@C3"%C8P!5H88\]J$,"-E!;(.X@C5T<`!65V,40
-M,'&(0C!"`1JP@"3TH`T9=&,5JRC$-]+1`U%TP@@[^,$>Z$&*0%1A%XFK`BFD
-MX0L6Y"(#A_A$#[JPC@%\@1@02`(SJ#&&.`A@'\&$!AALX(4Y="`/TA"",UA!
-M@%W<8!*\$`$@C%""+G1A"9AP!"<>9@ME*)$0F\C!$I8`B3\TP@%'@$(QH$`"
-M)8@#'(B0ACB`P`,@%&,'9"##)S`1!&)\`0)^&,,^+$`("QC"#D\X!":HX0!<
-ML(`&-O!%,&H@BS#F0AI'`!LO^"`,/OS!%KJ0_H0HEA`E27Q#%T%X0"%"@`1E
-M2,`!:F!%+Q#A!G)40A!HP`4OFK`#-13#`?I(QCW38(Q/9&``%0#!);01BE>$
-M@!TZNL81$G`!-]2!&&5@A1N&T0Q<,$$$%*!``BR1A5$PPPH<74$%]*`#$.RA
-M`(VP@#`X$(`7``(%T=@`.5Q`C@:0`P[)D$4'$H`."MB#"908Q=X@,01B9$(7
-MG'A%`#8!"QSL@PUAL,0==M"")CQCP4)0QQUDP806H&,!T]A!`EH@AC2P`P,^
-MT`,*NN%-&&T!&L@X!!Y^<(4.D(,%E>A`,T20C#IXL`6-:,`5F+"#!W"@'%OH
-MA`IJ$5(#;`(;AV/'FA103(EV+(,>GHB&&ZJ`!D'<X0[-N$(N@)$+4$C@`<(`
-M$(&/<8Q;7$,1UT"``+>P!57`X1F9D`4<W$`"4MP@$ZYX\B-"004Y2$`.HT@%
-M)@IAB#><0!]FB(<I.(&`(7P"%GPPQ3)F`0YB0"$0@8"")L!Q!RH`8A&AL,8L
-BR!$$,@@#&5OX!1V.\85XA.,.,A##!T2!AP@LXP#;"`@`.P``
-end
diff -urN perl-5.10.1/lib/CGI/eg/file_upload.cgi perl-5.10.1/lib/CGI/eg.oldeg/file_upload.cgi
--- perl-5.10.1/lib/CGI/eg/file_upload.cgi	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/eg.oldeg/file_upload.cgi	1970-01-01 01:00:00.000000000 +0100
@@ -1,71 +0,0 @@
-#!/usr/local/bin/perl -w
-
-use strict 'refs';
-use lib '..';
-use CGI qw(:standard);
-use CGI::Carp qw/fatalsToBrowser/;
-
-print header();
-print start_html("File Upload Example");
-print strong("Version "),$CGI::VERSION,p;
-
-print h1("File Upload Example"),
-    'This example demonstrates how to prompt the remote user to
-    select a remote file for uploading. ',
-    strong("This feature only works with Netscape 2.0 or greater, or IE 4.0 or greater."),
-    p,
-    'Select the ',cite('browser'),' button to choose a text file
-    to upload.  When you press the submit button, this script
-    will count the number of lines, words, and characters in
-    the file.';
-
-my @types = ('count lines','count words','count characters');
-
-# Start a multipart form.
-print start_multipart_form(),
-    "Enter the file to process:",
-    filefield('filename','',45),
-    br,
-    checkbox_group('count',\@types,\@types),
-    p,
-    reset,submit('submit','Process File'),
-    endform;
-
-# Process the form if there is a file name entered
-if (my $file = param('filename')) {
-    my %stats;
-    my $tmpfile=tmpFileName($file);
-    my $mimetype = uploadInfo($file)->{'Content-Type'} || '';
-    print hr(),
-          h2($file),
-          h3($tmpfile),
-          h4("MIME Type:",em($mimetype));
-
-    my($lines,$words,$characters,@words) = (0,0,0,0);
-    while (<$file>) {
-	$lines++;
-	$words += @words=split(/\s+/);
-	$characters += length($_);
-    }
-    close $file;
-    grep($stats{$_}++,param('count'));
-    if (%stats) {
-	print strong("Lines: "),$lines,br if $stats{'count lines'};
-	print strong("Words: "),$words,br if $stats{'count words'};
-	print strong("Characters: "),$characters,br if $stats{'count characters'};
-    } else {
-	print strong("No statistics selected.");
-    }
-}
-
-# print cite("URL parameters: "),url_param();
-
-print hr(),
-    a({href=>"../cgi_docs.html"},"CGI documentation"),
-    hr,
-    address(
-	    a({href=>'/~lstein'},"Lincoln D. Stein")),
-    br,
-    'Last modified July 17, 1996',
-    end_html;
-
diff -urN perl-5.10.1/lib/CGI/eg/frameset.cgi perl-5.10.1/lib/CGI/eg.oldeg/frameset.cgi
--- perl-5.10.1/lib/CGI/eg/frameset.cgi	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/eg.oldeg/frameset.cgi	1970-01-01 01:00:00.000000000 +0100
@@ -1,81 +0,0 @@
-#!/usr/local/bin/perl
-
-use CGI;
-$query = new CGI;
-print $query->header;
-$TITLE="Frameset Example";
-
-# We use the path information to distinguish between calls
-# to the script to:
-# (1) create the frameset
-# (2) create the query form
-# (3) create the query response
-
-$path_info = $query->path_info;
-
-# If no path information is provided, then we create 
-# a side-by-side frame set
-if (!$path_info) {
-    &print_frameset;
-    exit 0;
-}
-
-# If we get here, then we either create the query form
-# or we create the response.
-&print_html_header;
-&print_query if $path_info=~/query/;
-&print_response if $path_info=~/response/;
-&print_end;
-
-
-# Create the frameset
-sub print_frameset {
-    $script_name = $query->script_name;
-    print <<EOF;
-<html><head><title>$TITLE</title></head>
-<frameset cols="50,50">
-<frame src="$script_name/query" name="query">
-<frame src="$script_name/response" name="response">
-</frameset>
-EOF
-    ;
-    exit 0;
-}
-
-sub print_html_header {
-    print $query->start_html($TITLE);
-}
-
-sub print_end {
-    print qq{<P><hr><A HREF="../index.html" TARGET="_top">More Examples</A>};
-    print $query->end_html;
-}
-
-sub print_query {
-    $script_name = $query->script_name;
-    print "<H1>Frameset Query</H1>\n";
-    print $query->startform(-action=>"$script_name/response",-TARGET=>"response");
-    print "What's your name? ",$query->textfield('name');
-    print "<P>What's the combination?<P>",
-    $query->checkbox_group(-name=>'words',
-			       -values=>['eenie','meenie','minie','moe']);
-
-    print "<P>What's your favorite color? ",
-    $query->popup_menu(-name=>'color',
-		       -values=>['red','green','blue','chartreuse']),
-    "<P>";
-    print $query->submit;
-    print $query->endform;
-}
-
-sub print_response {
-    print "<H1>Frameset Result</H1>\n";
-    unless ($query->param) {
-	print "<b>No query submitted yet.</b>";
-	return;
-    }
-    print "Your name is <EM>",$query->param(name),"</EM>\n";
-    print "<P>The keywords are: <EM>",join(", ",$query->param(words)),"</EM>\n";
-    print "<P>Your favorite color is <EM>",$query->param(color),"</EM>\n";
-}
-
diff -urN perl-5.10.1/lib/CGI/eg/index.html perl-5.10.1/lib/CGI/eg.oldeg/index.html
--- perl-5.10.1/lib/CGI/eg/index.html	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/eg.oldeg/index.html	1970-01-01 01:00:00.000000000 +0100
@@ -1,119 +0,0 @@
-<HTML> <HEAD>
-<TITLE>More Examples of Scripts Created with CGI.pm</TITLE>
-</HEAD>
-
-<BODY>
-<H1>More Examples of Scripts Created with CGI.pm</H1>
-
-<H2> Basic Non Sequitur Questionnaire</H2>
-<UL>
-  <LI> <A HREF="tryit.cgi">Try the script</A>
-  <LI> <A HREF="tryit.txt">Look at its source code</A>
-</UL>
-
-<H2> Advanced Non Sequitur Questionnaire</H2>
-<UL>
-  <LI> <A HREF="monty.cgi">Try the script</A>
-  <LI> <A HREF="monty.txt">Look at its source code</A>
-</UL>
-
-<H2> Save and restore the state of a form to a file</H2>
-<UL>
-  <LI> <A HREF="save_state.cgi">Try the script</A>
-  <LI> <A HREF="save_state.txt">Look at its source code</A>
-</UL>
-
-<H2> Server Push</H2>
-<ul>
-  <li><a href="nph-multipart.cgi">Try the script</a>
-  <li><a href="nph-multipart.txt">Look at its source code</a>
-</ul>
-
-<H2> Read the coordinates from a clickable image map</H2>
-<UL>
-  <LI> <A HREF="clickable_image.cgi">Try the script</A>
-  <LI> <A HREF="clickable_image.txt">Look at its source code</A>
-</UL>
-
-<H2> Multiple independent forms on the same page</H2>
-<UL>
-  <LI> <A HREF="multiple_forms.cgi">Try the script</A>
-  <LI> <A HREF="multiple_forms.txt">Look at its source code</A>
-</UL>
-
-<H2> How to maintain state on a page with internal links</H2>
-<UL>
-  <LI> <A HREF="internal_links.cgi">Try the script</A>
-  <LI> <A HREF="internal_links.txt">Look at its source code</A>
-</UL>
-
-<h2>Echo fatal script errors to the browser</h2>
-<em>This script deliberately generates a compile-time error.</em>
-<ul>
-  <li><a href="crash.cgi">Try the script</a>
-  <li><a href="crash.txt">Look at its source code</a>
-</ul>
-
-<EM>The Following Scripts Work with Netscape Navigator 2.0 and higher,
-or Internet Explorer 3.0 and higher</EM>
-
-<H2> Prompt for a file to upload and process it</H2>
-<UL>
-  <LI> <A HREF="file_upload.cgi">Try the script</A>
-  <LI> <A HREF="file_upload.txt">Look at its source code</A>
-</UL>
-
-<h2> A Continuously-Updated Page using Server Push</h2>
-<ul>
-  <li><a href="nph-clock.cgi">Try the script</a>
-  <li><a href="nph-clock.txt">Look at its source code</a>
-</ul>
-
-<h2>Compute the "diff" between two uploaded files</h2>
-<ul>
-  <li><a href="diff_upload.cgi">Try the script</a>
-  <li><a href="diff_upload.txt">Look at its source code</a>
-</ul>
-
-<h2>Maintain state over a long period with a cookie</h2>
-<ul>
-  <li><a href="cookie.cgi">Try the script</a>
-  <li><a href="cookie.txt">Look at its source code</a>
-</ul>
-
-<h2>Permanently customize the appearance of a page with a cookie</h2>
-<ul>
-  <li><a href="customize.cgi">Try the script</a>
-  <li><a href="customize.txt">Look at its source code</a>
-</ul>
-
-<h2> Popup the response in a new window</h2>
-<ul>
-  <li><a href="popup.cgi">Try the script</a>
-  <li><a href="popup.txt">Look at its source code</a>
-</ul>
-
-<h2> Side-by-side form and response using frames</h2>
-<ul>
-  <li><a href="frameset.cgi">Try the script</a>
-  <li><a href="frameset.txt">Look at its source code</a>
-</ul>
-
-<h2>Verify the Contents of a fill-out form with JavaScript</h2>
-<ul>
-  <li><a href="javascript.cgi">Try the script</a>
-  <li><a href="javascript.txt">Look at its source code</a>
-</ul>
-
-<HR>
-<MENU>
-  <LI> <A HREF="../cgi_docs.html">CGI.pm documentation</A>
-  <LI> <A HREF="../CGI.pm.tar.gz">Download the CGI.pm distribution</A>
-</MENU>
-<HR>
-<ADDRESS>Lincoln D. Stein, lstein@genome.wi.mit.edu<br>
-<a href="/">Whitehead Institute/MIT Center for Genome Research</a></ADDRESS>
-<!-- hhmts start -->
-Last modified: Wed Jun 23 15:31:47 EDT 1999
-<!-- hhmts end -->
-</BODY> </HTML>
diff -urN perl-5.10.1/lib/CGI/eg/internal_links.cgi perl-5.10.1/lib/CGI/eg.oldeg/internal_links.cgi
--- perl-5.10.1/lib/CGI/eg/internal_links.cgi	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/eg.oldeg/internal_links.cgi	1970-01-01 01:00:00.000000000 +0100
@@ -1,33 +0,0 @@
-#!/usr/local/bin/perl
-
-use CGI;
-$query = new CGI;
-
-# We generate a regular HTML file containing a very long list
-# and a popup menu that does nothing except to show that we
-# don't lose the state information.
-print $query->header;
-print $query->start_html("Internal Links Example");
-print "<H1>Internal Links Example</H1>\n";
-print "Click <cite>Submit Query</cite> to create a state.  Then scroll down and",
-    " click on any of the <cite>Jump to top</cite> links.  This is not very exciting.";
-
-print "<A NAME=\"start\"></A>\n"; # an anchor point at the top
-
-# pick a default starting value;
-$query->param('amenu','FOO1') unless $query->param('amenu');
-
-print $query->startform;
-print $query->popup_menu('amenu',[('FOO1'..'FOO9')]);
-print $query->submit,$query->endform;
-
-# We create a long boring list for the purposes of illustration.
-$myself = $query->self_url;
-print "<OL>\n";
-for (1..100) {
-    print qq{<LI>List item #$_ <A HREF="$myself#start">Jump to top</A>\n};
-}
-print "</OL>\n";
-
-print $query->end_html;
-
diff -urN perl-5.10.1/lib/CGI/eg/javascript.cgi perl-5.10.1/lib/CGI/eg.oldeg/javascript.cgi
--- perl-5.10.1/lib/CGI/eg/javascript.cgi	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/eg.oldeg/javascript.cgi	1970-01-01 01:00:00.000000000 +0100
@@ -1,105 +0,0 @@
-#!/usr/local/bin/perl
-
-# This script illustrates how to use JavaScript to validate fill-out
-# forms.
-use CGI qw(:standard);
-
-# Here's the javascript code that we include in the document.
-$JSCRIPT=<<EOF;
-    // validate that the user is the right age.  Return
-    // false to prevent the form from being submitted.
-    function validateForm() {
-	var today = new Date();
-	var birthday = validateDate(document.form1.birthdate);
-	if (birthday == 0) {
-	    document.form1.birthdate.focus()
-	    document.form1.birthdate.select();
-	    return false;
-	}
-	var milliseconds = today.getTime()-birthday;
-	var years = milliseconds/(1000 * 60 * 60 * 24 * 365.25);
-	if ((years > 20) || (years < 5)) {
-	    alert("You must be between the ages of 5 and 20 to submit this form");
-	    document.form1.birthdate.focus();
-	    document.form1.birthdate.select();
-	    return false;
-	}
-	// Since we've calculated the age in years already,
-	// we might as well send it up to our CGI script.
-	document.form1.age.value=Math.floor(years);
-	return true;
-    }
-
-   // make sure that the contents of the supplied
-   // field contain a valid date.
-   function validateDate(element) {
-       var date = Date.parse(element.value);
-       if (0 == date) { 
-	   alert("Please enter date in format MMM DD, YY");
-	   element.focus();
-	   element.select();
-       }
-       return date;
-   }
-
-   // Compliments, compliments
-    function doPraise(element) {
-	if (element.checked) {
-	    self.status=element.value + " is an excellent choice!";
-	    return true;
-	} else {
-	    return false;
-	}
-    }
-
-    function checkColor(element) {
-	var color = element.options[element.selectedIndex].text;
-	if (color == "blonde") {
-	    if (confirm("Is it true that blondes have more fun?"))
-		alert("Darn.  That leaves me out.");
-	} else
-	    alert(color + " is a fine choice!");
-    }
-EOF
-    ;
-
-# here's where the execution begins
-print header;
-print start_html(-title=>'Personal Profile',-script=>$JSCRIPT);
-
-print h1("Big Brother Wants to Know All About You"),
-    strong("Note: "),"This page uses JavaScript and requires ",
-    "Netscape 2.0 or higher to do anything special.";
-
-&print_prompt();
-print hr;
-&print_response() if param;
-print end_html;
-
-sub print_prompt {
-    print start_form(-name=>'form1',
-		     -onSubmit=>"return validateForm()"),"\n";
-    print "Birthdate (e.g. Jan 3, 1972): ", 
-          textfield(-name=>'birthdate',
-			-onBlur=>"validateDate(this)"),"<p>\n";
-    print "Sex: ",radio_group(-name=>'gender',
-				  -value=>[qw/male female/],
-				  -onClick=>"doPraise(this)"),"<p>\n";
-    print "Hair color: ",popup_menu(-name=>'color',
-					-value=>[qw/brunette blonde red gray/],
-					-default=>'red',
-					-onChange=>"checkColor(this)"),"<p>\n";
-    print hidden(-name=>'age',-value=>0);
-    print submit();
-    print end_form;
-}
-
-sub print_response {
-    import_names('Q');
-    print h2("Your profile"),
-	"You claim to be a ",b($Q::age)," year old ",b($Q::color,$Q::gender),".",
-	"You should be ashamed of yourself for lying so ",
-	"blatantly to big brother!",
-	hr;
-}
-
diff -urN perl-5.10.1/lib/CGI/eg/make_links.pl perl-5.10.1/lib/CGI/eg.oldeg/make_links.pl
--- perl-5.10.1/lib/CGI/eg/make_links.pl	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/eg.oldeg/make_links.pl	1970-01-01 01:00:00.000000000 +0100
@@ -1,8 +0,0 @@
-#!/usr/local/bin/perl
-
-# this is just a utility for creating symlinks from *.txt to *.cgi
-# for documentation purposes.
-foreach (<*.cgi>) {
-    ($target=$_)=~s/cgi$/txt/;
-    symlink $_,$target
-}
diff -urN perl-5.10.1/lib/CGI/eg/monty.cgi perl-5.10.1/lib/CGI/eg.oldeg/monty.cgi
--- perl-5.10.1/lib/CGI/eg/monty.cgi	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/eg.oldeg/monty.cgi	1970-01-01 01:00:00.000000000 +0100
@@ -1,84 +0,0 @@
-#!/usr/local/bin/perl
-     
-use CGI;
-use CGI::Carp qw/fatalsToBrowser/;
- 
-$query = new CGI;
-
-print $query->header;
-print $query->start_html("Example CGI.pm Form");
-print "<H1> Example CGI.pm Form</H1>\n";
-&print_prompt($query);
-&do_work($query);
-&print_tail;
-print $query->end_html;
- 
-sub print_prompt {
-   my($query) = @_;
- 
-   print $query->start_form;
-   print "<EM>What's your name?</EM><BR>";
-   print $query->textfield('name');
-   print $query->checkbox('Not my real name');
- 
-   print "<P><EM>Where can you find English Sparrows?</EM><BR>";
-   print $query->checkbox_group(
-				-name=>'Sparrow locations',
-				-Values=>[England,France,Spain,Asia,Hoboken],
-				-linebreak=>'yes',
-				-defaults=>[England,Asia]);
- 
-   print "<P><EM>How far can they fly?</EM><BR>",
-   $query->radio_group(
-		       -name=>'how far',
-		       -Values=>['10 ft','1 mile','10 miles','real far'],
-		       -default=>'1 mile');
-   
-   print "<P><EM>What's your favorite color?</EM>  ";
-   print $query->popup_menu(-name=>'Color',
-			    -Values=>['black','brown','red','yellow'],
-			    -default=>'red');
- 
-   print $query->hidden('Reference','Monty Python and the Holy Grail');
- 
-   print "<P><EM>What have you got there?</EM><BR>";
-   print $query->scrolling_list(
-				-name=>'possessions',
-				-Values=>['A Coconut','A Grail','An Icon',
-					  'A Sword','A Ticket'],
-				-size=>5,
-				-multiple=>'true');
- 
-   print "<P><EM>Any parting comments?</EM><BR>";
-   print $query->textarea(-name=>'Comments',
-			  -rows=>10,
-			  -columns=>50);
-   
-   print "<P>",$query->reset;
-   print $query->submit('Action','Shout');
-   print $query->submit('Action','Scream');
-   print $query->endform;
-   print "<HR>\n";
- 	}
- 
-sub do_work {
-    my($query) = @_;
-    my(@values,$key);
-
-    print "<H2>Here are the current settings in this form</H2>";
-
-    foreach $key ($query->param) {
-	print "<STRONG>$key</STRONG> -> ";
-	@values = $query->param($key);
-	print join(", ",@values),"<BR>\n";
-    }
-}
- 
-sub print_tail {
-    print <<END;
-<HR>
-<ADDRESS>Lincoln D. Stein</ADDRESS><BR>
-<A HREF="/">Home Page</A>
-END
-    ;
-}
diff -urN perl-5.10.1/lib/CGI/eg/multiple_forms.cgi perl-5.10.1/lib/CGI/eg.oldeg/multiple_forms.cgi
--- perl-5.10.1/lib/CGI/eg/multiple_forms.cgi	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/eg.oldeg/multiple_forms.cgi	1970-01-01 01:00:00.000000000 +0100
@@ -1,54 +0,0 @@
-#!/usr/local/bin/perl
-
-use CGI;
-
-$query = new CGI;
-print $query->header;
-print $query->start_html('Multiple Forms');
-print "<H1>Multiple Forms</H1>\n";
-
-# Print the first form
-print $query->startform;
-$name = $query->remote_user || 'anonymous@' . $query->remote_host;
-
-print "What's your name? ",$query->textfield('name',$name,50);
-print "<P>What's the combination?<P>",
-        $query->checkbox_group('words',['eenie','meenie','minie','moe']);
-print "<P>What's your favorite color? ",
-        $query->popup_menu('color',['red','green','blue','chartreuse']),
-	"<P>";
-print $query->submit('form_1','Send Form 1');
-print $query->endform;
-
-# Print the second form
-print "<HR>\n";
-print $query->startform;
-print "Some radio buttons: ",$query->radio_group('radio buttons',
-						 [qw{one two three four five}],'three'),"\n";
-print "<P>What's the password? ",$query->password_field('pass','secret');
-print $query->defaults,$query->submit('form_2','Send Form 2'),"\n";
-print $query->endform;
-
-print "<HR>\n";
-
-$query->import_names('Q');
-if ($Q::form_1) {
-    print "<H2>Form 1 Submitted</H2>\n";
-    print "Your name is <EM>$Q::name</EM>\n";
-    print "<P>The combination is: <EM>{",join(",",@Q::words),"}</EM>\n";
-    print "<P>Your favorite color is <EM>$Q::color</EM>\n";
-} elsif ($Q::form_2) {
-    print <<EOF;
-<H2>Form 2 Submitted</H2>
-<P>The value of the radio buttons is <EM>$Q::radio_buttons</EM>
-<P>The secret password is <EM>$Q::pass</EM>
-EOF
-    ;
-}
-print qq{<P><A HREF="./">Other examples</A>};
-print qq{<P><A HREF="../cgi_docs.html">Go to the documentation</A>};
-
-print $query->end_html;
-
-
-
diff -urN perl-5.10.1/lib/CGI/eg/nph-clock.cgi perl-5.10.1/lib/CGI/eg.oldeg/nph-clock.cgi
--- perl-5.10.1/lib/CGI/eg/nph-clock.cgi	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/eg.oldeg/nph-clock.cgi	1970-01-01 01:00:00.000000000 +0100
@@ -1,18 +0,0 @@
-#!/usr/local/bin/perl -w
-
-use CGI::Push qw(:standard :html3);
-
-do_push(-next_page=>\&draw_time,-delay=>1);
-
-sub draw_time {
-    my $time = `/bin/date`;
-    return start_html('Tick Tock'),
-           div({-align=>CENTER},
-	       h1('Virtual Clock'),
-	       h2($time)
-	       ),
-	   hr,
-	   a({-href=>'index.html'},'More examples'),
-           end_html();
-}
-
diff -urN perl-5.10.1/lib/CGI/eg/nph-multipart.cgi perl-5.10.1/lib/CGI/eg.oldeg/nph-multipart.cgi
--- perl-5.10.1/lib/CGI/eg/nph-multipart.cgi	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/eg.oldeg/nph-multipart.cgi	1970-01-01 01:00:00.000000000 +0100
@@ -1,10 +0,0 @@
-#!/usr/local/bin/perl
-use CGI qw/:push -nph/;
-$| = 1;
-print multipart_init(-boundary=>'----------------here we go!');
-while (1) {
-    print multipart_start(-type=>'text/plain'),
-    "The current time is ",scalar(localtime),"\n",
-    multipart_end;
-    sleep 1;
-}
diff -urN perl-5.10.1/lib/CGI/eg/popup.cgi perl-5.10.1/lib/CGI/eg.oldeg/popup.cgi
--- perl-5.10.1/lib/CGI/eg/popup.cgi	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/eg.oldeg/popup.cgi	1970-01-01 01:00:00.000000000 +0100
@@ -1,32 +0,0 @@
-#!/usr/local/bin/perl
-
-use CGI;
-$query = new CGI;
-print $query->header;
-print $query->start_html('Popup Window');
-
-
-if (!$query->param) {
-    print "<H1>Ask your Question</H1>\n";
-    print $query->startform(-target=>'_new');
-    print "What's your name? ",$query->textfield('name');
-    print "<P>What's the combination?<P>",
-    $query->checkbox_group(-name=>'words',
-			   -values=>['eenie','meenie','minie','moe'],
-			   -defaults=>['eenie','moe']);
-
-    print "<P>What's your favorite color? ",
-    $query->popup_menu(-name=>'color',
-		       -values=>['red','green','blue','chartreuse']),
-    "<P>";
-    print $query->submit;
-    print $query->endform;
-
-} else {
-    print "<H1>And the Answer is...</H1>\n";
-    print "Your name is <EM>",$query->param(name),"</EM>\n";
-    print "<P>The keywords are: <EM>",join(", ",$query->param(words)),"</EM>\n";
-    print "<P>Your favorite color is <EM>",$query->param(color),"</EM>\n";
-}
-print qq{<P><A HREF="cgi_docs.html">Go to the documentation</A>};
-print $query->end_html;
diff -urN perl-5.10.1/lib/CGI/eg/RunMeFirst perl-5.10.1/lib/CGI/eg.oldeg/RunMeFirst
--- perl-5.10.1/lib/CGI/eg/RunMeFirst	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/eg.oldeg/RunMeFirst	1970-01-01 01:00:00.000000000 +0100
@@ -1,36 +0,0 @@
-#!/usr/local/bin/perl
-
-# Make a world-writeable directory for saving state.
-$ww = 'WORLD_WRITABLE';
-unless (-w $ww) {
-    $u = umask 0;
-    mkdir $ww, 0777;
-    umask $u;
-}
-
-# Decode the sample image.
-for $uu (<*.uu>) {
-    unless (open UU, "<$uu") { warn "Can't open $uu: $!\n"; next }
-    while (<UU>) {
-        chomp;
-	if (/^begin\s+\d+\s+(.+)$/) {
-	    $bin = $1;
-	    last;
-	}
-    }
-    unless (open BIN, "> $bin") { warn "Can't create $bin: $!\n"; next }
-    binmode BIN;
-    while (<UU>) {
-	chomp;
-	last if /^end/;
-	print BIN unpack "u", $_;
-    }
-    close BIN;
-    close UU;
-}
-
-# Create symlinks from *.txt to *.cgi for documentation purposes.
-foreach (<*.cgi>) {
-    ($target = $_) =~ s/cgi$/txt/i;
-    symlink $_, $target unless -e $target;
-}
diff -urN perl-5.10.1/lib/CGI/eg/save_state.cgi perl-5.10.1/lib/CGI/eg.oldeg/save_state.cgi
--- perl-5.10.1/lib/CGI/eg/save_state.cgi	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/eg.oldeg/save_state.cgi	1970-01-01 01:00:00.000000000 +0100
@@ -1,67 +0,0 @@
-#!/usr/local/bin/perl
-
-use CGI;
-$query = new CGI;
-
-print $query->header;
-print $query->start_html("Save and Restore Example");
-print "<H1>Save and Restore Example</H1>\n";
-
-# Here's where we take action on the previous request
-&save_parameters($query)              if $query->param('action') eq 'SAVE';
-$query = &restore_parameters($query)  if $query->param('action') eq 'RESTORE';
-
-# Here's where we create the form
-print $query->start_multipart_form;
-print "Popup 1: ",$query->popup_menu('popup1',[qw{red green purple magenta orange chartreuse brown}]),"\n";
-print "Popup 2: ",$query->popup_menu('popup2',[qw{lion tiger bear zebra potto wildebeest frog emu gazelle}]),"\n";
-print "<P>";
-$default_name = $query->remote_addr . '.sav';
-print "Save/restore state from file: ",$query->textfield('savefile',$default_name),"\n";
-print "<P>";
-print $query->submit('action','SAVE'),$query->submit('action','RESTORE');
-print "<P>",$query->defaults;
-print $query->endform;
-
-# Here we print out a bit at the end
-print $query->end_html;
-
-sub save_parameters {
-    local($query) = @_;
-    local($filename) = &clean_name($query->param('savefile'));
-    if (open(FILE,">$filename")) {
-	$query->save(FILE);
-	close FILE;
-	print "<STRONG>State has been saved to file $filename</STRONG>\n";
-	print "<P>If you remember this name you can restore the state later.\n";
-    } else {
-	print "<STRONG>Error:</STRONG> couldn't write to file $filename: $!\n";
-    }
-}
-
-sub restore_parameters {
-    local($query) = @_;
-    local($filename) = &clean_name($query->param('savefile'));
-    if (open(FILE,$filename)) {
-	$query = new CGI(FILE);  # Throw out the old query, replace it with a new one
-	close FILE;
-	print "<STRONG>State has been restored from file $filename</STRONG>\n";
-    } else {
-	print "<STRONG>Error:</STRONG> couldn't restore file $filename: $!\n";
-    }
-    return $query;
-}
-
-
-# Very important subroutine -- get rid of all the naughty
-# metacharacters from the file name. If there are, we
-# complain bitterly and die.
-sub clean_name {
-   local($name) = @_;
-   unless ($name=~/^[\w\._\-]+$/) {
-      print "<STRONG>$name has naughty characters.  Only ";
-      print "alphanumerics are allowed.  You can't use absolute names.</STRONG>";
-      die "Attempt to use naughty characters";
-   }
-   return "WORLD_WRITABLE/$name";
-}
diff -urN perl-5.10.1/lib/CGI/eg/tryit.cgi perl-5.10.1/lib/CGI/eg.oldeg/tryit.cgi
--- perl-5.10.1/lib/CGI/eg/tryit.cgi	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/eg.oldeg/tryit.cgi	1970-01-01 01:00:00.000000000 +0100
@@ -1,37 +0,0 @@
-#!/usr/local/bin/perl
-
-use CGI ':standard';
-
-print header;
-print start_html('A Simple Example'),
-    h1('A Simple Example'),
-    start_form,
-    "What's your name? ",textfield('name'),
-    p,
-    "What's the combination?",
-    p,
-    checkbox_group(-name=>'words',
-		   -values=>['eenie','meenie','minie','moe'],
-		   -defaults=>['eenie','minie']),
-    p,
-    "What's your favorite color? ",
-    popup_menu(-name=>'color',
-	       -values=>['red','green','blue','chartreuse']),
-    p,
-    submit,
-    end_form,
-    hr;
-
-if (param()) {
-    print 
-	"Your name is: ",em(param('name')),
-	p,
-	"The keywords are: ",em(join(", ",param('words'))),
-	p,
-	"Your favorite color is: ",em(param('color')),
-	hr;
-}
-print a({href=>'../cgi_docs.html'},'Go to the documentation');
-print end_html;
-
-
diff -urN perl-5.10.1/lib/CGI/eg/wilogo_gif.uu perl-5.10.1/lib/CGI/eg.oldeg/wilogo_gif.uu
--- perl-5.10.1/lib/CGI/eg/wilogo_gif.uu	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/lib/CGI/eg.oldeg/wilogo_gif.uu	1970-01-01 01:00:00.000000000 +0100
@@ -1,13 +0,0 @@
-begin 444 wilogo.gif
-M1TE&.#=A7@!$`(```'X2F?___RP`````7@!$```"_D2.J<#MKF)ZU,A3,[OO
-M(IUY']A%9"6AW$F)+#2]Y:BNLF6_\;WMH<?#I72^VP+D"@*)F&"O25KRDM&B
-M[%C-7;4_J)*6'4ZE&O`W8"1OQ5UGPWRBIKDPM!MW9J]-[;LUKL;$5W.'YQ3(
-M(O<&-^>F*(A55\BX%UEI^;<VB0BH1RFX2=<IELE4^*0'N?-I>OJ8N%(*Z^4G
-M.OJJ>8HZ.(>;JRMD><E[!KQHB^3;:APL6Z8\RKPK/)O:*-WLW&7]*\UYR]J)
-M?<P=1MR-_6VN76,WGAV^32W^3CZ_SCY3;W__C-R^CU^\%M#T!9PVL(ZZ&>X"
-M%A1XSM]!A?T8/C0T$1XMJG\B&G+,"-&C/(VS0(842;`)M'S>_OE8F#"=2S#*
-M8LHLAS'D1Y,42UGY9O,F-T:X@@JEE@D1RW>/D@8R.DZ-+*E0CQ:9JJ5JU!SQ
-MR&BU2D.;E*4'ER0TNY%G2A/Y.G[=VG%81+5K_UG$21<A6;=YP9'5B++O7:@7
-M\]J5]]?DX7:)%<]5%=B/55>-GQW55;$8L\RW6J8-9>QM7<^A/SMZK!ESY$,+
-(KPA.EJ```#L`
-end
diff -urN perl-5.10.1/lib/CGI/examples.newex/caution.xbm perl-5.10.1/lib/CGI/examples/caution.xbm
--- perl-5.10.1/lib/CGI/examples.newex/caution.xbm	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/examples/caution.xbm	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,12 @@
+#define caution_width 32
+#define caution_height 32
+static char caution_bits[] = {
+ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x00,0x00,0x00,0x10,0x01,
+ 0x00,0x00,0x08,0x07,0x00,0x00,0x08,0x0e,0x00,0x00,0x04,0x0e,0x00,0x00,0x04,
+ 0x1c,0x00,0x00,0x02,0x1c,0x00,0x00,0xe2,0x38,0x00,0x00,0xf1,0x39,0x00,0x00,
+ 0xf1,0x71,0x00,0x80,0xf0,0x71,0x00,0x80,0xf0,0xe1,0x00,0x40,0xf0,0xe1,0x00,
+ 0x40,0xf0,0xc1,0x01,0x20,0xf0,0xc1,0x01,0x20,0xf0,0x81,0x03,0x10,0xe0,0x80,
+ 0x03,0x10,0xe0,0x00,0x07,0x08,0xe0,0x00,0x07,0x08,0xe0,0x00,0x0e,0x04,0x00,
+ 0x00,0x0e,0x04,0xe0,0x00,0x1c,0x02,0xf0,0x01,0x1c,0x02,0xf0,0x01,0x38,0x01,
+ 0xe0,0x00,0x38,0x01,0x00,0x00,0x70,0x01,0x00,0x00,0x70,0xff,0xff,0xff,0x7f,
+ 0xf8,0xff,0xff,0x3f,0x00,0x00,0x00,0x00};
diff -urN perl-5.10.1/lib/CGI/examples.newex/clickable_image.cgi perl-5.10.1/lib/CGI/examples/clickable_image.cgi
--- perl-5.10.1/lib/CGI/examples.newex/clickable_image.cgi	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/examples/clickable_image.cgi	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,26 @@
+#!/usr/local/bin/perl
+
+use CGI;
+$query = new CGI;
+print $query->header;
+print $query->start_html("A Clickable Image");
+print <<END;
+<H1>A Clickable Image</H1>
+</A>
+END
+print "Sorry, this isn't very exciting!\n";
+
+print $query->start_form;
+print $query->image_button('picture',"./wilogo.gif");
+print "Give me a: ",$query->popup_menu('letter',['A','B','C','D','E','W']),"\n"; # 
+print "<P>Magnification: ",$query->radio_group('magnification',['1X','2X','4X','20X']),"\n";
+print "<HR>\n";
+
+if ($query->param) {
+    print "<P>Magnification, <EM>",$query->param('magnification'),"</EM>\n";
+    print "<P>Selected Letter, <EM>",$query->param('letter'),"</EM>\n";
+    ($x,$y) = ($query->param('picture.x'),$query->param('picture.y'));
+    print "<P>Selected Position <EM>($x,$y)</EM>\n";
+}
+
+print $query->end_html;
diff -urN perl-5.10.1/lib/CGI/examples.newex/cookie.cgi perl-5.10.1/lib/CGI/examples/cookie.cgi
--- perl-5.10.1/lib/CGI/examples.newex/cookie.cgi	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/examples/cookie.cgi	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,88 @@
+#!/usr/local/bin/perl
+
+use CGI qw(:standard);
+
+@ANIMALS=sort qw/lion tiger bear pig porcupine ferret zebra gnu ostrich
+    emu moa goat weasel yak chicken sheep hyena dodo lounge-lizard
+    squirrel rat mouse hedgehog racoon baboon kangaroo hippopotamus
+    giraffe/;
+
+# Recover the previous animals from the magic cookie.
+# The cookie has been formatted as an associative array
+# mapping animal name to the number of animals.
+%zoo = cookie('animals');
+
+# Recover the new animal(s) from the parameter 'new_animal'
+@new = param('new_animals');
+
+# If the action is 'add', then add new animals to the zoo.  Otherwise
+# delete them.
+foreach (@new) {
+    if (param('action') eq 'Add') {
+	$zoo{$_}++;
+    } elsif (param('action') eq 'Delete') {
+	$zoo{$_}-- if $zoo{$_};
+	delete $zoo{$_} unless $zoo{$_};
+    }
+}
+
+# Add new animals to old, and put them in a cookie
+$the_cookie = cookie(-name=>'animals',
+		     -value=>\%zoo,
+		     -expires=>'+1h');
+
+# Print the header, incorporating the cookie and the expiration date...
+print header(-cookie=>$the_cookie);
+
+# Now we're ready to create our HTML page.
+print start_html('Animal crackers');
+
+print <<EOF;
+<h1>Animal Crackers</h1>
+Choose the animals you want to add to the zoo, and click "add".
+Come back to this page any time within the next hour and the list of 
+animals in the zoo will be resurrected.  You can even quit Netscape
+completely!
+<p>
+Try adding the same animal several times to the list.  Does this
+remind you vaguely of a shopping cart?
+<p>
+<em>This script only works with Netscape browsers</em>
+<p>
+<center>
+<table border>
+<tr><th>Add/Delete<th>Current Contents
+EOF
+    ;
+
+print "<tr><td>",start_form;
+print scrolling_list(-name=>'new_animals',
+		     -values=>[@ANIMALS],
+		     -multiple=>1,
+		     -override=>1,
+		     -size=>10),"<br>";
+print submit(-name=>'action',-value=>'Delete'),
+    submit(-name=>'action',-value=>'Add');
+print end_form;
+
+print "<td>";
+if (%zoo) {			# make a table
+    print "<ul>\n";
+    foreach (sort keys %zoo) {
+	print "<li>$zoo{$_} $_\n";
+    }
+    print "</ul>\n";
+} else {
+    print "<strong>The zoo is empty.</strong>\n";
+}
+print "</table></center>";
+
+print <<EOF;
+<hr>
+<ADDRESS>Lincoln D. Stein</ADDRESS><BR>
+<A HREF="./">More Examples</A>
+EOF
+    ;
+print end_html;
+
+
diff -urN perl-5.10.1/lib/CGI/examples.newex/crash.cgi perl-5.10.1/lib/CGI/examples/crash.cgi
--- perl-5.10.1/lib/CGI/examples.newex/crash.cgi	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/examples/crash.cgi	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,6 @@
+#!/usr/local/bin/perl
+
+use CGI::Carp qw(fatalsToBrowser);
+
+# This line invokes a fatal error message at compile time.
+foo bar baz;
diff -urN perl-5.10.1/lib/CGI/examples.newex/customize.cgi perl-5.10.1/lib/CGI/examples/customize.cgi
--- perl-5.10.1/lib/CGI/examples.newex/customize.cgi	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/examples/customize.cgi	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,92 @@
+#!/usr/local/bin/perl
+
+use CGI qw(:standard :html3);
+
+# Some constants to use in our form.
+@colors=qw/aqua black blue fuschia gray green lime maroon navy olive
+    purple red silver teal white yellow/;
+@sizes=("<default>",1..7);
+
+# recover the "preferences" cookie.
+%preferences = cookie('preferences');
+
+# If the user wants to change the background color or her
+# name, they will appear among our CGI parameters.
+foreach ('text','background','name','size') {
+    $preferences{$_} = param($_) || $preferences{$_};
+}
+
+# Set some defaults
+$preferences{'background'} = $preferences{'background'} || 'silver';
+$preferences{'text'} = $preferences{'text'} || 'black';
+
+# Refresh the cookie so that it doesn't expire.  This also
+# makes any changes the user made permanent.
+$the_cookie = cookie(-name=>'preferences',
+			 -value=>\%preferences,
+			 -expires=>'+30d');
+print header(-cookie=>$the_cookie);
+
+# Adjust the title to incorporate the user's name, if provided.
+$title = $preferences{'name'} ? 
+    "Welcome back, $preferences{name}!" : "Customizable Page";
+
+# Create the HTML page.  We use several of Netscape's
+# extended tags to control the background color and the
+# font size.  It's safe to use Netscape features here because
+# cookies don't work anywhere else anyway.
+print start_html(-title=>$title,
+		 -bgcolor=>$preferences{'background'},
+		 -text=>$preferences{'text'}
+		 );
+
+print basefont({SIZE=>$preferences{size}}) if $preferences{'size'} > 0;
+
+print h1($title),<<END;
+You can change the appearance of this page by submitting
+the fill-out form below.  If you return to this page any time
+within 30 days, your preferences will be restored.
+END
+    ;
+
+# Create the form
+print hr(),
+    start_form,
+    
+    "Your first name: ",
+    textfield(-name=>'name',
+	      -default=>$preferences{'name'},
+	      -size=>30),br,
+    
+    table(
+	  TR(
+	     td("Preferred"),
+	     td("Page color:"),
+	     td(popup_menu(-name=>'background',
+			   -values=>\@colors,
+			   -default=>$preferences{'background'})
+		),
+	     ),
+	  TR(
+	     td(''),
+	     td("Text color:"),
+	     td(popup_menu(-name=>'text',
+			   -values=>\@colors,
+			   -default=>$preferences{'text'})
+		)
+	     ),
+	  TR(
+	     td(''),
+	     td("Font size:"),
+	     td(popup_menu(-name=>'size',
+			   -values=>\@sizes,
+			   -default=>$preferences{'size'})
+		)
+	     )
+	  ),
+
+    submit(-label=>'Set preferences'),
+    hr;
+	   
+print a({HREF=>"/"},'Go to the home page');
+print end_html;
diff -urN perl-5.10.1/lib/CGI/examples.newex/diff_upload.cgi perl-5.10.1/lib/CGI/examples/diff_upload.cgi
--- perl-5.10.1/lib/CGI/examples.newex/diff_upload.cgi	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/examples/diff_upload.cgi	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,68 @@
+#!/usr/local/bin/perl
+
+$DIFF = "/usr/bin/diff";
+$PERL = "/usr/bin/perl";
+
+use CGI qw(:standard);
+use CGI::Carp;
+
+print header;
+print start_html("File Diff Example");
+print "<strong>Version </strong>$CGI::VERSION<p>";
+
+print <<EOF;
+<H1>File Diff Example</H1>
+Enter two files.  When you press "submit" their diff will be
+produced.
+EOF
+    ;
+
+# Start a multipart form.
+print start_multipart_form;
+print "File #1:",filefield(-name=>'file1',-size=>45),"<BR>\n";
+print "File #2:",filefield(-name=>'file2',-size=>45),"<BR>\n";
+print "Diff type: ",radio_group(-name=>'type',
+					-value=>['context','normal']),"<br>\n";
+print reset,submit(-name=>'submit',-value=>'Do Diff');
+print endform;
+
+# Process the form if there is a file name entered
+$file1 = param('file1');
+$file2 = param('file2');
+
+$|=1;				# for buffering
+if ($file1 && $file2) {
+    $realfile1 = tmpFileName($file1);
+    $realfile2 = tmpFileName($file2);
+    print "<HR>\n";
+    print "<H2>$file1 vs $file2</H2>\n";
+
+    print "<PRE>\n";
+    $options = "-c" if param('type') eq 'context';
+    system "$DIFF $options $realfile1 $realfile2 | $PERL -pe 's/>/&gt;/g; s/</&lt;/g;'";
+    close $file1;
+    close $file2;
+    print "</PRE>\n";
+}
+
+print <<EOF;
+<HR>
+<A HREF="../cgi_docs.html">CGI documentation</A>
+<HR>
+<ADDRESS>
+<A HREF="/~lstein">Lincoln D. Stein</A>
+</ADDRESS><BR>
+Last modified 17 July 1996
+EOF
+    ;
+print end_html;
+
+sub sanitize {
+    my $name = shift;
+    my($safe) = $name=~/([a-zA-Z0-9._~#,]+)/;
+    unless ($safe) {
+	print "<strong>$name is not a valid Unix filename -- sorry</strong>";
+	exit 0;
+    }
+    return $safe;
+}
Binary files perl-5.10.1/lib/CGI/examples.newex/dna.small.gif and perl-5.10.1/lib/CGI/examples/dna.small.gif differ
diff -urN perl-5.10.1/lib/CGI/examples.newex/file_upload.cgi perl-5.10.1/lib/CGI/examples/file_upload.cgi
--- perl-5.10.1/lib/CGI/examples.newex/file_upload.cgi	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/examples/file_upload.cgi	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,71 @@
+#!/usr/local/bin/perl -w
+
+use strict 'refs';
+use lib '..';
+use CGI qw(:standard);
+use CGI::Carp qw/fatalsToBrowser/;
+
+print header();
+print start_html("File Upload Example");
+print strong("Version "),$CGI::VERSION,p;
+
+print h1("File Upload Example"),
+    'This example demonstrates how to prompt the remote user to
+    select a remote file for uploading. ',
+    strong("This feature only works with Netscape 2.0 or greater, or IE 4.0 or greater."),
+    p,
+    'Select the ',cite('browser'),' button to choose a text file
+    to upload.  When you press the submit button, this script
+    will count the number of lines, words, and characters in
+    the file.';
+
+my @types = ('count lines','count words','count characters');
+
+# Start a multipart form.
+print start_multipart_form(),
+    "Enter the file to process:",
+    filefield('filename','',45),
+    br,
+    checkbox_group('count',\@types,\@types),
+    p,
+    reset,submit('submit','Process File'),
+    endform;
+
+# Process the form if there is a file name entered
+if (my $file = param('filename')) {
+    my %stats;
+    my $tmpfile=tmpFileName($file);
+    my $mimetype = uploadInfo($file)->{'Content-Type'} || '';
+    print hr(),
+          h2($file),
+          h3($tmpfile),
+          h4("MIME Type:",em($mimetype));
+
+    my($lines,$words,$characters,@words) = (0,0,0,0);
+    while (<$file>) {
+	$lines++;
+	$words += @words=split(/\s+/);
+	$characters += length($_);
+    }
+    close $file;
+    grep($stats{$_}++,param('count'));
+    if (%stats) {
+	print strong("Lines: "),$lines,br if $stats{'count lines'};
+	print strong("Words: "),$words,br if $stats{'count words'};
+	print strong("Characters: "),$characters,br if $stats{'count characters'};
+    } else {
+	print strong("No statistics selected.");
+    }
+}
+
+# print cite("URL parameters: "),url_param();
+
+print hr(),
+    a({href=>"../cgi_docs.html"},"CGI documentation"),
+    hr,
+    address(
+	    a({href=>'/~lstein'},"Lincoln D. Stein")),
+    br,
+    'Last modified July 17, 1996',
+    end_html;
+
diff -urN perl-5.10.1/lib/CGI/examples.newex/frameset.cgi perl-5.10.1/lib/CGI/examples/frameset.cgi
--- perl-5.10.1/lib/CGI/examples.newex/frameset.cgi	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/examples/frameset.cgi	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,81 @@
+#!/usr/local/bin/perl
+
+use CGI;
+$query = new CGI;
+print $query->header;
+$TITLE="Frameset Example";
+
+# We use the path information to distinguish between calls
+# to the script to:
+# (1) create the frameset
+# (2) create the query form
+# (3) create the query response
+
+$path_info = $query->path_info;
+
+# If no path information is provided, then we create 
+# a side-by-side frame set
+if (!$path_info) {
+    &print_frameset;
+    exit 0;
+}
+
+# If we get here, then we either create the query form
+# or we create the response.
+&print_html_header;
+&print_query if $path_info=~/query/;
+&print_response if $path_info=~/response/;
+&print_end;
+
+
+# Create the frameset
+sub print_frameset {
+    $script_name = $query->script_name;
+    print <<EOF;
+<html><head><title>$TITLE</title></head>
+<frameset cols="50,50">
+<frame src="$script_name/query" name="query">
+<frame src="$script_name/response" name="response">
+</frameset>
+EOF
+    ;
+    exit 0;
+}
+
+sub print_html_header {
+    print $query->start_html($TITLE);
+}
+
+sub print_end {
+    print qq{<P><hr><A HREF="../index.html" TARGET="_top">More Examples</A>};
+    print $query->end_html;
+}
+
+sub print_query {
+    $script_name = $query->script_name;
+    print "<H1>Frameset Query</H1>\n";
+    print $query->start_form(-action=>"$script_name/response",-TARGET=>"response");
+    print "What's your name? ",$query->textfield('name');
+    print "<P>What's the combination?<P>",
+    $query->checkbox_group(-name=>'words',
+			       -values=>['eenie','meenie','minie','moe']);
+
+    print "<P>What's your favorite color? ",
+    $query->popup_menu(-name=>'color',
+		       -values=>['red','green','blue','chartreuse']),
+    "<P>";
+    print $query->submit;
+    print $query->endform;
+}
+
+sub print_response {
+    print "<H1>Frameset Result</H1>\n";
+    unless ($query->param) {
+	print "<b>No query submitted yet.</b>";
+	return;
+    }
+    print "Your name is <EM>",$query->param(name),"</EM>\n";
+    print "<P>The keywords are: <EM>",join(", ",$query->param(words)),"</EM>\n";
+    print "<P>Your favorite color is <EM>",$query->param(color),"</EM>\n";
+}
+
diff -urN perl-5.10.1/lib/CGI/examples.newex/index.html perl-5.10.1/lib/CGI/examples/index.html
--- perl-5.10.1/lib/CGI/examples.newex/index.html	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/examples/index.html	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,119 @@
+<HTML> <HEAD>
+<TITLE>More Examples of Scripts Created with CGI.pm</TITLE>
+</HEAD>
+
+<BODY>
+<H1>More Examples of Scripts Created with CGI.pm</H1>
+
+<H2> Basic Non Sequitur Questionnaire</H2>
+<UL>
+  <LI> <A HREF="tryit.cgi">Try the script</A>
+  <LI> <A HREF="tryit.txt">Look at its source code</A>
+</UL>
+
+<H2> Advanced Non Sequitur Questionnaire</H2>
+<UL>
+  <LI> <A HREF="monty.cgi">Try the script</A>
+  <LI> <A HREF="monty.txt">Look at its source code</A>
+</UL>
+
+<H2> Save and restore the state of a form to a file</H2>
+<UL>
+  <LI> <A HREF="save_state.cgi">Try the script</A>
+  <LI> <A HREF="save_state.txt">Look at its source code</A>
+</UL>
+
+<H2> Server Push</H2>
+<ul>
+  <li><a href="nph-multipart.cgi">Try the script</a>
+  <li><a href="nph-multipart.txt">Look at its source code</a>
+</ul>
+
+<H2> Read the coordinates from a clickable image map</H2>
+<UL>
+  <LI> <A HREF="clickable_image.cgi">Try the script</A>
+  <LI> <A HREF="clickable_image.txt">Look at its source code</A>
+</UL>
+
+<H2> Multiple independent forms on the same page</H2>
+<UL>
+  <LI> <A HREF="multiple_forms.cgi">Try the script</A>
+  <LI> <A HREF="multiple_forms.txt">Look at its source code</A>
+</UL>
+
+<H2> How to maintain state on a page with internal links</H2>
+<UL>
+  <LI> <A HREF="internal_links.cgi">Try the script</A>
+  <LI> <A HREF="internal_links.txt">Look at its source code</A>
+</UL>
+
+<h2>Echo fatal script errors to the browser</h2>
+<em>This script deliberately generates a compile-time error.</em>
+<ul>
+  <li><a href="crash.cgi">Try the script</a>
+  <li><a href="crash.txt">Look at its source code</a>
+</ul>
+
+<EM>The Following Scripts Work with Netscape Navigator 2.0 and higher,
+or Internet Explorer 3.0 and higher</EM>
+
+<H2> Prompt for a file to upload and process it</H2>
+<UL>
+  <LI> <A HREF="file_upload.cgi">Try the script</A>
+  <LI> <A HREF="file_upload.txt">Look at its source code</A>
+</UL>
+
+<h2> A Continuously-Updated Page using Server Push</h2>
+<ul>
+  <li><a href="nph-clock.cgi">Try the script</a>
+  <li><a href="nph-clock.txt">Look at its source code</a>
+</ul>
+
+<h2>Compute the "diff" between two uploaded files</h2>
+<ul>
+  <li><a href="diff_upload.cgi">Try the script</a>
+  <li><a href="diff_upload.txt">Look at its source code</a>
+</ul>
+
+<h2>Maintain state over a long period with a cookie</h2>
+<ul>
+  <li><a href="cookie.cgi">Try the script</a>
+  <li><a href="cookie.txt">Look at its source code</a>
+</ul>
+
+<h2>Permanently customize the appearance of a page with a cookie</h2>
+<ul>
+  <li><a href="customize.cgi">Try the script</a>
+  <li><a href="customize.txt">Look at its source code</a>
+</ul>
+
+<h2> Popup the response in a new window</h2>
+<ul>
+  <li><a href="popup.cgi">Try the script</a>
+  <li><a href="popup.txt">Look at its source code</a>
+</ul>
+
+<h2> Side-by-side form and response using frames</h2>
+<ul>
+  <li><a href="frameset.cgi">Try the script</a>
+  <li><a href="frameset.txt">Look at its source code</a>
+</ul>
+
+<h2>Verify the Contents of a fill-out form with JavaScript</h2>
+<ul>
+  <li><a href="javascript.cgi">Try the script</a>
+  <li><a href="javascript.txt">Look at its source code</a>
+</ul>
+
+<HR>
+<MENU>
+  <LI> <A HREF="../cgi_docs.html">CGI.pm documentation</A>
+  <LI> <A HREF="../CGI.pm.tar.gz">Download the CGI.pm distribution</A>
+</MENU>
+<HR>
+<ADDRESS>Lincoln D. Stein, lstein@genome.wi.mit.edu<br>
+<a href="/">Whitehead Institute/MIT Center for Genome Research</a></ADDRESS>
+<!-- hhmts start -->
+Last modified: Wed Jun 23 15:31:47 EDT 1999
+<!-- hhmts end -->
+</BODY> </HTML>
diff -urN perl-5.10.1/lib/CGI/examples.newex/internal_links.cgi perl-5.10.1/lib/CGI/examples/internal_links.cgi
--- perl-5.10.1/lib/CGI/examples.newex/internal_links.cgi	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/examples/internal_links.cgi	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,33 @@
+#!/usr/local/bin/perl
+
+use CGI;
+$query = new CGI;
+
+# We generate a regular HTML file containing a very long list
+# and a popup menu that does nothing except to show that we
+# don't lose the state information.
+print $query->header;
+print $query->start_html("Internal Links Example");
+print "<H1>Internal Links Example</H1>\n";
+print "Click <cite>Submit Query</cite> to create a state.  Then scroll down and",
+    " click on any of the <cite>Jump to top</cite> links.  This is not very exciting.";
+
+print "<A NAME=\"start\"></A>\n"; # an anchor point at the top
+
+# pick a default starting value;
+$query->param('amenu','FOO1') unless $query->param('amenu');
+
+print $query->start_form;
+print $query->popup_menu('amenu',[('FOO1'..'FOO9')]);
+print $query->submit,$query->endform;
+
+# We create a long boring list for the purposes of illustration.
+$myself = $query->self_url;
+print "<OL>\n";
+for (1..100) {
+    print qq{<LI>List item #$_ <A HREF="$myself#start">Jump to top</A>\n};
+}
+print "</OL>\n";
+
+print $query->end_html;
+
diff -urN perl-5.10.1/lib/CGI/examples.newex/javascript.cgi perl-5.10.1/lib/CGI/examples/javascript.cgi
--- perl-5.10.1/lib/CGI/examples.newex/javascript.cgi	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/examples/javascript.cgi	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,105 @@
+#!/usr/local/bin/perl
+
+# This script illustrates how to use JavaScript to validate fill-out
+# forms.
+use CGI qw(:standard);
+
+# Here's the javascript code that we include in the document.
+$JSCRIPT=<<EOF;
+    // validate that the user is the right age.  Return
+    // false to prevent the form from being submitted.
+    function validateForm() {
+	var today = new Date();
+	var birthday = validateDate(document.form1.birthdate);
+	if (birthday == 0) {
+	    document.form1.birthdate.focus()
+	    document.form1.birthdate.select();
+	    return false;
+	}
+	var milliseconds = today.getTime()-birthday;
+	var years = milliseconds/(1000 * 60 * 60 * 24 * 365.25);
+	if ((years > 20) || (years < 5)) {
+	    alert("You must be between the ages of 5 and 20 to submit this form");
+	    document.form1.birthdate.focus();
+	    document.form1.birthdate.select();
+	    return false;
+	}
+	// Since we've calculated the age in years already,
+	// we might as well send it up to our CGI script.
+	document.form1.age.value=Math.floor(years);
+	return true;
+    }
+
+   // make sure that the contents of the supplied
+   // field contain a valid date.
+   function validateDate(element) {
+       var date = Date.parse(element.value);
+       if (0 == date) { 
+	   alert("Please enter date in format MMM DD, YY");
+	   element.focus();
+	   element.select();
+       }
+       return date;
+   }
+
+   // Compliments, compliments
+    function doPraise(element) {
+	if (element.checked) {
+	    self.status=element.value + " is an excellent choice!";
+	    return true;
+	} else {
+	    return false;
+	}
+    }
+
+    function checkColor(element) {
+	var color = element.options[element.selectedIndex].text;
+	if (color == "blonde") {
+	    if (confirm("Is it true that blondes have more fun?"))
+		alert("Darn.  That leaves me out.");
+	} else
+	    alert(color + " is a fine choice!");
+    }
+EOF
+    ;
+
+# here's where the execution begins
+print header;
+print start_html(-title=>'Personal Profile',-script=>$JSCRIPT);
+
+print h1("Big Brother Wants to Know All About You"),
+    strong("Note: "),"This page uses JavaScript and requires ",
+    "Netscape 2.0 or higher to do anything special.";
+
+&print_prompt();
+print hr;
+&print_response() if param;
+print end_html;
+
+sub print_prompt {
+    print start_form(-name=>'form1',
+		     -onSubmit=>"return validateForm()"),"\n";
+    print "Birthdate (e.g. Jan 3, 1972): ", 
+          textfield(-name=>'birthdate',
+			-onBlur=>"validateDate(this)"),"<p>\n";
+    print "Sex: ",radio_group(-name=>'gender',
+				  -value=>[qw/male female/],
+				  -onClick=>"doPraise(this)"),"<p>\n";
+    print "Hair color: ",popup_menu(-name=>'color',
+					-value=>[qw/brunette blonde red gray/],
+					-default=>'red',
+					-onChange=>"checkColor(this)"),"<p>\n";
+    print hidden(-name=>'age',-value=>0);
+    print submit();
+    print end_form;
+}
+
+sub print_response {
+    import_names('Q');
+    print h2("Your profile"),
+	"You claim to be a ",b($Q::age)," year old ",b($Q::color,$Q::gender),".",
+	"You should be ashamed of yourself for lying so ",
+	"blatantly to big brother!",
+	hr;
+}
+
diff -urN perl-5.10.1/lib/CGI/examples.newex/make_links.pl perl-5.10.1/lib/CGI/examples/make_links.pl
--- perl-5.10.1/lib/CGI/examples.newex/make_links.pl	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/examples/make_links.pl	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,8 @@
+#!/usr/local/bin/perl
+
+# this is just a utility for creating symlinks from *.txt to *.cgi
+# for documentation purposes.
+foreach (<*.cgi>) {
+    ($target=$_)=~s/cgi$/txt/;
+    symlink $_,$target
+}
diff -urN perl-5.10.1/lib/CGI/examples.newex/monty.cgi perl-5.10.1/lib/CGI/examples/monty.cgi
--- perl-5.10.1/lib/CGI/examples.newex/monty.cgi	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/examples/monty.cgi	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,84 @@
+#!/usr/local/bin/perl
+     
+use CGI;
+use CGI::Carp qw/fatalsToBrowser/;
+ 
+$query = new CGI;
+
+print $query->header;
+print $query->start_html("Example CGI.pm Form");
+print "<H1> Example CGI.pm Form</H1>\n";
+&print_prompt($query);
+&do_work($query);
+&print_tail;
+print $query->end_html;
+ 
+sub print_prompt {
+   my($query) = @_;
+ 
+   print $query->start_form;
+   print "<EM>What's your name?</EM><BR>";
+   print $query->textfield('name');
+   print $query->checkbox('Not my real name');
+ 
+   print "<P><EM>Where can you find English Sparrows?</EM><BR>";
+   print $query->checkbox_group(
+				-name=>'Sparrow locations',
+				-Values=>[England,France,Spain,Asia,Hoboken],
+				-linebreak=>'yes',
+				-defaults=>[England,Asia]);
+ 
+   print "<P><EM>How far can they fly?</EM><BR>",
+   $query->radio_group(
+		       -name=>'how far',
+		       -Values=>['10 ft','1 mile','10 miles','real far'],
+		       -default=>'1 mile');
+   
+   print "<P><EM>What's your favorite color?</EM>  ";
+   print $query->popup_menu(-name=>'Color',
+			    -Values=>['black','brown','red','yellow'],
+			    -default=>'red');
+ 
+   print $query->hidden('Reference','Monty Python and the Holy Grail');
+ 
+   print "<P><EM>What have you got there?</EM><BR>";
+   print $query->scrolling_list(
+				-name=>'possessions',
+				-Values=>['A Coconut','A Grail','An Icon',
+					  'A Sword','A Ticket'],
+				-size=>5,
+				-multiple=>'true');
+ 
+   print "<P><EM>Any parting comments?</EM><BR>";
+   print $query->textarea(-name=>'Comments',
+			  -rows=>10,
+			  -columns=>50);
+   
+   print "<P>",$query->reset;
+   print $query->submit('Action','Shout');
+   print $query->submit('Action','Scream');
+   print $query->endform;
+   print "<HR>\n";
+ 	}
+ 
+sub do_work {
+    my($query) = @_;
+    my(@values,$key);
+
+    print "<H2>Here are the current settings in this form</H2>";
+
+    foreach $key ($query->param) {
+	print "<STRONG>$key</STRONG> -> ";
+	@values = $query->param($key);
+	print join(", ",@values),"<BR>\n";
+    }
+}
+ 
+sub print_tail {
+    print <<END;
+<HR>
+<ADDRESS>Lincoln D. Stein</ADDRESS><BR>
+<A HREF="/">Home Page</A>
+END
+    ;
+}
diff -urN perl-5.10.1/lib/CGI/examples.newex/multiple_forms.cgi perl-5.10.1/lib/CGI/examples/multiple_forms.cgi
--- perl-5.10.1/lib/CGI/examples.newex/multiple_forms.cgi	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/examples/multiple_forms.cgi	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,54 @@
+#!/usr/local/bin/perl
+
+use CGI;
+
+$query = new CGI;
+print $query->header;
+print $query->start_html('Multiple Forms');
+print "<H1>Multiple Forms</H1>\n";
+
+# Print the first form
+print $query->start_form;
+$name = $query->remote_user || 'anonymous@' . $query->remote_host;
+
+print "What's your name? ",$query->textfield('name',$name,50);
+print "<P>What's the combination?<P>",
+        $query->checkbox_group('words',['eenie','meenie','minie','moe']);
+print "<P>What's your favorite color? ",
+        $query->popup_menu('color',['red','green','blue','chartreuse']),
+	"<P>";
+print $query->submit('form_1','Send Form 1');
+print $query->endform;
+
+# Print the second form
+print "<HR>\n";
+print $query->start_form;
+print "Some radio buttons: ",$query->radio_group('radio buttons',
+						 [qw{one two three four five}],'three'),"\n";
+print "<P>What's the password? ",$query->password_field('pass','secret');
+print $query->defaults,$query->submit('form_2','Send Form 2'),"\n";
+print $query->endform;
+
+print "<HR>\n";
+
+$query->import_names('Q');
+if ($Q::form_1) {
+    print "<H2>Form 1 Submitted</H2>\n";
+    print "Your name is <EM>$Q::name</EM>\n";
+    print "<P>The combination is: <EM>{",join(",",@Q::words),"}</EM>\n";
+    print "<P>Your favorite color is <EM>$Q::color</EM>\n";
+} elsif ($Q::form_2) {
+    print <<EOF;
+<H2>Form 2 Submitted</H2>
+<P>The value of the radio buttons is <EM>$Q::radio_buttons</EM>
+<P>The secret password is <EM>$Q::pass</EM>
+EOF
+    ;
+}
+print qq{<P><A HREF="./">Other examples</A>};
+print qq{<P><A HREF="../cgi_docs.html">Go to the documentation</A>};
+
+print $query->end_html;
+
+
+
diff -urN perl-5.10.1/lib/CGI/examples.newex/nph-clock.cgi perl-5.10.1/lib/CGI/examples/nph-clock.cgi
--- perl-5.10.1/lib/CGI/examples.newex/nph-clock.cgi	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/examples/nph-clock.cgi	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,18 @@
+#!/usr/local/bin/perl -w
+
+use CGI::Push qw(:standard :html3);
+
+do_push(-next_page=>\&draw_time,-delay=>1);
+
+sub draw_time {
+    my $time = localtime();
+    return start_html('Tick Tock'),
+           div({-align=>CENTER},
+	       h1('Virtual Clock'),
+	       h2($time)
+	       ),
+	   hr,
+	   a({-href=>'index.html'},'More examples'),
+           end_html();
+}
+
diff -urN perl-5.10.1/lib/CGI/examples.newex/nph-multipart.cgi perl-5.10.1/lib/CGI/examples/nph-multipart.cgi
--- perl-5.10.1/lib/CGI/examples.newex/nph-multipart.cgi	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/examples/nph-multipart.cgi	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,10 @@
+#!/usr/local/bin/perl
+use CGI qw/:push -nph/;
+$| = 1;
+print multipart_init(-boundary=>'----------------here we go!');
+while (1) {
+    print multipart_start(-type=>'text/plain'),
+    "The current time is ",scalar(localtime),"\n",
+    multipart_end;
+    sleep 1;
+}
diff -urN perl-5.10.1/lib/CGI/examples.newex/popup.cgi perl-5.10.1/lib/CGI/examples/popup.cgi
--- perl-5.10.1/lib/CGI/examples.newex/popup.cgi	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/examples/popup.cgi	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,32 @@
+#!/usr/local/bin/perl
+
+use CGI;
+$query = new CGI;
+print $query->header;
+print $query->start_html('Popup Window');
+
+
+if (!$query->param) {
+    print "<H1>Ask your Question</H1>\n";
+    print $query->start_form(-target=>'_new');
+    print "What's your name? ",$query->textfield('name');
+    print "<P>What's the combination?<P>",
+    $query->checkbox_group(-name=>'words',
+			   -values=>['eenie','meenie','minie','moe'],
+			   -defaults=>['eenie','moe']);
+
+    print "<P>What's your favorite color? ",
+    $query->popup_menu(-name=>'color',
+		       -values=>['red','green','blue','chartreuse']),
+    "<P>";
+    print $query->submit;
+    print $query->endform;
+
+} else {
+    print "<H1>And the Answer is...</H1>\n";
+    print "Your name is <EM>",$query->param(name),"</EM>\n";
+    print "<P>The keywords are: <EM>",join(", ",$query->param(words)),"</EM>\n";
+    print "<P>Your favorite color is <EM>",$query->param(color),"</EM>\n";
+}
+print qq{<P><A HREF="cgi_docs.html">Go to the documentation</A>};
+print $query->end_html;
diff -urN perl-5.10.1/lib/CGI/examples.newex/save_state.cgi perl-5.10.1/lib/CGI/examples/save_state.cgi
--- perl-5.10.1/lib/CGI/examples.newex/save_state.cgi	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/examples/save_state.cgi	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,67 @@
+#!/usr/local/bin/perl
+
+use CGI;
+$query = new CGI;
+
+print $query->header;
+print $query->start_html("Save and Restore Example");
+print "<H1>Save and Restore Example</H1>\n";
+
+# Here's where we take action on the previous request
+&save_parameters($query)              if $query->param('action') eq 'SAVE';
+$query = &restore_parameters($query)  if $query->param('action') eq 'RESTORE';
+
+# Here's where we create the form
+print $query->start_multipart_form;
+print "Popup 1: ",$query->popup_menu('popup1',[qw{red green purple magenta orange chartreuse brown}]),"\n";
+print "Popup 2: ",$query->popup_menu('popup2',[qw{lion tiger bear zebra potto wildebeest frog emu gazelle}]),"\n";
+print "<P>";
+$default_name = $query->remote_addr . '.sav';
+print "Save/restore state from file: ",$query->textfield('savefile',$default_name),"\n";
+print "<P>";
+print $query->submit('action','SAVE'),$query->submit('action','RESTORE');
+print "<P>",$query->defaults;
+print $query->endform;
+
+# Here we print out a bit at the end
+print $query->end_html;
+
+sub save_parameters {
+    local($query) = @_;
+    local($filename) = &clean_name($query->param('savefile'));
+    if (open(FILE,">$filename")) {
+	$query->save(FILE);
+	close FILE;
+	print "<STRONG>State has been saved to file $filename</STRONG>\n";
+	print "<P>If you remember this name you can restore the state later.\n";
+    } else {
+	print "<STRONG>Error:</STRONG> couldn't write to file $filename: $!\n";
+    }
+}
+
+sub restore_parameters {
+    local($query) = @_;
+    local($filename) = &clean_name($query->param('savefile'));
+    if (open(FILE,$filename)) {
+	$query = new CGI(FILE);  # Throw out the old query, replace it with a new one
+	close FILE;
+	print "<STRONG>State has been restored from file $filename</STRONG>\n";
+    } else {
+	print "<STRONG>Error:</STRONG> couldn't restore file $filename: $!\n";
+    }
+    return $query;
+}
+
+
+# Very important subroutine -- get rid of all the naughty
+# metacharacters from the file name. If there are, we
+# complain bitterly and die.
+sub clean_name {
+   local($name) = @_;
+   unless ($name=~/^[\w\._\-]+$/) {
+      print "<STRONG>$name has naughty characters.  Only ";
+      print "alphanumerics are allowed.  You can't use absolute names.</STRONG>";
+      die "Attempt to use naughty characters";
+   }
+   return "WORLD_WRITABLE/$name";
+}
diff -urN perl-5.10.1/lib/CGI/examples.newex/tryit.cgi perl-5.10.1/lib/CGI/examples/tryit.cgi
--- perl-5.10.1/lib/CGI/examples.newex/tryit.cgi	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/examples/tryit.cgi	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,37 @@
+#!/usr/local/bin/perl
+
+use CGI ':standard';
+
+print header;
+print start_html('A Simple Example'),
+    h1('A Simple Example'),
+    start_form,
+    "What's your name? ",textfield('name'),
+    p,
+    "What's the combination?",
+    p,
+    checkbox_group(-name=>'words',
+		   -values=>['eenie','meenie','minie','moe'],
+		   -defaults=>['eenie','minie']),
+    p,
+    "What's your favorite color? ",
+    popup_menu(-name=>'color',
+	       -values=>['red','green','blue','chartreuse']),
+    p,
+    submit,
+    end_form,
+    hr;
+
+if (param()) {
+    print 
+	"Your name is: ",em(param('name')),
+	p,
+	"The keywords are: ",em(join(", ",param('words'))),
+	p,
+	"Your favorite color is: ",em(param('color')),
+	hr;
+}
+print a({href=>'../cgi_docs.html'},'Go to the documentation');
+print end_html;
+
+
Binary files perl-5.10.1/lib/CGI/examples.newex/wilogo.gif and perl-5.10.1/lib/CGI/examples/wilogo.gif differ
diff -urN perl-5.10.1/lib/CGI/examples.newex/WORLD_WRITABLE/18.157.1.253.sav perl-5.10.1/lib/CGI/examples/WORLD_WRITABLE/18.157.1.253.sav
--- perl-5.10.1/lib/CGI/examples.newex/WORLD_WRITABLE/18.157.1.253.sav	1970-01-01 01:00:00.000000000 +0100
+++ perl-5.10.1/lib/CGI/examples/WORLD_WRITABLE/18.157.1.253.sav	2011-01-05 19:13:45.000000000 +0100
@@ -0,0 +1,5 @@
+popup1=purple
+popup2=potto
+savefile=18.157.1.253.sav
+action=SAVE
+=
diff -up perl-5.10.1/MANIFEST.cginew perl-5.10.1/MANIFEST
--- perl-5.10.1/MANIFEST.cginew	2011-01-21 13:56:27.000000000 +0100
+++ perl-5.10.1/MANIFEST	2011-01-21 13:57:47.379573204 +0100
@@ -1901,25 +1901,26 @@ lib/CGI/Apache.pm		Support for Apache's 
 lib/CGI/Carp.pm			Log server errors with helpful context
 lib/CGI/Changes			Changelog for CGI.pm
 lib/CGI/Cookie.pm		Interface to Netscape Cookies
-lib/CGI/eg/caution.xbm		CGI example
-lib/CGI/eg/clickable_image.cgi	CGI example
-lib/CGI/eg/cookie.cgi		CGI example
-lib/CGI/eg/crash.cgi		CGI example
-lib/CGI/eg/customize.cgi	CGI example
-lib/CGI/eg/diff_upload.cgi	CGI example
-lib/CGI/eg/file_upload.cgi	CGI example
-lib/CGI/eg/frameset.cgi		CGI example
-lib/CGI/eg/index.html		Index page for CGI examples
-lib/CGI/eg/internal_links.cgi	CGI example
-lib/CGI/eg/javascript.cgi	CGI example
-lib/CGI/eg/make_links.pl	CGI example
-lib/CGI/eg/monty.cgi		CGI example
-lib/CGI/eg/multiple_forms.cgi	CGI example
-lib/CGI/eg/nph-clock.cgi	CGI example
-lib/CGI/eg/nph-multipart.cgi	CGI example
-lib/CGI/eg/popup.cgi		CGI example
-lib/CGI/eg/save_state.cgi	CGI example
-lib/CGI/eg/tryit.cgi		CGI example
+lib/CGI/examples/caution.xbm
+lib/CGI/examples/clickable_image.cgi
+lib/CGI/examples/cookie.cgi
+lib/CGI/examples/crash.cgi
+lib/CGI/examples/customize.cgi
+lib/CGI/examples/diff_upload.cgi
+lib/CGI/examples/file_upload.cgi
+lib/CGI/examples/frameset.cgi
+lib/CGI/examples/index.html
+lib/CGI/examples/internal_links.cgi
+lib/CGI/examples/javascript.cgi
+lib/CGI/examples/make_links.pl
+lib/CGI/examples/monty.cgi
+lib/CGI/examples/multiple_forms.cgi
+lib/CGI/examples/nph-clock.cgi
+lib/CGI/examples/nph-multipart.cgi
+lib/CGI/examples/popup.cgi
+lib/CGI/examples/save_state.cgi
+lib/CGI/examples/tryit.cgi
+lib/CGI/examples/WORLD_WRITABLE/18.157.1.253.sav
 lib/CGI/Fast.pm			Support for FastCGI (persistent server process)
 lib/CGI.pm			Web server interface ("Common Gateway Interface")
 lib/CGI/Pretty.pm		Output nicely formatted HTML

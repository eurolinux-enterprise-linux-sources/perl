From c80aaad1582641a2058d076bab6d79a9688d6776 Mon Sep 17 00:00:00 2001
From: Niko Tyni <ntyni@debian.org>
Date: Tue, 19 Jan 2010 11:03:08 +0100
Subject: [PATCH] Fix a NULL pointer dereference when looking for a DESTROY
 method

The empty DESTROY method optimization introduced by commit
fbb3ee5af3d would crash the interpreter if a DESTROY method
was declared but not actually defined.

This is seen in the real world with AutoLoader / AutoSplit,
where the crash defeats autoloading a DESTROY method.

Petr Pisar: Upstream commit ported to perl-5.10.1:

From 1f15e670edb515b744e9021b4a42a7955da83093 Mon Sep 17 00:00:00 2001
From: Niko Tyni <ntyni@debian.org>
Date: Tue, 19 Jan 2010 11:03:08 +0100
Subject: [PATCH] Fix a NULL pointer dereference when looking for a DESTROY
 method
---
 sv.c          |  3 ++-
 t/op/method.t | 15 ++++++++++++++-
 2 files changed, 16 insertions(+), 2 deletions(-)

diff --git a/sv.c b/sv.c
index f0287a5..e3571e2 100644
--- a/sv.c
+++ b/sv.c
@@ -5419,7 +5419,8 @@ Perl_sv_clear(pTHX_ register SV *sv)
 		if (destructor
 			/* Don't bother calling an empty destructor */
 			&& (CvISXSUB(destructor)
-			|| CvSTART(destructor)->op_next->op_type != OP_LEAVESUB))
+			|| (CvSTART(destructor)
+			    && (CvSTART(destructor)->op_next->op_type != OP_LEAVESUB))))
 		{
 		    SV* const tmpref = newRV(sv);
 	            SvREADONLY_on(tmpref);   /* DESTROY() could be naughty */
diff --git a/t/op/method.t b/t/op/method.t
index 46c4642..44e672a 100755
--- a/t/op/method.t
+++ b/t/op/method.t
@@ -10,7 +10,7 @@ BEGIN {
     require "test.pl";
 }
 
-print "1..78\n";
+print "1..79\n";
 
 @A::ISA = 'B';
 @B::ISA = 'C';
@@ -293,3 +293,16 @@ EOT
 	"check if UNIVERSAL::AUTOLOAD works",
     );
 }
+
+# Test for #71952: crash when looking for a nonexistent destructor
+# Regression introduced by fbb3ee5af3d4
+{
+    fresh_perl_is(<<'EOT',
+sub M::DESTROY; bless {}, "M" ; print "survived\n";
+EOT
+    "survived",
+    {},
+	"no crash with a declared but missing DESTROY method"
+    );
+}
+
-- 
1.8.1.4


diff -up perl-5.10.1/ext/threads/t/basic.t.oldthread perl-5.10.1/ext/threads/t/basic.t
--- perl-5.10.1/ext/threads/t/basic.t.oldthread	2009-06-10 18:53:46.000000000 +0200
+++ perl-5.10.1/ext/threads/t/basic.t	2011-01-07 13:23:20.841524264 +0100
@@ -2,10 +2,6 @@ use strict;
 use warnings;
 
 BEGIN {
-    if ($ENV{'PERL_CORE'}){
-        chdir 't';
-        unshift @INC, '../lib';
-    }
     use Config;
     if (! $Config{'useithreads'}) {
         print("1..0 # SKIP Perl not compiled with 'useithreads'\n");
@@ -31,12 +27,12 @@ sub ok {
 
 BEGIN {
     $| = 1;
-    print("1..33\n");   ### Number of tests that will be run ###
+    print("1..34\n");   ### Number of tests that will be run ###
 };
 
 use threads;
 
-if ($threads::VERSION && ! exists($ENV{'PERL_CORE'})) {
+if ($threads::VERSION && ! $ENV{'PERL_CORE'}) {
     print(STDERR "# Testing threads $threads::VERSION\n");
 }
 
@@ -157,14 +153,17 @@ $thrx = threads->object();
 ok(30, ! defined($thrx), 'No object');
 $thrx = threads->object(undef);
 ok(31, ! defined($thrx), 'No object');
-$thrx = threads->object(0);
-ok(32, ! defined($thrx), 'No object');
 
 threads->import('stringify');
 $thr1 = threads->create(sub {});
-ok(33, "$thr1" eq $thr1->tid(), 'Stringify');
+ok(32, "$thr1" eq $thr1->tid(), 'Stringify');
 $thr1->join();
 
+# ->object($tid) works like ->self() when $tid is thread's TID
+$thrx = threads->object(threads->tid());
+ok(33, defined($thrx), 'Main thread object');
+ok(34, 0 == $thrx->tid(), "Check so that tid for threads work for main thread");
+
 exit(0);
 
 # EOF
diff -up perl-5.10.1/ext/threads/t/blocks.t.oldthread perl-5.10.1/ext/threads/t/blocks.t
--- perl-5.10.1/ext/threads/t/blocks.t.oldthread	2009-04-15 14:25:00.000000000 +0200
+++ perl-5.10.1/ext/threads/t/blocks.t	2011-01-07 13:23:20.841524264 +0100
@@ -2,10 +2,6 @@ use strict;
 use warnings;
 
 BEGIN {
-    if ($ENV{'PERL_CORE'}){
-        chdir 't';
-        unshift @INC, '../lib';
-    }
     use Config;
     if (! $Config{'useithreads'}) {
         print("1..0 # SKIP Perl not compiled with 'useithreads'\n");
@@ -51,7 +47,7 @@ sub ok {
     } else {
         print("not ok $id - $name\n");
         printf("# Failed test at line %d\n", (caller)[2]);
-        print(STDERR "# FAIL: $name\n") if (! exists($ENV{'PERL_CORE'}));
+        print(STDERR "# FAIL: $name\n") if (! $ENV{'PERL_CORE'});
     }
 
     return ($ok);
diff -up perl-5.10.1/ext/threads/t/context.t.oldthread perl-5.10.1/ext/threads/t/context.t
--- perl-5.10.1/ext/threads/t/context.t.oldthread	2009-04-15 14:25:00.000000000 +0200
+++ perl-5.10.1/ext/threads/t/context.t	2011-01-07 13:23:20.841524264 +0100
@@ -2,10 +2,6 @@ use strict;
 use warnings;
 
 BEGIN {
-    if ($ENV{'PERL_CORE'}){
-        chdir 't';
-        unshift @INC, '../lib';
-    }
     use Config;
     if (! $Config{'useithreads'}) {
         print("1..0 # SKIP Perl not compiled with 'useithreads'\n");
diff -up perl-5.10.1/ext/threads/t/end.t.oldthread perl-5.10.1/ext/threads/t/end.t
--- perl-5.10.1/ext/threads/t/end.t.oldthread	2009-04-15 14:25:00.000000000 +0200
+++ perl-5.10.1/ext/threads/t/end.t	2011-01-07 13:23:20.841524264 +0100
@@ -2,10 +2,6 @@ use strict;
 use warnings;
 
 BEGIN {
-    if ($ENV{'PERL_CORE'}){
-        chdir 't';
-        unshift @INC, '../lib';
-    }
     use Config;
     if (! $Config{'useithreads'}) {
         print("1..0 # SKIP Perl not compiled with 'useithreads'\n");
diff -up perl-5.10.1/ext/threads/t/err.t.oldthread perl-5.10.1/ext/threads/t/err.t
--- perl-5.10.1/ext/threads/t/err.t.oldthread	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/ext/threads/t/err.t	2011-01-07 13:25:13.732532387 +0100
@@ -2,12 +2,7 @@ use strict;
 use warnings;
 
 BEGIN {
-    if ($ENV{'PERL_CORE'}){
-        chdir 't';
-        unshift @INC, '../lib';
-    }
-
-    require($ENV{PERL_CORE} ? "./test.pl" : "./t/test.pl");
+    require($ENV{PERL_CORE} ? './test.pl' : './t/test.pl');
 
     use Config;
     if (! $Config{'useithreads'}) {
diff -up perl-5.10.1/ext/threads/t/exit.t.oldthread perl-5.10.1/ext/threads/t/exit.t
--- perl-5.10.1/ext/threads/t/exit.t.oldthread	2009-04-15 14:25:00.000000000 +0200
+++ perl-5.10.1/ext/threads/t/exit.t	2011-01-07 13:25:24.772534949 +0100
@@ -2,12 +2,7 @@ use strict;
 use warnings;
 
 BEGIN {
-    if ($ENV{'PERL_CORE'}){
-        chdir 't';
-        unshift @INC, '../lib';
-    }
-
-    require($ENV{PERL_CORE} ? "./test.pl" : "./t/test.pl");
+    require($ENV{PERL_CORE} ? './test.pl' : './t/test.pl');
 
     use Config;
     if (! $Config{'useithreads'}) {
@@ -53,7 +48,7 @@ my $rc = $thr->join();
 ok(! defined($rc), 'Exited: threads->exit()');
 
 
-run_perl(prog => 'use threads 1.72;' .
+run_perl(prog => 'use threads 1.82;' .
                  'threads->exit(86);' .
                  'exit(99);',
          nolib => ($ENV{PERL_CORE}) ? 0 : 1,
@@ -103,7 +98,7 @@ $rc = $thr->join();
 ok(! defined($rc), 'Exited: $thr->set_thread_exit_only');
 
 
-run_perl(prog => 'use threads 1.72 qw(exit thread_only);' .
+run_perl(prog => 'use threads 1.82 qw(exit thread_only);' .
                  'threads->create(sub { exit(99); })->join();' .
                  'exit(86);',
          nolib => ($ENV{PERL_CORE}) ? 0 : 1,
@@ -113,7 +108,7 @@ run_perl(prog => 'use threads 1.72 qw(ex
     is($?>>8, 86, "'use threads 'exit' => 'thread_only'");
 }
 
-my $out = run_perl(prog => 'use threads 1.72;' .
+my $out = run_perl(prog => 'use threads 1.82;' .
                            'threads->create(sub {' .
                            '    exit(99);' .
                            '});' .
@@ -129,7 +124,7 @@ my $out = run_perl(prog => 'use threads 
 like($out, '1 finished and unjoined', "exit(status) in thread");
 
 
-$out = run_perl(prog => 'use threads 1.72 qw(exit thread_only);' .
+$out = run_perl(prog => 'use threads 1.82 qw(exit thread_only);' .
                         'threads->create(sub {' .
                         '   threads->set_thread_exit_only(0);' .
                         '   exit(99);' .
@@ -146,7 +141,7 @@ $out = run_perl(prog => 'use threads 1.7
 like($out, '1 finished and unjoined', "set_thread_exit_only(0)");
 
 
-run_perl(prog => 'use threads 1.72;' .
+run_perl(prog => 'use threads 1.82;' .
                  'threads->create(sub {' .
                  '   $SIG{__WARN__} = sub { exit(99); };' .
                  '   die();' .
diff -up perl-5.10.1/ext/threads/t/free2.t.oldthread perl-5.10.1/ext/threads/t/free2.t
--- perl-5.10.1/ext/threads/t/free2.t.oldthread	2009-04-15 14:25:00.000000000 +0200
+++ perl-5.10.1/ext/threads/t/free2.t	2011-01-07 13:25:45.595532316 +0100
@@ -2,11 +2,6 @@ use strict;
 use warnings;
 
 BEGIN {
-    if ($ENV{'PERL_CORE'}){
-        chdir 't';
-        unshift @INC, '../lib';
-    }
-
     # Import test.pl into its own package
     {
         package Test;
diff -up perl-5.10.1/ext/threads/t/free.t.oldthread perl-5.10.1/ext/threads/t/free.t
--- perl-5.10.1/ext/threads/t/free.t.oldthread	2009-04-15 14:25:00.000000000 +0200
+++ perl-5.10.1/ext/threads/t/free.t	2011-01-07 13:25:35.996531735 +0100
@@ -2,11 +2,6 @@ use strict;
 use warnings;
 
 BEGIN {
-    if ($ENV{'PERL_CORE'}){
-        chdir 't';
-        unshift @INC, '../lib';
-    }
-
     # Import test.pl into its own package
     {
         package Test;
diff -up perl-5.10.1/ext/threads/threads.h.oldthread perl-5.10.1/ext/threads/threads.h
--- perl-5.10.1/ext/threads/threads.h.oldthread	2011-01-07 13:23:20.839523118 +0100
+++ perl-5.10.1/ext/threads/threads.h	2011-01-07 13:23:20.839523118 +0100
@@ -0,0 +1,17 @@
+#ifndef _THREADS_H_
+#define _THREADS_H_
+
+/* Needed for 5.8.0 */
+#ifndef CLONEf_JOIN_IN
+#  define CLONEf_JOIN_IN        8
+#endif
+#ifndef SAVEBOOL
+#  define SAVEBOOL(a)
+#endif
+
+/* Added in 5.11.x */
+#ifndef G_WANT
+#  define G_WANT                (128|1)
+#endif
+
+#endif
diff -up perl-5.10.1/ext/threads/threads.pm.oldthread perl-5.10.1/ext/threads/threads.pm
--- perl-5.10.1/ext/threads/threads.pm.oldthread	2009-04-15 14:25:00.000000000 +0200
+++ perl-5.10.1/ext/threads/threads.pm	2011-01-07 13:23:20.840523547 +0100
@@ -5,7 +5,7 @@ use 5.008;
 use strict;
 use warnings;
 
-our $VERSION = '1.72';
+our $VERSION = '1.82';
 my $XS_VERSION = $VERSION;
 $VERSION = eval $VERSION;
 
@@ -134,7 +134,7 @@ threads - Perl interpreter-based threads
 
 =head1 VERSION
 
-This document describes threads version 1.72
+This document describes threads version 1.82
 
 =head1 SYNOPSIS
 
@@ -221,28 +221,38 @@ This document describes threads version 
 
 =head1 DESCRIPTION
 
-Perl 5.6 introduced something called interpreter threads.  Interpreter threads
-are different from I<5005threads> (the thread model of Perl 5.005) by creating
-a new Perl interpreter per thread, and not sharing any data or state between
-threads by default.
-
-Prior to Perl 5.8, this has only been available to people embedding Perl, and
-for emulating fork() on Windows.
-
-The I<threads> API is loosely based on the old Thread.pm API. It is very
-important to note that variables are not shared between threads, all variables
-are by default thread local.  To use shared variables one must also use
-L<threads::shared>:
+Since Perl 5.8, thread programming has been available using a model called
+I<interpreter threads> which provides a new Perl interpreter for each
+thread, and, by default, results in no data or state information being shared
+between threads.
+
+(Prior to Perl 5.8, I<5005threads> was available through the C<Thread.pm> API.
+This threading model has been deprecated, and was removed as of Perl 5.10.0.)
+
+As just mentioned, all variables are, by default, thread local.  To use shared
+variables, you need to also load L<threads::shared>:
 
     use threads;
     use threads::shared;
 
-It is also important to note that you must enable threads by doing C<use
-threads> as early as possible in the script itself, and that it is not
-possible to enable threading inside an C<eval "">, C<do>, C<require>, or
-C<use>.  In particular, if you are intending to share variables with
-L<threads::shared>, you must C<use threads> before you C<use threads::shared>.
-(C<threads> will emit a warning if you do it the other way around.)
+When loading L<threads::shared>, you must C<use threads> before you
+C<use threads::shared>.  (C<threads> will emit a warning if you do it the
+other way around.)
+
+It is strongly recommended that you enable threads via C<use threads> as early
+as possible in your script.
+
+If needed, scripts can be written so as to run on both threaded and
+non-threaded Perls:
+
+    my $can_use_threads = eval 'use threads; 1';
+    if ($can_use_threads) {
+        # Do processing using threads
+        ...
+    } else {
+        # Do it without using threads
+        ...
+    }
 
 =over
 
@@ -351,9 +361,10 @@ key) will cause its ID to be used as the
 =item threads->object($tid)
 
 This will return the I<threads> object for the I<active> thread associated
-with the specified thread ID.  Returns C<undef> if there is no thread
-associated with the TID, if the thread is joined or detached, if no TID is
-specified or if the specified TID is undef.
+with the specified thread ID.  If C<$tid> is the value for the current thread,
+then this call works the same as C<-E<gt>self()>.  Otherwise, returns C<undef>
+if there is no thread associated with the TID, if the thread is joined or
+detached, if no TID is specified or if the specified TID is undef.
 
 =item threads->yield()
 
@@ -892,6 +903,18 @@ other threads are started afterwards.
 If the above does not work, or is not adequate for your application, then file
 a bug report on L<http://rt.cpan.org/Public/> against the problematic module.
 
+=item Memory consumption
+
+On most systems, frequent and continual creation and destruction of threads
+can lead to ever-increasing growth in the memory footprint of the Perl
+interpreter.  While it is simple to just launch threads and then
+C<-E<gt>join()> or C<-E<gt>detach()> them, for long-lived applications, it is
+better to maintain a pool of threads, and to reuse them for the work needed,
+using L<queues|Thread::Queue> to notify threads of pending work.  The CPAN
+distribution of this module contains a simple example
+(F<examples/pool_reuse.pl>) illustrating the creation, use and monitoring of a
+pool of I<reusable> threads.
+
 =item Current working directory
 
 On all platforms except MSWin32, the setting for the current working directory
@@ -965,7 +988,7 @@ involved, you may be able to work around
 version of the object (e.g., using L<Data::Dumper> or L<Storable>), and then
 reconstituting it in the joining thread.  If you're using Perl 5.10.0 or
 later, and if the class supports L<shared objects|threads::shared/"OBJECTS">,
-you can pass them via L<shared queues| Thread::Queue>.
+you can pass them via L<shared queues|Thread::Queue>.
 
 =item END blocks in threads
 
@@ -982,6 +1005,18 @@ mutexes that are needed to control funct
 For this reason, the use of C<END> blocks in threads is B<strongly>
 discouraged.
 
+=item Open directory handles
+
+In perl 5.14 and higher, on systems other than Windows that do
+not support the C<fchdir> C function, directory handles (see
+L<opendir|perlfunc/"opendir DIRHANDLE,EXPR">) will not be copied to new
+threads. You can use the C<d_fchdir> variable in L<Config.pm|Config> to
+determine whether your system supports it.
+
+In prior perl versions, spawning threads with open directory handles would
+crash the interpreter.
+L<[perl #75154]|http://rt.perl.org/rt3/Public/Bug/Display.html?id=75154>
+
 =item Perl Bugs and the CPAN Version of L<threads>
 
 Support for threads extends beyond the code in this module (i.e.,
@@ -1010,12 +1045,6 @@ Perl 5.8.0 or later
 L<threads> Discussion Forum on CPAN:
 L<http://www.cpanforum.com/dist/threads>
 
-Annotated POD for L<threads>:
-L<http://annocpan.org/~JDHEDDEN/threads-1.72/threads.pm>
-
-Source repository:
-L<http://code.google.com/p/threads-shared/>
-
 L<threads::shared>, L<perlthrtut>
 
 L<http://www.perl.com/pub/a/2002/06/11/threads.html> and
diff -up perl-5.10.1/ext/threads/threads.xs.oldthread perl-5.10.1/ext/threads/threads.xs
--- perl-5.10.1/ext/threads/threads.xs.oldthread	2009-04-12 18:39:06.000000000 +0200
+++ perl-5.10.1/ext/threads/threads.xs	2011-01-07 13:23:20.840523547 +0100
@@ -1,11 +1,17 @@
 #define PERL_NO_GET_CONTEXT
+/* Workaround for mingw 32-bit compiler by mingw-w64.sf.net - has to come before any #include.
+ * It also defines USE_NO_MINGW_SETJMP_TWO_ARGS for the mingw.org 32-bit compilers ... but
+ * that's ok as that compiler makes no use of that symbol anyway */
+#if defined(WIN32) && defined(__MINGW32__) && !defined(__MINGW64__)
+#  define USE_NO_MINGW_SETJMP_TWO_ARGS 1
+#endif
 #include "EXTERN.h"
 #include "perl.h"
 #include "XSUB.h"
 /* Workaround for XSUB.h bug under WIN32 */
 #ifdef WIN32
 #  undef setjmp
-#  if !defined(__BORLANDC__)
+#  if defined(USE_NO_MINGW_SETJMP_TWO_ARGS) || (!defined(__BORLANDC__) && !defined(__MINGW64__))
 #    define setjmp(x) _setjmp(x)
 #  endif
 #endif
@@ -46,7 +52,7 @@ typedef perl_os_thread pthread_t;
 
 /* Values for 'state' member */
 #define PERL_ITHR_DETACHED           1 /* Thread has been detached */
-#define PERL_ITHR_JOINED             2 /* Thread has been joined */
+#define PERL_ITHR_JOINED             2 /* Thread is being / has been joined */
 #define PERL_ITHR_FINISHED           4 /* Thread has finished execution */
 #define PERL_ITHR_THREAD_EXIT_ONLY   8 /* exit() only exits current thread */
 #define PERL_ITHR_NONVIABLE         16 /* Thread creation failed */
@@ -65,7 +71,7 @@ typedef struct _ithread {
     int state;                  /* Detached, joined, finished, etc. */
     int gimme;                  /* Context of create */
     SV *init_function;          /* Code to run */
-    SV *params;                 /* Args to pass function */
+    AV *params;                 /* Args to pass function */
 #ifdef WIN32
     DWORD  thr;                 /* OS's idea if thread id */
     HANDLE handle;              /* OS's waitable handle */
@@ -75,6 +81,9 @@ typedef struct _ithread {
     IV stack_size;
     SV *err;                    /* Error from abnormally terminated thread */
     char *err_class;            /* Error object's classname if applicable */
+#ifndef WIN32
+    sigset_t initial_sigmask;   /* Thread wakes up with signals blocked */
+#endif
 } ithread;
 
 
@@ -114,6 +123,45 @@ typedef struct {
 
 #define MY_POOL (*my_poolp)
 
+#ifndef WIN32
+/* Block most signals for calling thread, setting the old signal mask to
+ * oldmask, if it is not NULL */
+STATIC int
+S_block_most_signals(sigset_t *oldmask)
+{
+    sigset_t newmask;
+
+    sigfillset(&newmask);
+    /* Don't block certain "important" signals (stolen from mg.c) */
+#ifdef SIGILL
+    sigdelset(&newmask, SIGILL);
+#endif
+#ifdef SIGBUS
+    sigdelset(&newmask, SIGBUS);
+#endif
+#ifdef SIGSEGV
+    sigdelset(&newmask, SIGSEGV);
+#endif
+
+#if defined(VMS)
+    /* no per-thread blocking available */
+    return sigprocmask(SIG_BLOCK, &newmask, oldmask);
+#else
+    return pthread_sigmask(SIG_BLOCK, &newmask, oldmask);
+#endif /* VMS */
+}
+
+/* Set the signal mask for this thread to newmask */
+STATIC int
+S_set_sigmask(sigset_t *newmask)
+{
+#if defined(VMS)
+    return sigprocmask(SIG_SETMASK, newmask, NULL);
+#else
+    return pthread_sigmask(SIG_SETMASK, newmask, NULL);
+#endif /* VMS */
+}
+#endif /* WIN32 */
 
 /* Used by Perl interpreter for thread context switching */
 STATIC void
@@ -142,12 +190,23 @@ STATIC void
 S_ithread_clear(pTHX_ ithread *thread)
 {
     PerlInterpreter *interp;
+#ifndef WIN32
+    sigset_t origmask;
+#endif
 
     assert(((thread->state & PERL_ITHR_FINISHED) &&
             (thread->state & PERL_ITHR_UNCALLABLE))
                 ||
            (thread->state & PERL_ITHR_NONVIABLE));
 
+#ifndef WIN32
+    /* We temporarily set the interpreter context to the interpreter being
+     * destroyed.  It's in no condition to handle signals while it's being
+     * taken apart.
+     */
+    S_block_most_signals(&origmask);
+#endif
+
     interp = thread->interp;
     if (interp) {
         dTHXa(interp);
@@ -156,7 +215,7 @@ S_ithread_clear(pTHX_ ithread *thread)
         S_ithread_set(aTHX_ thread);
 
         SvREFCNT_dec(thread->params);
-        thread->params = Nullsv;
+        thread->params = NULL;
 
         if (thread->err) {
             SvREFCNT_dec(thread->err);
@@ -169,6 +228,9 @@ S_ithread_clear(pTHX_ ithread *thread)
     }
 
     PERL_SET_CONTEXT(aTHX);
+#ifndef WIN32
+    S_set_sigmask(&origmask);
+#endif
 }
 
 
@@ -301,6 +363,7 @@ int
 ithread_mg_free(pTHX_ SV *sv, MAGIC *mg)
 {
     ithread *thread = (ithread *)mg->mg_ptr;
+    PERL_UNUSED_ARG(sv);
     MUTEX_LOCK(&thread->mutex);
     S_ithread_free(aTHX_ thread);   /* Releases MUTEX */
     return (0);
@@ -309,6 +372,7 @@ ithread_mg_free(pTHX_ SV *sv, MAGIC *mg)
 int
 ithread_mg_dup(pTHX_ MAGIC *mg, CLONE_PARAMS *param)
 {
+    PERL_UNUSED_ARG(param);
     S_ithread_count_inc(aTHX_ (ithread *)mg->mg_ptr);
     return (0);
 }
@@ -415,10 +479,17 @@ S_ithread_run(void * arg)
     PERL_SET_CONTEXT(thread->interp);
     S_ithread_set(aTHX_ thread);
 
+#ifndef WIN32
+    /* Thread starts with most signals blocked - restore the signal mask from
+     * the ithread struct.
+     */
+    S_set_sigmask(&thread->initial_sigmask);
+#endif
+
     PL_perl_destruct_level = 2;
 
     {
-        AV *params = (AV *)SvRV(thread->params);
+        AV *params = thread->params;
         int len = (int)av_len(params)+1;
         int ii;
 
@@ -448,6 +519,14 @@ S_ithread_run(void * arg)
         }
         JMPENV_POP;
 
+#ifndef WIN32
+        /* The interpreter is finished, so this thread can stop receiving
+         * signals.  This way, our signal handler doesn't get called in the
+         * middle of our parent thread calling perl_destruct()...
+         */
+        S_block_most_signals(NULL);
+#endif
+
         /* Remove args from stack and put back in params array */
         SPAGAIN;
         for (ii=len-1; ii >= 0; ii--) {
@@ -598,13 +677,18 @@ S_ithread_create(
         IV        stack_size,
         int       gimme,
         int       exit_opt,
-        SV       *params)
+        SV      **params_start,
+        SV      **params_end)
 {
     ithread     *thread;
     ithread     *current_thread = S_ithread_get(aTHX);
+    AV          *params;
+    SV          **array;
 
+#if PERL_VERSION <= 8 && PERL_SUBVERSION <= 7
     SV         **tmps_tmp = PL_tmps_stack;
     IV           tmps_ix  = PL_tmps_ix;
+#endif
 #ifndef WIN32
     int          rc_stack_size = 0;
     int          rc_thread_create = 0;
@@ -660,6 +744,27 @@ S_ithread_create(
     PL_srand_called = FALSE;   /* Set it to false so we can detect if it gets
                                   set during the clone */
 
+#ifndef WIN32
+    /* perl_clone() will leave us the new interpreter's context.  This poses
+     * two problems for our signal handler.  First, it sets the new context
+     * before the new interpreter struct is fully initialized, so our signal
+     * handler might find bogus data in the interpreter struct it gets.
+     * Second, even if the interpreter is initialized before a signal comes in,
+     * we would like to avoid that interpreter receiving notifications for
+     * signals (especially when they ought to be for the one running in this
+     * thread), until it is running in its own thread.  Another problem is that
+     * the new thread will not have set the context until some time after it
+     * has started, so it won't be safe for our signal handler to run until
+     * that time.
+     *
+     * So we block most signals here, so the new thread will inherit the signal
+     * mask, and unblock them right after the thread creation.  The original
+     * mask is saved in the thread struct so that the new thread can restore
+     * the original mask.
+     */
+    S_block_most_signals(&thread->initial_sigmask);
+#endif
+
 #ifdef WIN32
     thread->interp = perl_clone(aTHX, CLONEf_KEEP_PTR_TABLE | CLONEf_CLONE_HOST);
 #else
@@ -671,6 +776,7 @@ S_ithread_create(
      * context for the duration of our work for new interpreter.
      */
     {
+#if (PERL_VERSION < 13) || (PERL_VERSION == 13 && PERL_SUBVERSION <= 1)
         CLONE_PARAMS clone_param;
 
         dTHXa(thread->interp);
@@ -681,7 +787,7 @@ S_ithread_create(
          * they are created
          */
         SvREFCNT_dec(PL_endav);
-        PL_endav = newAV();
+        PL_endav = NULL;
 
         clone_param.flags = 0;
         if (SvPOK(init_function)) {
@@ -689,12 +795,47 @@ S_ithread_create(
             sv_copypv(thread->init_function, init_function);
         } else {
             thread->init_function =
-		SvREFCNT_inc(sv_dup(init_function, &clone_param));
+                SvREFCNT_inc(sv_dup(init_function, &clone_param));
+        }
+
+        thread->params = params = newAV();
+        av_extend(params, params_end - params_start - 1);
+        AvFILLp(params) = params_end - params_start - 1;
+        array = AvARRAY(params);
+        while (params_start < params_end) {
+            *array++ = SvREFCNT_inc(sv_dup(*params_start++, &clone_param));
         }
+#else
+        CLONE_PARAMS *clone_param = Perl_clone_params_new(aTHX, thread->interp);
+
+        dTHXa(thread->interp);
 
-        thread->params = sv_dup(params, &clone_param);
-        SvREFCNT_inc_void(thread->params);
+        MY_CXT_CLONE;
+
+        /* Here we remove END blocks since they should only run in the thread
+         * they are created
+         */
+        SvREFCNT_dec(PL_endav);
+        PL_endav = NULL;
+
+        if (SvPOK(init_function)) {
+            thread->init_function = newSV(0);
+            sv_copypv(thread->init_function, init_function);
+        } else {
+            thread->init_function = sv_dup_inc(init_function, clone_param);
+        }
+
+        thread->params = params = newAV();
+        av_extend(params, params_end - params_start - 1);
+        AvFILLp(params) = params_end - params_start - 1;
+        array = AvARRAY(params);
+        while (params_start < params_end) {
+            *array++ = SvREFCNT_inc(sv_dup(*params_start++, clone_param));
+        }
+        Perl_clone_params_del(clone_param);
+#endif
 
+#if PERL_VERSION <= 8 && PERL_SUBVERSION <= 7
         /* The code below checks that anything living on the tmps stack and
          * has been cloned (so it lives in the ptr_table) has a refcount
          * higher than 0.
@@ -707,7 +848,7 @@ S_ithread_create(
          * Example of this can be found in bugreport 15837 where calls in the
          * parameter list end up as a temp.
          *
-         * One could argue that this fix should be in perl_clone.
+         * As of 5.8.8 this is done in perl_clone.
          */
         while (tmps_ix > 0) {
             SV* sv = (SV*)ptr_table_fetch(PL_ptr_table, tmps_tmp[tmps_ix]);
@@ -717,6 +858,7 @@ S_ithread_create(
                 SvREFCNT_dec(sv);
             }
         }
+#endif
 
         SvTEMP_off(thread->init_function);
         ptr_table_free(PL_ptr_table);
@@ -774,6 +916,13 @@ S_ithread_create(
 #  endif
         }
 
+#ifndef WIN32
+    /* Now it's safe to accept signals, since we're in our own interpreter's
+     * context and we have created the thread.
+     */
+    S_set_sigmask(&thread->initial_sigmask);
+#endif
+
 #  ifdef _POSIX_THREAD_ATTR_STACKSIZE
         /* Try to get thread's actual stack size */
         {
@@ -799,7 +948,6 @@ S_ithread_create(
 #endif
         /* Must unlock mutex for destruct call */
         MUTEX_UNLOCK(&MY_POOL.create_destruct_mutex);
-        sv_2mortal(params);
         thread->state |= PERL_ITHR_NONVIABLE;
         S_ithread_free(aTHX_ thread);   /* Releases MUTEX */
 #ifndef WIN32
@@ -815,7 +963,6 @@ S_ithread_create(
     }
 
     MY_POOL.running_threads++;
-    sv_2mortal(params);
     return (thread);
 }
 
@@ -833,7 +980,6 @@ ithread_create(...)
         char *classname;
         ithread *thread;
         SV *function_to_call;
-        AV *params;
         HV *specs;
         IV stack_size;
         int context;
@@ -841,7 +987,8 @@ ithread_create(...)
         SV *thread_exit_only;
         char *str;
         int idx;
-        int ii;
+        SV **args_start;
+        SV **args_end;
         dMY_POOL;
     CODE:
         if ((items >= 2) && SvROK(ST(1)) && SvTYPE(SvRV(ST(1)))==SVt_PVHV) {
@@ -879,18 +1026,19 @@ ithread_create(...)
 
         context = -1;
         if (specs) {
+            SV **svp;
             /* stack_size */
-            if (hv_exists(specs, "stack", 5)) {
-                stack_size = SvIV(*hv_fetch(specs, "stack", 5, 0));
-            } else if (hv_exists(specs, "stacksize", 9)) {
-                stack_size = SvIV(*hv_fetch(specs, "stacksize", 9, 0));
-            } else if (hv_exists(specs, "stack_size", 10)) {
-                stack_size = SvIV(*hv_fetch(specs, "stack_size", 10, 0));
+            if ((svp = hv_fetch(specs, "stack", 5, 0))) {
+                stack_size = SvIV(*svp);
+            } else if ((svp = hv_fetch(specs, "stacksize", 9, 0))) {
+                stack_size = SvIV(*svp);
+            } else if ((svp = hv_fetch(specs, "stack_size", 10, 0))) {
+                stack_size = SvIV(*svp);
             }
 
             /* context */
-            if (hv_exists(specs, "context", 7)) {
-                str = (char *)SvPV_nolen(*hv_fetch(specs, "context", 7, 0));
+            if ((svp = hv_fetch(specs, "context", 7, 0))) {
+                str = (char *)SvPV_nolen(*svp);
                 switch (*str) {
                     case 'a':
                     case 'A':
@@ -909,27 +1057,27 @@ ithread_create(...)
                     default:
                         Perl_croak(aTHX_ "Invalid context: %s", str);
                 }
-            } else if (hv_exists(specs, "array", 5)) {
-                if (SvTRUE(*hv_fetch(specs, "array", 5, 0))) {
+            } else if ((svp = hv_fetch(specs, "array", 5, 0))) {
+                if (SvTRUE(*svp)) {
                     context = G_ARRAY;
                 }
-            } else if (hv_exists(specs, "list", 4)) {
-                if (SvTRUE(*hv_fetch(specs, "list", 4, 0))) {
+            } else if ((svp = hv_fetch(specs, "list", 4, 0))) {
+                if (SvTRUE(*svp)) {
                     context = G_ARRAY;
                 }
-            } else if (hv_exists(specs, "scalar", 6)) {
-                if (SvTRUE(*hv_fetch(specs, "scalar", 6, 0))) {
+            } else if ((svp = hv_fetch(specs, "scalar", 6, 0))) {
+                if (SvTRUE(*svp)) {
                     context = G_SCALAR;
                 }
-            } else if (hv_exists(specs, "void", 4)) {
-                if (SvTRUE(*hv_fetch(specs, "void", 4, 0))) {
+            } else if ((svp = hv_fetch(specs, "void", 4, 0))) {
+                if (SvTRUE(*svp)) {
                     context = G_VOID;
                 }
             }
 
             /* exit => thread_only */
-            if (hv_exists(specs, "exit", 4)) {
-                str = (char *)SvPV_nolen(*hv_fetch(specs, "exit", 4, 0));
+            if ((svp = hv_fetch(specs, "exit", 4, 0))) {
+                str = (char *)SvPV_nolen(*svp);
                 exit_opt = (*str == 't' || *str == 'T')
                                     ? PERL_ITHR_THREAD_EXIT_ONLY : 0;
             }
@@ -941,11 +1089,11 @@ ithread_create(...)
         }
 
         /* Function args */
-        params = newAV();
+        args_start = &ST(idx + 2);
         if (items > 2) {
-            for (ii=2; ii < items ; ii++) {
-                av_push(params, SvREFCNT_inc(ST(idx+ii)));
-            }
+            args_end = &ST(idx + items);
+        } else {
+            args_end = args_start;
         }
 
         /* Create thread */
@@ -954,7 +1102,8 @@ ithread_create(...)
                                         stack_size,
                                         context,
                                         exit_opt,
-                                        newRV_noinc((SV*)params));
+                                        args_start,
+                                        args_end);
         if (! thread) {
             XSRETURN_UNDEF;     /* Mutex already unlocked */
         }
@@ -1123,11 +1272,12 @@ ithread_join(...)
         /* Get the return value from the call_sv */
         /* Objects do not survive this process - FIXME */
         if ((thread->gimme & G_WANT) != G_VOID) {
+#if (PERL_VERSION < 13) || (PERL_VERSION == 13 && PERL_SUBVERSION <= 1)
             AV *params_copy;
             PerlInterpreter *other_perl;
             CLONE_PARAMS clone_params;
 
-            params_copy = (AV *)SvRV(thread->params);
+            params_copy = thread->params;
             other_perl = thread->interp;
             clone_params.stashes = newAV();
             clone_params.flags = CLONEf_JOIN_IN;
@@ -1143,6 +1293,26 @@ ithread_join(...)
             SvREFCNT_inc_void(params);
             ptr_table_free(PL_ptr_table);
             PL_ptr_table = NULL;
+#else
+            AV *params_copy;
+            PerlInterpreter *other_perl = thread->interp;
+            CLONE_PARAMS *clone_params = Perl_clone_params_new(other_perl, aTHX);
+
+            params_copy = thread->params;
+            clone_params->flags |= CLONEf_JOIN_IN;
+            PL_ptr_table = ptr_table_new();
+            S_ithread_set(aTHX_ thread);
+            /* Ensure 'meaningful' addresses retain their meaning */
+            ptr_table_store(PL_ptr_table, &other_perl->Isv_undef, &PL_sv_undef);
+            ptr_table_store(PL_ptr_table, &other_perl->Isv_no, &PL_sv_no);
+            ptr_table_store(PL_ptr_table, &other_perl->Isv_yes, &PL_sv_yes);
+            params = (AV *)sv_dup((SV*)params_copy, clone_params);
+            S_ithread_set(aTHX_ current_thread);
+            Perl_clone_params_del(clone_params);
+            SvREFCNT_inc_void(params);
+            ptr_table_free(PL_ptr_table);
+            PL_ptr_table = NULL;
+#endif
         }
 
         /* If thread didn't die, then we can free its interpreter */
@@ -1228,6 +1398,7 @@ ithread_kill(...)
         ithread *thread;
         char *sig_name;
         IV signal;
+        int no_handler = 1;
     CODE:
         /* Must have safe signals */
         if (PL_signals & PERL_SIGNALS_UNSAFE_FLAG) {
@@ -1257,11 +1428,21 @@ ithread_kill(...)
         MUTEX_LOCK(&thread->mutex);
         if (thread->interp) {
             dTHXa(thread->interp);
-            PL_psig_pend[signal]++;
-            PL_sig_pending = 1;
+            if (PL_psig_pend && PL_psig_ptr[signal]) {
+                PL_psig_pend[signal]++;
+                PL_sig_pending = 1;
+                no_handler = 0;
+            }
+        } else {
+            /* Ignore signal to terminated thread */
+            no_handler = 0;
         }
         MUTEX_UNLOCK(&thread->mutex);
 
+        if (no_handler) {
+            Perl_croak(aTHX_ "Signal %s received in thread %"UVuf", but no signal handler set.", sig_name, thread->tid);
+        }
+
         /* Return the thread to allow for method chaining */
         ST(0) = ST(0);
         /* XSRETURN(1); - implied */
@@ -1300,6 +1481,7 @@ void
 ithread_object(...)
     PREINIT:
         char *classname;
+        SV *arg;
         UV tid;
         ithread *thread;
         int state;
@@ -1312,34 +1494,47 @@ ithread_object(...)
         }
         classname = (char *)SvPV_nolen(ST(0));
 
-        if ((items < 2) || ! SvOK(ST(1))) {
+        /* Turn $tid from PVLV to SV if needed (bug #73330) */
+        arg = ST(1);
+        SvGETMAGIC(arg);
+
+        if ((items < 2) || ! SvOK(arg)) {
             XSRETURN_UNDEF;
         }
 
         /* threads->object($tid) */
-        tid = SvUV(ST(1));
+        tid = SvUV(arg);
 
-        /* Walk through threads list */
-        MUTEX_LOCK(&MY_POOL.create_destruct_mutex);
-        for (thread = MY_POOL.main_thread.next;
-             thread != &MY_POOL.main_thread;
-             thread = thread->next)
-        {
-            /* Look for TID */
-            if (thread->tid == tid) {
-                /* Ignore if detached or joined */
-                MUTEX_LOCK(&thread->mutex);
-                state = thread->state;
-                MUTEX_UNLOCK(&thread->mutex);
-                if (! (state & PERL_ITHR_UNCALLABLE)) {
-                    /* Put object on stack */
-                    ST(0) = sv_2mortal(S_ithread_to_SV(aTHX_ Nullsv, thread, classname, TRUE));
-                    have_obj = 1;
+        /* If current thread wants its own object, then behave the same as
+           ->self() */
+        thread = S_ithread_get(aTHX);
+        if (thread->tid == tid) {
+            ST(0) = sv_2mortal(S_ithread_to_SV(aTHX_ Nullsv, thread, classname, TRUE));
+            have_obj = 1;
+
+        } else {
+            /* Walk through threads list */
+            MUTEX_LOCK(&MY_POOL.create_destruct_mutex);
+            for (thread = MY_POOL.main_thread.next;
+                 thread != &MY_POOL.main_thread;
+                 thread = thread->next)
+            {
+                /* Look for TID */
+                if (thread->tid == tid) {
+                    /* Ignore if detached or joined */
+                    MUTEX_LOCK(&thread->mutex);
+                    state = thread->state;
+                    MUTEX_UNLOCK(&thread->mutex);
+                    if (! (state & PERL_ITHR_UNCALLABLE)) {
+                        /* Put object on stack */
+                        ST(0) = sv_2mortal(S_ithread_to_SV(aTHX_ Nullsv, thread, classname, TRUE));
+                        have_obj = 1;
+                    }
+                    break;
                 }
-                break;
             }
+            MUTEX_UNLOCK(&MY_POOL.create_destruct_mutex);
         }
-        MUTEX_UNLOCK(&MY_POOL.create_destruct_mutex);
 
         if (! have_obj) {
             XSRETURN_UNDEF;
@@ -1499,6 +1694,7 @@ ithread_error(...)
 
         /* If thread died, then clone the error into the calling thread */
         if (thread->state & PERL_ITHR_DIED) {
+#if (PERL_VERSION < 13) || (PERL_VERSION == 13 && PERL_SUBVERSION <= 1)
             PerlInterpreter *other_perl;
             CLONE_PARAMS clone_params;
             ithread *current_thread;
@@ -1523,6 +1719,30 @@ ithread_error(...)
             }
             ptr_table_free(PL_ptr_table);
             PL_ptr_table = NULL;
+#else
+            PerlInterpreter *other_perl = thread->interp;
+            CLONE_PARAMS *clone_params = Perl_clone_params_new(other_perl, aTHX);
+            ithread *current_thread;
+
+            clone_params->flags |= CLONEf_JOIN_IN;
+            PL_ptr_table = ptr_table_new();
+            current_thread = S_ithread_get(aTHX);
+            S_ithread_set(aTHX_ thread);
+            /* Ensure 'meaningful' addresses retain their meaning */
+            ptr_table_store(PL_ptr_table, &other_perl->Isv_undef, &PL_sv_undef);
+            ptr_table_store(PL_ptr_table, &other_perl->Isv_no, &PL_sv_no);
+            ptr_table_store(PL_ptr_table, &other_perl->Isv_yes, &PL_sv_yes);
+            err = sv_dup(thread->err, clone_params);
+            S_ithread_set(aTHX_ current_thread);
+            Perl_clone_params_del(clone_params);
+            SvREFCNT_inc_void(err);
+            /* If error was an object, bless it into the correct class */
+            if (thread->err_class) {
+                sv_bless(err, gv_stashpv(thread->err_class, 1));
+            }
+            ptr_table_free(PL_ptr_table);
+            PL_ptr_table = NULL;
+#endif
         }
 
         MUTEX_UNLOCK(&thread->mutex);
diff -up perl-5.10.1/ext/threads/t/join.t.oldthread perl-5.10.1/ext/threads/t/join.t
--- perl-5.10.1/ext/threads/t/join.t.oldthread	2009-04-15 14:25:00.000000000 +0200
+++ perl-5.10.1/ext/threads/t/join.t	2011-01-07 13:23:20.842522955 +0100
@@ -2,10 +2,6 @@ use strict;
 use warnings;
 
 BEGIN {
-    if ($ENV{'PERL_CORE'}){
-        chdir 't';
-        unshift @INC, '../lib';
-    }
     use Config;
     if (! $Config{'useithreads'}) {
         print("1..0 # SKIP Perl not compiled with 'useithreads'\n");
diff -up perl-5.10.1/ext/threads/t/kill2.t.oldthread perl-5.10.1/ext/threads/t/kill2.t
--- perl-5.10.1/ext/threads/t/kill2.t.oldthread	2011-01-07 13:23:20.842522955 +0100
+++ perl-5.10.1/ext/threads/t/kill2.t	2011-01-07 13:23:20.842522955 +0100
@@ -0,0 +1,91 @@
+use strict;
+use warnings;
+
+BEGIN {
+    require($ENV{PERL_CORE} ? '../../t/test.pl' : './t/test.pl');
+
+    use Config;
+    if (! $Config{'useithreads'}) {
+        skip_all(q/Perl not compiled with 'useithreads'/);
+    }
+}
+
+use ExtUtils::testlib;
+
+use threads;
+
+BEGIN {
+    if (! eval 'use threads::shared; 1') {
+        skip_all('threads::shared not available');
+    }
+
+    local $SIG{'HUP'} = sub {};
+    my $thr = threads->create(sub {});
+    eval { $thr->kill('HUP') };
+    $thr->join();
+    if ($@ && $@ =~ /safe signals/) {
+        skip_all('Not using safe signals');
+    }
+
+    plan(3);
+};
+
+fresh_perl_is(<<'EOI', 'ok', { }, 'No signal handler in thread');
+    use threads;
+    use Thread::Semaphore;
+    my $sema = Thread::Semaphore->new(0);
+    my $test = sub {
+        my $sema = shift;
+        $sema->up();
+        while(1) { sleep(1); }
+    };
+    my $thr = threads->create($test, $sema);
+    $sema->down();
+    $thr->detach();
+    eval {
+        $thr->kill('STOP');
+    };
+    print(($@ =~ /no signal handler set/) ? 'ok' : 'not ok');
+EOI
+
+fresh_perl_is(<<'EOI', 'ok', { }, 'Handler to signal mismatch');
+    use threads;
+    use Thread::Semaphore;
+    my $sema = Thread::Semaphore->new(0);
+    my $test = sub {
+        my $sema = shift;
+        $SIG{'TERM'} = sub { threads->exit() };
+        $sema->up();
+        while(1) { sleep(1); }
+    };
+    my $thr = threads->create($test, $sema);
+    $sema->down();
+    $thr->detach();
+    eval {
+        $thr->kill('STOP');
+    };
+    print(($@ =~ /no signal handler set/) ? 'ok' : 'not ok');
+EOI
+
+fresh_perl_is(<<'EOI', 'ok', { }, 'Handler and signal match');
+    use threads;
+    use Thread::Semaphore;
+    my $sema = Thread::Semaphore->new(0);
+    my $test = sub {
+        my $sema = shift;
+        $SIG{'STOP'} = sub { threads->exit() };
+        $sema->up();
+        while(1) { sleep(1); }
+    };
+    my $thr = threads->create($test, $sema);
+    $sema->down();
+    $thr->detach();
+    eval {
+        $thr->kill('STOP');
+    };
+    print((! $@) ? 'ok' : 'not ok');
+EOI
+
+exit(0);
+
+# EOF
diff -up perl-5.10.1/ext/threads/t/kill.t.oldthread perl-5.10.1/ext/threads/t/kill.t
--- perl-5.10.1/ext/threads/t/kill.t.oldthread	2009-04-15 14:25:00.000000000 +0200
+++ perl-5.10.1/ext/threads/t/kill.t	2011-01-07 13:23:20.842522955 +0100
@@ -2,10 +2,6 @@ use strict;
 use warnings;
 
 BEGIN {
-    if ($ENV{'PERL_CORE'}){
-        chdir 't';
-        unshift @INC, '../lib';
-    }
     use Config;
     if (! $Config{'useithreads'}) {
         print("1..0 # SKIP Perl not compiled with 'useithreads'\n");
diff -up perl-5.10.1/ext/threads/t/libc.t.oldthread perl-5.10.1/ext/threads/t/libc.t
--- perl-5.10.1/ext/threads/t/libc.t.oldthread	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/ext/threads/t/libc.t	2011-01-07 13:25:54.827532083 +0100
@@ -2,12 +2,7 @@ use strict;
 use warnings;
 
 BEGIN {
-    if ($ENV{'PERL_CORE'}){
-        chdir 't';
-        unshift @INC, '../lib';
-    }
-
-    require($ENV{PERL_CORE} ? "./test.pl" : "./t/test.pl");
+    require($ENV{PERL_CORE} ? './test.pl' : './t/test.pl');
 
     use Config;
     if (! $Config{'useithreads'}) {
diff -up perl-5.10.1/ext/threads/t/list.t.oldthread perl-5.10.1/ext/threads/t/list.t
--- perl-5.10.1/ext/threads/t/list.t.oldthread	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/ext/threads/t/list.t	2011-01-07 13:23:20.843523692 +0100
@@ -2,10 +2,6 @@ use strict;
 use warnings;
 
 BEGIN {
-    if ($ENV{'PERL_CORE'}){
-        chdir 't';
-        unshift @INC, '../lib';
-    }
     use Config;
     if (! $Config{'useithreads'}) {
         print("1..0 # SKIP Perl not compiled with 'useithreads'\n");
diff -up perl-5.10.1/ext/threads/t/no_threads.t.oldthread perl-5.10.1/ext/threads/t/no_threads.t
--- perl-5.10.1/ext/threads/t/no_threads.t.oldthread	2011-01-07 13:23:20.843523692 +0100
+++ perl-5.10.1/ext/threads/t/no_threads.t	2011-01-07 13:23:20.843523692 +0100
@@ -0,0 +1,39 @@
+use strict;
+use warnings;
+
+BEGIN {
+    use Config;
+    if ($Config{'useithreads'}) {
+        print("1..0 # SKIP Perl compiled with 'useithreads'\n");
+        exit(0);
+    }
+}
+
+use ExtUtils::testlib;
+
+sub ok {
+    my ($id, $ok, $name) = @_;
+
+    # You have to do it this way or VMS will get confused.
+    if ($ok) {
+        print("ok $id - $name\n");
+    } else {
+        print("not ok $id - $name\n");
+        printf("# Failed test at line %d\n", (caller)[2]);
+    }
+
+    return ($ok);
+}
+
+BEGIN {
+    $| = 1;
+    print("1..1\n");   ### Number of tests that will be run ###
+};
+
+eval 'use threads; 1';
+
+ok(1, (($@ =~ /not built to support thread/)?1:0), "No threads support");
+
+exit(0);
+
+# EOF
diff -up perl-5.10.1/ext/threads/t/pod.t.oldthread perl-5.10.1/ext/threads/t/pod.t
--- perl-5.10.1/ext/threads/t/pod.t.oldthread	2011-01-07 13:23:20.843523692 +0100
+++ perl-5.10.1/ext/threads/t/pod.t	2011-01-07 13:23:20.843523692 +0100
@@ -0,0 +1,84 @@
+use strict;
+use warnings;
+
+use Test::More;
+if ($ENV{RUN_MAINTAINER_TESTS}) {
+    plan 'tests' => 3;
+} else {
+    plan 'skip_all' => 'Module maintainer tests';
+}
+
+SKIP: {
+    if (! eval 'use Test::Pod 1.26; 1') {
+        skip('Test::Pod 1.26 required for testing POD', 1);
+    }
+
+    pod_file_ok('lib/threads.pm');
+}
+
+SKIP: {
+    if (! eval 'use Test::Pod::Coverage 1.08; 1') {
+        skip('Test::Pod::Coverage 1.08 required for testing POD coverage', 1);
+    }
+
+    pod_coverage_ok('threads',
+                    {
+                        'trustme' => [
+                            qr/^new$/,
+                            qr/^exit$/,
+                            qr/^async$/,
+                            qr/^\(/,
+                            qr/^(all|running|joinable)$/,
+                        ],
+                        'private' => [
+                            qr/^import$/,
+                            qr/^DESTROY$/,
+                            qr/^bootstrap$/,
+                        ]
+                    }
+    );
+}
+
+SKIP: {
+    if (! eval 'use Test::Spelling; 1') {
+        skip('Test::Spelling required for testing POD spelling', 1);
+    }
+    if (system('aspell help >/dev/null 2>&1')) {
+        skip(q/'aspell' required for testing POD spelling/, 1);
+    }
+    set_spell_cmd('aspell list --lang=en');
+    add_stopwords(<DATA>);
+    pod_file_spelling_ok('lib/threads.pm', 'thread.pm spelling');
+    unlink("/home/$ENV{'USER'}/en.prepl", "/home/$ENV{'USER'}/en.pws");
+}
+
+exit(0);
+
+__DATA__
+
+API
+async
+cpan
+MSWin32
+pthreads
+SIGTERM
+TID
+Config.pm
+
+Hedden
+Soderberg
+crystalflame
+brecon
+netrus
+Rocco
+Caputo
+netrus
+vipul
+Ved
+Prakash
+presicient
+
+okay
+unjoinable
+
+__END__
diff -up perl-5.10.1/ext/threads/t/problems.t.oldthread perl-5.10.1/ext/threads/t/problems.t
--- perl-5.10.1/ext/threads/t/problems.t.oldthread	2009-04-15 14:25:00.000000000 +0200
+++ perl-5.10.1/ext/threads/t/problems.t	2011-01-07 13:23:20.843523692 +0100
@@ -2,10 +2,6 @@ use strict;
 use warnings;
 
 BEGIN {
-    if ($ENV{'PERL_CORE'}){
-        chdir 't';
-        unshift @INC, '../lib';
-    }
     use Config;
     if (! $Config{'useithreads'}) {
         print("1..0 # SKIP Perl not compiled with 'useithreads'\n");
diff -up perl-5.10.1/ext/threads/t/stack_env.t.oldthread perl-5.10.1/ext/threads/t/stack_env.t
--- perl-5.10.1/ext/threads/t/stack_env.t.oldthread	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/ext/threads/t/stack_env.t	2011-01-07 13:23:20.843523692 +0100
@@ -2,10 +2,6 @@ use strict;
 use warnings;
 
 BEGIN {
-    if ($ENV{'PERL_CORE'}){
-        chdir 't';
-        unshift @INC, '../lib';
-    }
     use Config;
     if (! $Config{'useithreads'}) {
         print("1..0 # SKIP Perl not compiled with 'useithreads'\n");
diff -up perl-5.10.1/ext/threads/t/stack.t.oldthread perl-5.10.1/ext/threads/t/stack.t
--- perl-5.10.1/ext/threads/t/stack.t.oldthread	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/ext/threads/t/stack.t	2011-01-07 13:23:20.844523681 +0100
@@ -2,10 +2,6 @@ use strict;
 use warnings;
 
 BEGIN {
-    if ($ENV{'PERL_CORE'}){
-        chdir 't';
-        unshift @INC, '../lib';
-    }
     use Config;
     if (! $Config{'useithreads'}) {
         print("1..0 # SKIP Perl not compiled with 'useithreads'\n");
diff -up perl-5.10.1/ext/threads/t/state.t.oldthread perl-5.10.1/ext/threads/t/state.t
--- perl-5.10.1/ext/threads/t/state.t.oldthread	2009-04-15 14:25:00.000000000 +0200
+++ perl-5.10.1/ext/threads/t/state.t	2011-01-07 13:23:20.844523681 +0100
@@ -2,10 +2,6 @@ use strict;
 use warnings;
 
 BEGIN {
-    if ($ENV{'PERL_CORE'}){
-        chdir 't';
-        unshift @INC, '../lib';
-    }
     use Config;
     if (! $Config{'useithreads'}) {
         print("1..0 # SKIP Perl not compiled with 'useithreads'\n");
diff -up perl-5.10.1/ext/threads/t/stress_cv.t.oldthread perl-5.10.1/ext/threads/t/stress_cv.t
--- perl-5.10.1/ext/threads/t/stress_cv.t.oldthread	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/ext/threads/t/stress_cv.t	2011-01-07 13:23:20.844523681 +0100
@@ -2,10 +2,6 @@ use strict;
 use warnings;
 
 BEGIN {
-    if ($ENV{'PERL_CORE'}){
-        chdir 't';
-        unshift @INC, '../lib';
-    }
     use Config;
     if (! $Config{'useithreads'}) {
         print("1..0 # SKIP Perl not compiled with 'useithreads'\n");
diff -up perl-5.10.1/ext/threads/t/stress_re.t.oldthread perl-5.10.1/ext/threads/t/stress_re.t
--- perl-5.10.1/ext/threads/t/stress_re.t.oldthread	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/ext/threads/t/stress_re.t	2011-01-07 13:23:20.844523681 +0100
@@ -2,10 +2,6 @@ use strict;
 use warnings;
 
 BEGIN {
-    if ($ENV{'PERL_CORE'}){
-        chdir 't';
-        unshift @INC, '../lib';
-    }
     use Config;
     if (! $Config{'useithreads'}) {
         print("1..0 # SKIP Perl not compiled with 'useithreads'\n");
diff -up perl-5.10.1/ext/threads/t/stress_string.t.oldthread perl-5.10.1/ext/threads/t/stress_string.t
--- perl-5.10.1/ext/threads/t/stress_string.t.oldthread	2009-02-12 23:58:12.000000000 +0100
+++ perl-5.10.1/ext/threads/t/stress_string.t	2011-01-07 13:23:20.844523681 +0100
@@ -2,10 +2,6 @@ use strict;
 use warnings;
 
 BEGIN {
-    if ($ENV{'PERL_CORE'}){
-        chdir 't';
-        unshift @INC, '../lib';
-    }
     use Config;
     if (! $Config{'useithreads'}) {
         print("1..0 # SKIP Perl not compiled with 'useithreads'\n");
diff -up perl-5.10.1/ext/threads/t/test.pl.oldthread perl-5.10.1/ext/threads/t/test.pl
--- perl-5.10.1/ext/threads/t/test.pl.oldthread	2011-01-07 13:23:20.845523756 +0100
+++ perl-5.10.1/ext/threads/t/test.pl	2011-01-07 13:23:20.845523756 +0100
@@ -0,0 +1,1162 @@
+#
+# t/test.pl - most of Test::More functionality without the fuss, plus
+# has mappings native_to_latin1 and latin1_to_native so that fewer tests
+# on non ASCII-ish platforms need to be skipped
+
+
+# NOTE:
+#
+# Increment ($x++) has a certain amount of cleverness for things like
+#
+#   $x = 'zz';
+#   $x++; # $x eq 'aaa';
+#
+# stands more chance of breaking than just a simple
+#
+#   $x = $x + 1
+#
+# In this file, we use the latter "Baby Perl" approach, and increment
+# will be worked over by t/op/inc.t
+
+$Level = 1;
+my $test = 1;
+my $planned;
+my $noplan;
+my $Perl;       # Safer version of $^X set by which_perl()
+
+$TODO = 0;
+$NO_ENDING = 0;
+$Tests_Are_Passing = 1;
+
+# Use this instead of print to avoid interference while testing globals.
+sub _print {
+    local($\, $", $,) = (undef, ' ', '');
+    print STDOUT @_;
+}
+
+sub _print_stderr {
+    local($\, $", $,) = (undef, ' ', '');
+    print STDERR @_;
+}
+
+sub plan {
+    my $n;
+    if (@_ == 1) {
+	$n = shift;
+	if ($n eq 'no_plan') {
+	  undef $n;
+	  $noplan = 1;
+	}
+    } else {
+	my %plan = @_;
+	$n = $plan{tests};
+    }
+    _print "1..$n\n" unless $noplan;
+    $planned = $n;
+}
+
+
+# Set the plan at the end.  See Test::More::done_testing.
+sub done_testing {
+    my $n = $test - 1;
+    $n = shift if @_;
+
+    _print "1..$n\n";
+    $planned = $n;
+}
+
+
+END {
+    my $ran = $test - 1;
+    if (!$NO_ENDING) {
+	if (defined $planned && $planned != $ran) {
+	    _print_stderr
+		"# Looks like you planned $planned tests but ran $ran.\n";
+	} elsif ($noplan) {
+	    _print "1..$ran\n";
+	}
+    }
+}
+
+sub _diag {
+    return unless @_;
+    my @mess = _comment(@_);
+    $TODO ? _print(@mess) : _print_stderr(@mess);
+}
+
+# Use this instead of "print STDERR" when outputing failure diagnostic
+# messages
+sub diag {
+    _diag(@_);
+}
+
+# Use this instead of "print" when outputing informational messages
+sub note {
+    return unless @_;
+    _print( _comment(@_) );
+}
+
+sub _comment {
+    return map { /^#/ ? "$_\n" : "# $_\n" }
+           map { split /\n/ } @_;
+}
+
+sub skip_all {
+    if (@_) {
+        _print "1..0 # Skip @_\n";
+    } else {
+	_print "1..0\n";
+    }
+    exit(0);
+}
+
+sub _ok {
+    my ($pass, $where, $name, @mess) = @_;
+    # Do not try to microoptimize by factoring out the "not ".
+    # VMS will avenge.
+    my $out;
+    if ($name) {
+        # escape out '#' or it will interfere with '# skip' and such
+        $name =~ s/#/\\#/g;
+	$out = $pass ? "ok $test - $name" : "not ok $test - $name";
+    } else {
+	$out = $pass ? "ok $test" : "not ok $test";
+    }
+
+    if ($TODO) {
+	$out = $out . " # TODO $TODO";
+    } else {
+	$Tests_Are_Passing = 0 unless $pass;
+    }
+
+    _print "$out\n";
+
+    unless ($pass) {
+	_diag "# Failed $where\n";
+    }
+
+    # Ensure that the message is properly escaped.
+    _diag @mess;
+
+    $test = $test + 1; # don't use ++
+
+    return $pass;
+}
+
+sub _where {
+    my @caller = caller($Level);
+    return "at $caller[1] line $caller[2]";
+}
+
+# DON'T use this for matches. Use like() instead.
+sub ok ($@) {
+    my ($pass, $name, @mess) = @_;
+    _ok($pass, _where(), $name, @mess);
+}
+
+sub _q {
+    my $x = shift;
+    return 'undef' unless defined $x;
+    my $q = $x;
+    $q =~ s/\\/\\\\/g;
+    $q =~ s/'/\\'/g;
+    return "'$q'";
+}
+
+sub _qq {
+    my $x = shift;
+    return defined $x ? '"' . display ($x) . '"' : 'undef';
+};
+
+# keys are the codes \n etc map to, values are 2 char strings such as \n
+my %backslash_escape;
+foreach my $x (split //, 'nrtfa\\\'"') {
+    $backslash_escape{ord eval "\"\\$x\""} = "\\$x";
+}
+# A way to display scalars containing control characters and Unicode.
+# Trying to avoid setting $_, or relying on local $_ to work.
+sub display {
+    my @result;
+    foreach my $x (@_) {
+        if (defined $x and not ref $x) {
+            my $y = '';
+            foreach my $c (unpack("U*", $x)) {
+                if ($c > 255) {
+                    $y = $y . sprintf "\\x{%x}", $c;
+                } elsif ($backslash_escape{$c}) {
+                    $y = $y . $backslash_escape{$c};
+                } else {
+                    my $z = chr $c; # Maybe we can get away with a literal...
+                    if ($z =~ /[[:^print:]]/) {
+
+                        # Use octal for characters traditionally expressed as
+                        # such: the low controls
+                        if ($c <= 037) {
+                            $z = sprintf "\\%03o", $c;
+                        } else {
+                            $z = sprintf "\\x{%x}", $c;
+                        }
+                    }
+                    $y = $y . $z;
+                }
+            }
+            $x = $y;
+        }
+        return $x unless wantarray;
+        push @result, $x;
+    }
+    return @result;
+}
+
+sub is ($$@) {
+    my ($got, $expected, $name, @mess) = @_;
+
+    my $pass;
+    if( !defined $got || !defined $expected ) {
+        # undef only matches undef
+        $pass = !defined $got && !defined $expected;
+    }
+    else {
+        $pass = $got eq $expected;
+    }
+
+    unless ($pass) {
+	unshift(@mess, "#      got "._qq($got)."\n",
+		       "# expected "._qq($expected)."\n");
+    }
+    _ok($pass, _where(), $name, @mess);
+}
+
+sub isnt ($$@) {
+    my ($got, $isnt, $name, @mess) = @_;
+
+    my $pass;
+    if( !defined $got || !defined $isnt ) {
+        # undef only matches undef
+        $pass = defined $got || defined $isnt;
+    }
+    else {
+        $pass = $got ne $isnt;
+    }
+
+    unless( $pass ) {
+        unshift(@mess, "# it should not be "._qq($got)."\n",
+                       "# but it is.\n");
+    }
+    _ok($pass, _where(), $name, @mess);
+}
+
+sub cmp_ok ($$$@) {
+    my($got, $type, $expected, $name, @mess) = @_;
+
+    my $pass;
+    {
+        local $^W = 0;
+        local($@,$!);   # don't interfere with $@
+                        # eval() sometimes resets $!
+        $pass = eval "\$got $type \$expected";
+    }
+    unless ($pass) {
+        # It seems Irix long doubles can have 2147483648 and 2147483648
+        # that stringify to the same thing but are acutally numerically
+        # different. Display the numbers if $type isn't a string operator,
+        # and the numbers are stringwise the same.
+        # (all string operators have alphabetic names, so tr/a-z// is true)
+        # This will also show numbers for some uneeded cases, but will
+        # definately be helpful for things such as == and <= that fail
+        if ($got eq $expected and $type !~ tr/a-z//) {
+            unshift @mess, "# $got - $expected = " . ($got - $expected) . "\n";
+        }
+        unshift(@mess, "#      got "._qq($got)."\n",
+                       "# expected $type "._qq($expected)."\n");
+    }
+    _ok($pass, _where(), $name, @mess);
+}
+
+# Check that $got is within $range of $expected
+# if $range is 0, then check it's exact
+# else if $expected is 0, then $range is an absolute value
+# otherwise $range is a fractional error.
+# Here $range must be numeric, >= 0
+# Non numeric ranges might be a useful future extension. (eg %)
+sub within ($$$@) {
+    my ($got, $expected, $range, $name, @mess) = @_;
+    my $pass;
+    if (!defined $got or !defined $expected or !defined $range) {
+        # This is a fail, but doesn't need extra diagnostics
+    } elsif ($got !~ tr/0-9// or $expected !~ tr/0-9// or $range !~ tr/0-9//) {
+        # This is a fail
+        unshift @mess, "# got, expected and range must be numeric\n";
+    } elsif ($range < 0) {
+        # This is also a fail
+        unshift @mess, "# range must not be negative\n";
+    } elsif ($range == 0) {
+        # Within 0 is ==
+        $pass = $got == $expected;
+    } elsif ($expected == 0) {
+        # If expected is 0, treat range as absolute
+        $pass = ($got <= $range) && ($got >= - $range);
+    } else {
+        my $diff = $got - $expected;
+        $pass = abs ($diff / $expected) < $range;
+    }
+    unless ($pass) {
+        if ($got eq $expected) {
+            unshift @mess, "# $got - $expected = " . ($got - $expected) . "\n";
+        }
+	unshift@mess, "#      got "._qq($got)."\n",
+		      "# expected "._qq($expected)." (within "._qq($range).")\n";
+    }
+    _ok($pass, _where(), $name, @mess);
+}
+
+# Note: this isn't quite as fancy as Test::More::like().
+
+sub like   ($$@) { like_yn (0,@_) }; # 0 for -
+sub unlike ($$@) { like_yn (1,@_) }; # 1 for un-
+
+sub like_yn ($$$@) {
+    my ($flip, $got, $expected, $name, @mess) = @_;
+    my $pass;
+    $pass = $got =~ /$expected/ if !$flip;
+    $pass = $got !~ /$expected/ if $flip;
+    unless ($pass) {
+	unshift(@mess, "#      got '$got'\n",
+		$flip
+		? "# expected !~ /$expected/\n" : "# expected /$expected/\n");
+    }
+    local $Level = $Level + 1;
+    _ok($pass, _where(), $name, @mess);
+}
+
+sub pass {
+    _ok(1, '', @_);
+}
+
+sub fail {
+    _ok(0, _where(), @_);
+}
+
+sub curr_test {
+    $test = shift if @_;
+    return $test;
+}
+
+sub next_test {
+  my $retval = $test;
+  $test = $test + 1; # don't use ++
+  $retval;
+}
+
+# Note: can't pass multipart messages since we try to
+# be compatible with Test::More::skip().
+sub skip {
+    my $why = shift;
+    my $n    = @_ ? shift : 1;
+    for (1..$n) {
+        _print "ok $test # skip $why\n";
+        $test = $test + 1;
+    }
+    local $^W = 0;
+    last SKIP;
+}
+
+sub todo_skip {
+    my $why = shift;
+    my $n   = @_ ? shift : 1;
+
+    for (1..$n) {
+        _print "not ok $test # TODO & SKIP $why\n";
+        $test = $test + 1;
+    }
+    local $^W = 0;
+    last TODO;
+}
+
+sub eq_array {
+    my ($ra, $rb) = @_;
+    return 0 unless $#$ra == $#$rb;
+    for my $i (0..$#$ra) {
+	next     if !defined $ra->[$i] && !defined $rb->[$i];
+	return 0 if !defined $ra->[$i];
+	return 0 if !defined $rb->[$i];
+	return 0 unless $ra->[$i] eq $rb->[$i];
+    }
+    return 1;
+}
+
+sub eq_hash {
+  my ($orig, $suspect) = @_;
+  my $fail;
+  while (my ($key, $value) = each %$suspect) {
+    # Force a hash recompute if this perl's internals can cache the hash key.
+    $key = "" . $key;
+    if (exists $orig->{$key}) {
+      if ($orig->{$key} ne $value) {
+        _print "# key ", _qq($key), " was ", _qq($orig->{$key}),
+                     " now ", _qq($value), "\n";
+        $fail = 1;
+      }
+    } else {
+      _print "# key ", _qq($key), " is ", _qq($value),
+                   ", not in original.\n";
+      $fail = 1;
+    }
+  }
+  foreach (keys %$orig) {
+    # Force a hash recompute if this perl's internals can cache the hash key.
+    $_ = "" . $_;
+    next if (exists $suspect->{$_});
+    _print "# key ", _qq($_), " was ", _qq($orig->{$_}), " now missing.\n";
+    $fail = 1;
+  }
+  !$fail;
+}
+
+sub require_ok ($) {
+    my ($require) = @_;
+    eval <<REQUIRE_OK;
+require $require;
+REQUIRE_OK
+    _ok(!$@, _where(), "require $require");
+}
+
+sub use_ok ($) {
+    my ($use) = @_;
+    eval <<USE_OK;
+use $use;
+USE_OK
+    _ok(!$@, _where(), "use $use");
+}
+
+# runperl - Runs a separate perl interpreter.
+# Arguments :
+#   switches => [ command-line switches ]
+#   nolib    => 1 # don't use -I../lib (included by default)
+#   non_portable => Don't warn if a one liner contains quotes
+#   prog     => one-liner (avoid quotes)
+#   progs    => [ multi-liner (avoid quotes) ]
+#   progfile => perl script
+#   stdin    => string to feed the stdin
+#   stderr   => redirect stderr to stdout
+#   args     => [ command-line arguments to the perl program ]
+#   verbose  => print the command line
+
+my $is_mswin    = $^O eq 'MSWin32';
+my $is_netware  = $^O eq 'NetWare';
+my $is_vms      = $^O eq 'VMS';
+my $is_cygwin   = $^O eq 'cygwin';
+
+sub _quote_args {
+    my ($runperl, $args) = @_;
+
+    foreach (@$args) {
+	# In VMS protect with doublequotes because otherwise
+	# DCL will lowercase -- unless already doublequoted.
+       $_ = q(").$_.q(") if $is_vms && !/^\"/ && length($_) > 0;
+       $runperl = $runperl . ' ' . $_;
+    }
+    return $runperl;
+}
+
+sub _create_runperl { # Create the string to qx in runperl().
+    my %args = @_;
+    my $runperl = which_perl();
+    if ($runperl =~ m/\s/) {
+        $runperl = qq{"$runperl"};
+    }
+    #- this allows, for example, to set PERL_RUNPERL_DEBUG=/usr/bin/valgrind
+    if ($ENV{PERL_RUNPERL_DEBUG}) {
+	$runperl = "$ENV{PERL_RUNPERL_DEBUG} $runperl";
+    }
+    unless ($args{nolib}) {
+	$runperl = $runperl . ' "-I../lib"'; # doublequotes because of VMS
+    }
+    if ($args{switches}) {
+	local $Level = 2;
+	die "test.pl:runperl(): 'switches' must be an ARRAYREF " . _where()
+	    unless ref $args{switches} eq "ARRAY";
+	$runperl = _quote_args($runperl, $args{switches});
+    }
+    if (defined $args{prog}) {
+	die "test.pl:runperl(): both 'prog' and 'progs' cannot be used " . _where()
+	    if defined $args{progs};
+        $args{progs} = [$args{prog}]
+    }
+    if (defined $args{progs}) {
+	die "test.pl:runperl(): 'progs' must be an ARRAYREF " . _where()
+	    unless ref $args{progs} eq "ARRAY";
+        foreach my $prog (@{$args{progs}}) {
+	    if ($prog =~ tr/'"// && !$args{non_portable}) {
+		warn "quotes in prog >>$prog<< are not portable";
+	    }
+            if ($is_mswin || $is_netware || $is_vms) {
+                $runperl = $runperl . qq ( -e "$prog" );
+            }
+            else {
+                $runperl = $runperl . qq ( -e '$prog' );
+            }
+        }
+    } elsif (defined $args{progfile}) {
+	$runperl = $runperl . qq( "$args{progfile}");
+    } else {
+	# You probaby didn't want to be sucking in from the upstream stdin
+	die "test.pl:runperl(): none of prog, progs, progfile, args, "
+	    . " switches or stdin specified"
+	    unless defined $args{args} or defined $args{switches}
+		or defined $args{stdin};
+    }
+    if (defined $args{stdin}) {
+	# so we don't try to put literal newlines and crs onto the
+	# command line.
+	$args{stdin} =~ s/\n/\\n/g;
+	$args{stdin} =~ s/\r/\\r/g;
+
+	if ($is_mswin || $is_netware || $is_vms) {
+	    $runperl = qq{$Perl -e "print qq(} .
+		$args{stdin} . q{)" | } . $runperl;
+	}
+	else {
+	    $runperl = qq{$Perl -e 'print qq(} .
+		$args{stdin} . q{)' | } . $runperl;
+	}
+    }
+    if (defined $args{args}) {
+	$runperl = _quote_args($runperl, $args{args});
+    }
+    $runperl = $runperl . ' 2>&1' if $args{stderr};
+    if ($args{verbose}) {
+	my $runperldisplay = $runperl;
+	$runperldisplay =~ s/\n/\n\#/g;
+	_print_stderr "# $runperldisplay\n";
+    }
+    return $runperl;
+}
+
+sub runperl {
+    die "test.pl:runperl() does not take a hashref"
+	if ref $_[0] and ref $_[0] eq 'HASH';
+    my $runperl = &_create_runperl;
+    my $result;
+
+    my $tainted = ${^TAINT};
+    my %args = @_;
+    exists $args{switches} && grep m/^-T$/, @{$args{switches}} and $tainted = $tainted + 1;
+
+    if ($tainted) {
+	# We will assume that if you're running under -T, you really mean to
+	# run a fresh perl, so we'll brute force launder everything for you
+	my $sep;
+
+	if (! eval 'require Config; 1') {
+	    warn "test.pl had problems loading Config: $@";
+	    $sep = ':';
+	} else {
+	    $sep = $Config::Config{path_sep};
+	}
+
+	my @keys = grep {exists $ENV{$_}} qw(CDPATH IFS ENV BASH_ENV);
+	local @ENV{@keys} = ();
+	# Untaint, plus take out . and empty string:
+	local $ENV{'DCL$PATH'} = $1 if $is_vms && exists($ENV{'DCL$PATH'}) && ($ENV{'DCL$PATH'} =~ /(.*)/s);
+	$ENV{PATH} =~ /(.*)/s;
+	local $ENV{PATH} =
+	    join $sep, grep { $_ ne "" and $_ ne "." and -d $_ and
+		($is_mswin or $is_vms or !(stat && (stat _)[2]&0022)) }
+		    split quotemeta ($sep), $1;
+	if ($is_cygwin) {   # Must have /bin under Cygwin
+	    if (length $ENV{PATH}) {
+		$ENV{PATH} = $ENV{PATH} . $sep;
+	    }
+	    $ENV{PATH} = $ENV{PATH} . '/bin';
+	}
+	$runperl =~ /(.*)/s;
+	$runperl = $1;
+
+	$result = `$runperl`;
+    } else {
+	$result = `$runperl`;
+    }
+    $result =~ s/\n\n/\n/ if $is_vms; # XXX pipes sometimes double these
+    return $result;
+}
+
+# Nice alias
+*run_perl = *run_perl = \&runperl; # shut up "used only once" warning
+
+sub DIE {
+    _print_stderr "# @_\n";
+    exit 1;
+}
+
+# A somewhat safer version of the sometimes wrong $^X.
+sub which_perl {
+    unless (defined $Perl) {
+	$Perl = $^X;
+
+	# VMS should have 'perl' aliased properly
+	return $Perl if $^O eq 'VMS';
+
+	my $exe;
+	if (! eval 'require Config; 1') {
+	    warn "test.pl had problems loading Config: $@";
+	    $exe = '';
+	} else {
+	    $exe = $Config::Config{_exe};
+	}
+       $exe = '' unless defined $exe;
+
+	# This doesn't absolutize the path: beware of future chdirs().
+	# We could do File::Spec->abs2rel() but that does getcwd()s,
+	# which is a bit heavyweight to do here.
+
+	if ($Perl =~ /^perl\Q$exe\E$/i) {
+	    my $perl = "perl$exe";
+	    if (! eval 'require File::Spec; 1') {
+		warn "test.pl had problems loading File::Spec: $@";
+		$Perl = "./$perl";
+	    } else {
+		$Perl = File::Spec->catfile(File::Spec->curdir(), $perl);
+	    }
+	}
+
+	# Build up the name of the executable file from the name of
+	# the command.
+
+	if ($Perl !~ /\Q$exe\E$/i) {
+	    $Perl = $Perl . $exe;
+	}
+
+	warn "which_perl: cannot find $Perl from $^X" unless -f $Perl;
+
+	# For subcommands to use.
+	$ENV{PERLEXE} = $Perl;
+    }
+    return $Perl;
+}
+
+sub unlink_all {
+    my $count = 0;
+    foreach my $file (@_) {
+        1 while unlink $file;
+	if( -f $file ){
+	    _print_stderr "# Couldn't unlink '$file': $!\n";
+	}else{
+	    ++$count;
+	}
+    }
+    $count;
+}
+
+my %tmpfiles;
+END { unlink_all keys %tmpfiles }
+
+# A regexp that matches the tempfile names
+$::tempfile_regexp = 'tmp\d+[A-Z][A-Z]?';
+
+# Avoid ++, avoid ranges, avoid split //
+my @letters = qw(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z);
+sub tempfile {
+    my $count = 0;
+    do {
+	my $temp = $count;
+	my $try = "tmp$$";
+	do {
+	    $try = $try . $letters[$temp % 26];
+	    $temp = int ($temp / 26);
+	} while $temp;
+	# Need to note all the file names we allocated, as a second request may
+	# come before the first is created.
+	if (!-e $try && !$tmpfiles{$try}) {
+	    # We have a winner
+	    $tmpfiles{$try} = 1;
+	    return $try;
+	}
+	$count = $count + 1;
+    } while $count < 26 * 26;
+    die "Can't find temporary file name starting 'tmp$$'";
+}
+
+# This is the temporary file for _fresh_perl
+my $tmpfile = tempfile();
+
+#
+# _fresh_perl
+#
+# The $resolve must be a subref that tests the first argument
+# for success, or returns the definition of success (e.g. the
+# expected scalar) if given no arguments.
+#
+
+sub _fresh_perl {
+    my($prog, $resolve, $runperl_args, $name) = @_;
+
+    # Given the choice of the mis-parsable {}
+    # (we want an anon hash, but a borked lexer might think that it's a block)
+    # or relying on taking a reference to a lexical
+    # (\ might be mis-parsed, and the reference counting on the pad may go
+    #  awry)
+    # it feels like the least-worse thing is to assume that auto-vivification
+    # works. At least, this is only going to be a run-time failure, so won't
+    # affect tests using this file but not this function.
+    $runperl_args->{progfile} = $tmpfile;
+    $runperl_args->{stderr} = 1;
+
+    open TEST, ">$tmpfile" or die "Cannot open $tmpfile: $!";
+
+    # VMS adjustments
+    if( $^O eq 'VMS' ) {
+        $prog =~ s#/dev/null#NL:#;
+
+        # VMS file locking
+        $prog =~ s{if \(-e _ and -f _ and -r _\)}
+                  {if (-e _ and -f _)}
+    }
+
+    print TEST $prog;
+    close TEST or die "Cannot close $tmpfile: $!";
+
+    my $results = runperl(%$runperl_args);
+    my $status = $?;
+
+    # Clean up the results into something a bit more predictable.
+    $results  =~ s/\n+$//;
+    $results =~ s/at\s+$::tempfile_regexp\s+line/at - line/g;
+    $results =~ s/of\s+$::tempfile_regexp\s+aborted/of - aborted/g;
+
+    # bison says 'parse error' instead of 'syntax error',
+    # various yaccs may or may not capitalize 'syntax'.
+    $results =~ s/^(syntax|parse) error/syntax error/mig;
+
+    if ($^O eq 'VMS') {
+        # some tests will trigger VMS messages that won't be expected
+        $results =~ s/\n?%[A-Z]+-[SIWEF]-[A-Z]+,.*//;
+
+        # pipes double these sometimes
+        $results =~ s/\n\n/\n/g;
+    }
+
+    my $pass = $resolve->($results);
+    unless ($pass) {
+        _diag "# PROG: \n$prog\n";
+        _diag "# EXPECTED:\n", $resolve->(), "\n";
+        _diag "# GOT:\n$results\n";
+        _diag "# STATUS: $status\n";
+    }
+
+    # Use the first line of the program as a name if none was given
+    unless( $name ) {
+        ($first_line, $name) = $prog =~ /^((.{1,50}).*)/;
+        $name = $name . '...' if length $first_line > length $name;
+    }
+
+    _ok($pass, _where(), "fresh_perl - $name");
+}
+
+#
+# fresh_perl_is
+#
+# Combination of run_perl() and is().
+#
+
+sub fresh_perl_is {
+    my($prog, $expected, $runperl_args, $name) = @_;
+
+    # _fresh_perl() is going to clip the trailing newlines off the result.
+    # This will make it so the test author doesn't have to know that.
+    $expected =~ s/\n+$//;
+
+    local $Level = 2;
+    _fresh_perl($prog,
+		sub { @_ ? $_[0] eq $expected : $expected },
+		$runperl_args, $name);
+}
+
+#
+# fresh_perl_like
+#
+# Combination of run_perl() and like().
+#
+
+sub fresh_perl_like {
+    my($prog, $expected, $runperl_args, $name) = @_;
+    local $Level = 2;
+    _fresh_perl($prog,
+		sub { @_ ? $_[0] =~ $expected : $expected },
+		$runperl_args, $name);
+}
+
+sub can_ok ($@) {
+    my($proto, @methods) = @_;
+    my $class = ref $proto || $proto;
+
+    unless( @methods ) {
+        return _ok( 0, _where(), "$class->can(...)" );
+    }
+
+    my @nok = ();
+    foreach my $method (@methods) {
+        local($!, $@);  # don't interfere with caller's $@
+                        # eval sometimes resets $!
+        eval { $proto->can($method) } || push @nok, $method;
+    }
+
+    my $name;
+    $name = @methods == 1 ? "$class->can('$methods[0]')"
+                          : "$class->can(...)";
+
+    _ok( !@nok, _where(), $name );
+}
+
+
+# Call $class->new( @$args ); and run the result through isa_ok.
+# See Test::More::new_ok
+sub new_ok {
+    my($class, $args, $obj_name) = @_;
+    $args ||= [];
+    $object_name = "The object" unless defined $obj_name;
+
+    local $Level = $Level + 1;
+
+    my $obj;
+    my $ok = eval { $obj = $class->new(@$args); 1 };
+    my $error = $@;
+
+    if($ok) {
+        isa_ok($obj, $class, $object_name);
+    }
+    else {
+        ok( 0, "new() died" );
+        diag("Error was:  $@");
+    }
+
+    return $obj;
+
+}
+
+
+sub isa_ok ($$;$) {
+    my($object, $class, $obj_name) = @_;
+
+    my $diag;
+    $obj_name = 'The object' unless defined $obj_name;
+    my $name = "$obj_name isa $class";
+    if( !defined $object ) {
+        $diag = "$obj_name isn't defined";
+    }
+    elsif( !ref $object ) {
+        $diag = "$obj_name isn't a reference";
+    }
+    else {
+        # We can't use UNIVERSAL::isa because we want to honor isa() overrides
+        local($@, $!);  # eval sometimes resets $!
+        my $rslt = eval { $object->isa($class) };
+        if( $@ ) {
+            if( $@ =~ /^Can't call method "isa" on unblessed reference/ ) {
+                if( !UNIVERSAL::isa($object, $class) ) {
+                    my $ref = ref $object;
+                    $diag = "$obj_name isn't a '$class' it's a '$ref'";
+                }
+            } else {
+                die <<WHOA;
+WHOA! I tried to call ->isa on your object and got some weird error.
+This should never happen.  Please contact the author immediately.
+Here's the error.
+$@
+WHOA
+            }
+        }
+        elsif( !$rslt ) {
+            my $ref = ref $object;
+            $diag = "$obj_name isn't a '$class' it's a '$ref'";
+        }
+    }
+
+    _ok( !$diag, _where(), $name );
+}
+
+# Set a watchdog to timeout the entire test file
+# NOTE:  If the test file uses 'threads', then call the watchdog() function
+#        _AFTER_ the 'threads' module is loaded.
+sub watchdog ($;$)
+{
+    my $timeout = shift;
+    my $method  = shift || "";
+    my $timeout_msg = 'Test process timed out - terminating';
+
+    # Valgrind slows perl way down so give it more time before dying.
+    $timeout *= 10 if $ENV{PERL_VALGRIND};
+
+    my $pid_to_kill = $$;   # PID for this process
+
+    if ($method eq "alarm") {
+        goto WATCHDOG_VIA_ALARM;
+    }
+
+    # shut up use only once warning
+    my $threads_on = $threads::threads && $threads::threads;
+
+    # Don't use a watchdog process if 'threads' is loaded -
+    #   use a watchdog thread instead
+    if (!$threads_on) {
+
+        # On Windows and VMS, try launching a watchdog process
+        #   using system(1, ...) (see perlport.pod)
+        if (($^O eq 'MSWin32') || ($^O eq 'VMS')) {
+            # On Windows, try to get the 'real' PID
+            if ($^O eq 'MSWin32') {
+                eval { require Win32; };
+                if (defined(&Win32::GetCurrentProcessId)) {
+                    $pid_to_kill = Win32::GetCurrentProcessId();
+                }
+            }
+
+            # If we still have a fake PID, we can't use this method at all
+            return if ($pid_to_kill <= 0);
+
+            # Launch watchdog process
+            my $watchdog;
+            eval {
+                local $SIG{'__WARN__'} = sub {
+                    _diag("Watchdog warning: $_[0]");
+                };
+                my $sig = $^O eq 'VMS' ? 'TERM' : 'KILL';
+                my $cmd = _create_runperl( prog =>  "sleep($timeout);" .
+                                                    "warn qq/# $timeout_msg" . '\n/;' .
+                                                    "kill($sig, $pid_to_kill);");
+                $watchdog = system(1, $cmd);
+            };
+            if ($@ || ($watchdog <= 0)) {
+                _diag('Failed to start watchdog');
+                _diag($@) if $@;
+                undef($watchdog);
+                return;
+            }
+
+            # Add END block to parent to terminate and
+            #   clean up watchdog process
+            eval "END { local \$! = 0; local \$? = 0;
+                        wait() if kill('KILL', $watchdog); };";
+            return;
+        }
+
+        # Try using fork() to generate a watchdog process
+        my $watchdog;
+        eval { $watchdog = fork() };
+        if (defined($watchdog)) {
+            if ($watchdog) {   # Parent process
+                # Add END block to parent to terminate and
+                #   clean up watchdog process
+                eval "END { local \$! = 0; local \$? = 0;
+                            wait() if kill('KILL', $watchdog); };";
+                return;
+            }
+
+            ### Watchdog process code
+
+            # Load POSIX if available
+            eval { require POSIX; };
+
+            # Execute the timeout
+            sleep($timeout - 2) if ($timeout > 2);   # Workaround for perlbug #49073
+            sleep(2);
+
+            # Kill test process if still running
+            if (kill(0, $pid_to_kill)) {
+                _diag($timeout_msg);
+                kill('KILL', $pid_to_kill);
+            }
+
+            # Don't execute END block (added at beginning of this file)
+            $NO_ENDING = 1;
+
+            # Terminate ourself (i.e., the watchdog)
+            POSIX::_exit(1) if (defined(&POSIX::_exit));
+            exit(1);
+        }
+
+        # fork() failed - fall through and try using a thread
+    }
+
+    # Use a watchdog thread because either 'threads' is loaded,
+    #   or fork() failed
+    if (eval 'require threads; 1') {
+        'threads'->create(sub {
+                # Load POSIX if available
+                eval { require POSIX; };
+
+                # Execute the timeout
+                my $time_left = $timeout;
+                do {
+                    $time_left = $time_left - sleep($time_left);
+                } while ($time_left > 0);
+
+                # Kill the parent (and ourself)
+                select(STDERR); $| = 1;
+                _diag($timeout_msg);
+                POSIX::_exit(1) if (defined(&POSIX::_exit));
+                my $sig = $^O eq 'VMS' ? 'TERM' : 'KILL';
+                kill($sig, $pid_to_kill);
+            })->detach();
+        return;
+    }
+
+    # If everything above fails, then just use an alarm timeout
+WATCHDOG_VIA_ALARM:
+    if (eval { alarm($timeout); 1; }) {
+        # Load POSIX if available
+        eval { require POSIX; };
+
+        # Alarm handler will do the actual 'killing'
+        $SIG{'ALRM'} = sub {
+            select(STDERR); $| = 1;
+            _diag($timeout_msg);
+            POSIX::_exit(1) if (defined(&POSIX::_exit));
+            my $sig = $^O eq 'VMS' ? 'TERM' : 'KILL';
+            kill($sig, $pid_to_kill);
+        };
+    }
+}
+
+my $cp_0037 =   # EBCDIC code page 0037
+    '\x00\x01\x02\x03\x37\x2D\x2E\x2F\x16\x05\x25\x0B\x0C\x0D\x0E\x0F' .
+    '\x10\x11\x12\x13\x3C\x3D\x32\x26\x18\x19\x3F\x27\x1C\x1D\x1E\x1F' .
+    '\x40\x5A\x7F\x7B\x5B\x6C\x50\x7D\x4D\x5D\x5C\x4E\x6B\x60\x4B\x61' .
+    '\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\x7A\x5E\x4C\x7E\x6E\x6F' .
+    '\x7C\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xD1\xD2\xD3\xD4\xD5\xD6' .
+    '\xD7\xD8\xD9\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xBA\xE0\xBB\xB0\x6D' .
+    '\x79\x81\x82\x83\x84\x85\x86\x87\x88\x89\x91\x92\x93\x94\x95\x96' .
+    '\x97\x98\x99\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xC0\x4F\xD0\xA1\x07' .
+    '\x20\x21\x22\x23\x24\x15\x06\x17\x28\x29\x2A\x2B\x2C\x09\x0A\x1B' .
+    '\x30\x31\x1A\x33\x34\x35\x36\x08\x38\x39\x3A\x3B\x04\x14\x3E\xFF' .
+    '\x41\xAA\x4A\xB1\x9F\xB2\x6A\xB5\xBD\xB4\x9A\x8A\x5F\xCA\xAF\xBC' .
+    '\x90\x8F\xEA\xFA\xBE\xA0\xB6\xB3\x9D\xDA\x9B\x8B\xB7\xB8\xB9\xAB' .
+    '\x64\x65\x62\x66\x63\x67\x9E\x68\x74\x71\x72\x73\x78\x75\x76\x77' .
+    '\xAC\x69\xED\xEE\xEB\xEF\xEC\xBF\x80\xFD\xFE\xFB\xFC\xAD\xAE\x59' .
+    '\x44\x45\x42\x46\x43\x47\x9C\x48\x54\x51\x52\x53\x58\x55\x56\x57' .
+    '\x8C\x49\xCD\xCE\xCB\xCF\xCC\xE1\x70\xDD\xDE\xDB\xDC\x8D\x8E\xDF';
+
+my $cp_1047 =   # EBCDIC code page 1047
+    '\x00\x01\x02\x03\x37\x2D\x2E\x2F\x16\x05\x15\x0B\x0C\x0D\x0E\x0F' .
+    '\x10\x11\x12\x13\x3C\x3D\x32\x26\x18\x19\x3F\x27\x1C\x1D\x1E\x1F' .
+    '\x40\x5A\x7F\x7B\x5B\x6C\x50\x7D\x4D\x5D\x5C\x4E\x6B\x60\x4B\x61' .
+    '\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\x7A\x5E\x4C\x7E\x6E\x6F' .
+    '\x7C\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xD1\xD2\xD3\xD4\xD5\xD6' .
+    '\xD7\xD8\xD9\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xAD\xE0\xBD\x5F\x6D' .
+    '\x79\x81\x82\x83\x84\x85\x86\x87\x88\x89\x91\x92\x93\x94\x95\x96' .
+    '\x97\x98\x99\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xC0\x4F\xD0\xA1\x07' .
+    '\x20\x21\x22\x23\x24\x25\x06\x17\x28\x29\x2A\x2B\x2C\x09\x0A\x1B' .
+    '\x30\x31\x1A\x33\x34\x35\x36\x08\x38\x39\x3A\x3B\x04\x14\x3E\xFF' .
+    '\x41\xAA\x4A\xB1\x9F\xB2\x6A\xB5\xBB\xB4\x9A\x8A\xB0\xCA\xAF\xBC' .
+    '\x90\x8F\xEA\xFA\xBE\xA0\xB6\xB3\x9D\xDA\x9B\x8B\xB7\xB8\xB9\xAB' .
+    '\x64\x65\x62\x66\x63\x67\x9E\x68\x74\x71\x72\x73\x78\x75\x76\x77' .
+    '\xAC\x69\xED\xEE\xEB\xEF\xEC\xBF\x80\xFD\xFE\xFB\xFC\xBA\xAE\x59' .
+    '\x44\x45\x42\x46\x43\x47\x9C\x48\x54\x51\x52\x53\x58\x55\x56\x57' .
+    '\x8C\x49\xCD\xCE\xCB\xCF\xCC\xE1\x70\xDD\xDE\xDB\xDC\x8D\x8E\xDF';
+
+my $cp_bc = # EBCDIC code page POSiX-BC
+    '\x00\x01\x02\x03\x37\x2D\x2E\x2F\x16\x05\x15\x0B\x0C\x0D\x0E\x0F' .
+    '\x10\x11\x12\x13\x3C\x3D\x32\x26\x18\x19\x3F\x27\x1C\x1D\x1E\x1F' .
+    '\x40\x5A\x7F\x7B\x5B\x6C\x50\x7D\x4D\x5D\x5C\x4E\x6B\x60\x4B\x61' .
+    '\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\x7A\x5E\x4C\x7E\x6E\x6F' .
+    '\x7C\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xD1\xD2\xD3\xD4\xD5\xD6' .
+    '\xD7\xD8\xD9\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xBB\xBC\xBD\x6A\x6D' .
+    '\x4A\x81\x82\x83\x84\x85\x86\x87\x88\x89\x91\x92\x93\x94\x95\x96' .
+    '\x97\x98\x99\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xFB\x4F\xFD\xFF\x07' .
+    '\x20\x21\x22\x23\x24\x25\x06\x17\x28\x29\x2A\x2B\x2C\x09\x0A\x1B' .
+    '\x30\x31\x1A\x33\x34\x35\x36\x08\x38\x39\x3A\x3B\x04\x14\x3E\x5F' .
+    '\x41\xAA\xB0\xB1\x9F\xB2\xD0\xB5\x79\xB4\x9A\x8A\xBA\xCA\xAF\xA1' .
+    '\x90\x8F\xEA\xFA\xBE\xA0\xB6\xB3\x9D\xDA\x9B\x8B\xB7\xB8\xB9\xAB' .
+    '\x64\x65\x62\x66\x63\x67\x9E\x68\x74\x71\x72\x73\x78\x75\x76\x77' .
+    '\xAC\x69\xED\xEE\xEB\xEF\xEC\xBF\x80\xE0\xFE\xDD\xFC\xAD\xAE\x59' .
+    '\x44\x45\x42\x46\x43\x47\x9C\x48\x54\x51\x52\x53\x58\x55\x56\x57' .
+    '\x8C\x49\xCD\xCE\xCB\xCF\xCC\xE1\x70\xC0\xDE\xDB\xDC\x8D\x8E\xDF';
+
+my $straight =  # Avoid ranges
+    '\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F' .
+    '\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F' .
+    '\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2A\x2B\x2C\x2D\x2E\x2F' .
+    '\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3A\x3B\x3C\x3D\x3E\x3F' .
+    '\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4A\x4B\x4C\x4D\x4E\x4F' .
+    '\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5A\x5B\x5C\x5D\x5E\x5F' .
+    '\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6A\x6B\x6C\x6D\x6E\x6F' .
+    '\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7A\x7B\x7C\x7D\x7E\x7F' .
+    '\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F' .
+    '\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F' .
+    '\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF' .
+    '\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF' .
+    '\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF' .
+    '\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF' .
+    '\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF' .
+    '\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF';
+
+# The following 2 functions allow tests to work on both EBCDIC and
+# ASCII-ish platforms.  They convert string scalars between the native
+# character set and the set of 256 characters which is usually called
+# Latin1.
+#
+# These routines don't work on UTF-EBCDIC and UTF-8.
+
+sub native_to_latin1($) {
+    my $string = shift;
+
+    return $string if ord('^') == 94;   # ASCII, Latin1
+    my $cp;
+    if (ord('^') == 95) {    # EBCDIC 1047
+        $cp = \$cp_1047;
+    }
+    elsif (ord('^') == 106) {   # EBCDIC POSIX-BC
+        $cp = \$cp_bc;
+    }
+    elsif (ord('^') == 176)  {   # EBCDIC 037 */
+        $cp = \$cp_0037;
+    }
+    else {
+        die "Unknown native character set";
+    }
+
+    eval '$string =~ tr/' . $$cp . '/' . $straight . '/';
+    return $string;
+}
+
+sub latin1_to_native($) {
+    my $string = shift;
+
+    return $string if ord('^') == 94;   # ASCII, Latin1
+    my $cp;
+    if (ord('^') == 95) {    # EBCDIC 1047
+        $cp = \$cp_1047;
+    }
+    elsif (ord('^') == 106) {   # EBCDIC POSIX-BC
+        $cp = \$cp_bc;
+    }
+    elsif (ord('^') == 176)  {   # EBCDIC 037 */
+        $cp = \$cp_0037;
+    }
+    else {
+        die "Unknown native character set";
+    }
+
+    eval '$string =~ tr/' . $straight . '/' . $$cp . '/';
+    return $string;
+}
+
+sub ord_latin1_to_native {
+    # given an input code point, return the platform's native
+    # equivalent value.  Anything above latin1 is itself.
+
+    my $ord = shift;
+    return $ord if $ord > 255;
+    return ord latin1_to_native(chr $ord);
+}
+
+sub ord_native_to_latin1 {
+    # given an input platform code point, return the latin1 equivalent value.
+    # Anything above latin1 is itself.
+
+    my $ord = shift;
+    return $ord if $ord > 255;
+    return ord native_to_latin1(chr $ord);
+}
+
+1;
diff -up perl-5.10.1/ext/threads/t/thread.t.oldthread perl-5.10.1/ext/threads/t/thread.t
--- perl-5.10.1/ext/threads/t/thread.t.oldthread	2009-04-15 14:25:00.000000000 +0200
+++ perl-5.10.1/ext/threads/t/thread.t	2011-01-07 13:26:03.195531935 +0100
@@ -2,12 +2,7 @@ use strict;
 use warnings;
 
 BEGIN {
-    if ($ENV{'PERL_CORE'}){
-        chdir 't';
-        unshift @INC, '../lib';
-    }
-
-    require($ENV{PERL_CORE} ? "./test.pl" : "./t/test.pl");
+    require($ENV{PERL_CORE} ? './test.pl' : './t/test.pl');
 
     use Config;
     if (! $Config{'useithreads'}) {
@@ -25,7 +20,7 @@ BEGIN {
     }
 
     $| = 1;
-    print("1..34\n");   ### Number of tests that will be run ###
+    print("1..35\n");   ### Number of tests that will be run ###
 };
 
 print("ok 1 - Loaded\n");
@@ -166,7 +161,7 @@ package main;
 
 # bugid #24165
 
-run_perl(prog => 'use threads 1.72;' .
+run_perl(prog => 'use threads 1.82;' .
                  'sub a{threads->create(shift)} $t = a sub{};' .
                  '$t->tid; $t->join; $t->tid',
          nolib => ($ENV{PERL_CORE}) ? 0 : 1,
@@ -309,6 +304,26 @@ SKIP: {
         "counts of calls to DESTROY");
 }
 
+# Bug 73330 - Apply magic to arg to ->object()
+{
+    my @tids :shared;
+
+    my $thr = threads->create(sub {
+                        lock(@tids);
+                        push(@tids, threads->tid());
+                        cond_signal(@tids);
+                    });
+
+    {
+        lock(@tids);
+        cond_wait(@tids) while (! @tids);
+    }
+
+    ok(threads->object($_), 'Got threads object') foreach (@tids);
+
+    $thr->join();
+}
+
 exit(0);
 
 # EOF

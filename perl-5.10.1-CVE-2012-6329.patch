From f5d37ac6705f1dea1f183b476f22a034f1a51c36 Mon Sep 17 00:00:00 2001
From: Brian Carlson <brian.carlson@cpanel.net>
Date: Mon, 4 Mar 2013 12:41:18 +0100
Subject: [PATCH] [PATCH] Fix misparsing of maketext strings

Case 61251: This commit fixes a misparse of maketext strings that could
lead to arbitrary code execution.  Basically, maketext was compiling
bracket notation into functions, but neglected to escape backslashes
inside the content or die on fully-qualified method names when
generating the code.  This change escapes all such backslashes and dies
when a method name with a colon or apostrophe is specified.

Petr Pisar: Ported to 1.13 bundled in perl-5.10.1.
---
 AUTHORS                     |  1 +
 lib/Locale/Maketext/Guts.pm | 24 ++++++++----------------
 2 files changed, 9 insertions(+), 16 deletions(-)

diff --git a/AUTHORS b/AUTHORS
index f2eec8c..7709b87 100644
--- a/AUTHORS
+++ b/AUTHORS
@@ -134,6 +134,7 @@ Brent B. Powers			<powers@ml.com>
 Brent Dax			<brentdax@cpan.org>
 Brooks D Boyd
 Brian Callaghan			<callagh@itginc.com>
+Brian Carlson			<brian.carlson@cpanel.net>
 Brian Clarke			<clarke@appliedmeta.com>
 brian d foy			<brian.d.foy@gmail.com>
 Brian Grossman
diff --git a/lib/Locale/Maketext/Guts.pm b/lib/Locale/Maketext/Guts.pm
index 9af292c..0a3bacf 100644
--- a/lib/Locale/Maketext/Guts.pm
+++ b/lib/Locale/Maketext/Guts.pm
@@ -140,21 +140,9 @@ sub _compile {
                         # 0-length method name means to just interpolate:
                         push @code, ' (';
                     }
-                    elsif($m =~ /^\w+(?:\:\:\w+)*$/s
-                            and $m !~ m/(?:^|\:)\d/s
-                        # exclude starting a (sub)package or symbol with a digit
+                    elsif($m =~ /^\w+$/s
+                        # exclude anything fancy, especially fully-qualified module names
                     ) {
-                        # Yes, it even supports the demented (and undocumented?)
-                        #  $obj->Foo::bar(...) syntax.
-                        $target->_die_pointing(
-                            $_[1], q{Can't use "SUPER::" in a bracket-group method},
-                            2 + length($c[-1])
-                        )
-                        if $m =~ m/^SUPER::/s;
-                        # Because for SUPER:: to work, we'd have to compile this into
-                        #  the right package, and that seems just not worth the bother,
-                        #  unless someone convinces me otherwise.
-
                         push @code, ' $_[0]->' . $m . '(';
                     }
                     else {
@@ -208,7 +196,9 @@ sub _compile {
             elsif(substr($1,0,1) ne '~') {
                 # it's stuff not containing "~" or "[" or "]"
                 # i.e., a literal blob
-                $c[-1] .= $1;
+                my $text = $1;
+                $text =~ s/\\/\\\\/g;
+                $c[-1] .= $text;
 
             }
             elsif($1 eq '~~') { # "~~"
@@ -246,7 +236,9 @@ sub _compile {
             else {
                 # It's a "~X" where X is not a special character.
                 # Consider it a literal ~ and X.
-                $c[-1] .= $1;
+                my $text = $1;
+                $text =~ s/\\/\\\\/g;
+                $c[-1] .= $text;
             }
         }
     }
-- 
1.8.1.4

